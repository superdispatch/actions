var __create = Object.create, __defProp = Object.defineProperty, __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty, __getOwnPropNames = Object.getOwnPropertyNames, __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: !0}), __name = (target, value) => __defProp(target, "name", {value, configurable: !0});
var __commonJS = (callback, module2) => () => (module2 || (module2 = {exports: {}}, callback(module2.exports, module2)), module2.exports), __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: !0});
}, __exportStar = (target, module2, desc) => {
  if (__markAsModule(target), module2 && typeof module2 == "object" || typeof module2 == "function")
    for (let key of __getOwnPropNames(module2))
      !__hasOwnProp.call(target, key) && key !== "default" && __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  return target;
}, __toModule = (module2) => module2 && module2.__esModule ? module2 : __exportStar(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", {value: module2, enumerable: !0}), module2);

// ../node_modules/@actions/core/lib/utils.js
var require_utils = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  function toCommandValue(input) {
    return input == null ? "" : typeof input == "string" || input instanceof String ? input : JSON.stringify(input);
  }
  __name(toCommandValue, "toCommandValue");
  exports2.toCommandValue = toCommandValue;
});

// ../node_modules/@actions/core/lib/command.js
var require_command = __commonJS((exports2) => {
  "use strict";
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
    return result.default = mod, result;
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var os4 = __importStar(require("os")), utils_1 = require_utils();
  function issueCommand(command, properties, message) {
    let cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os4.EOL);
  }
  __name(issueCommand, "issueCommand");
  exports2.issueCommand = issueCommand;
  function issue(name, message = "") {
    issueCommand(name, {}, message);
  }
  __name(issue, "issue");
  exports2.issue = issue;
  var CMD_STRING = "::", Command = class {
    constructor(command, properties, message) {
      command || (command = "missing.command"), this.command = command, this.properties = properties, this.message = message;
    }
    toString() {
      let cmdStr = CMD_STRING + this.command;
      if (this.properties && Object.keys(this.properties).length > 0) {
        cmdStr += " ";
        let first = !0;
        for (let key in this.properties)
          if (this.properties.hasOwnProperty(key)) {
            let val = this.properties[key];
            val && (first ? first = !1 : cmdStr += ",", cmdStr += `${key}=${escapeProperty(val)}`);
          }
      }
      return cmdStr += `${CMD_STRING}${escapeData(this.message)}`, cmdStr;
    }
  };
  __name(Command, "Command");
  function escapeData(s) {
    return utils_1.toCommandValue(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
  }
  __name(escapeData, "escapeData");
  function escapeProperty(s) {
    return utils_1.toCommandValue(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
  }
  __name(escapeProperty, "escapeProperty");
});

// ../node_modules/@actions/core/lib/file-command.js
var require_file_command = __commonJS((exports2) => {
  "use strict";
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
    return result.default = mod, result;
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var fs4 = __importStar(require("fs")), os4 = __importStar(require("os")), utils_1 = require_utils();
  function issueCommand(command, message) {
    let filePath = process.env[`GITHUB_${command}`];
    if (!filePath)
      throw new Error(`Unable to find environment variable for file command ${command}`);
    if (!fs4.existsSync(filePath))
      throw new Error(`Missing file at path: ${filePath}`);
    fs4.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os4.EOL}`, {
      encoding: "utf8"
    });
  }
  __name(issueCommand, "issueCommand");
  exports2.issueCommand = issueCommand;
});

// ../node_modules/@actions/core/lib/core.js
var require_core = __commonJS((exports2) => {
  "use strict";
  var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return __name(adopt, "adopt"), new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(fulfilled, "fulfilled");
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(rejected, "rejected");
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      __name(step, "step"), step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }, __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
    return result.default = mod, result;
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var command_1 = require_command(), file_command_1 = require_file_command(), utils_1 = require_utils(), os4 = __importStar(require("os")), path3 = __importStar(require("path")), ExitCode;
  (function(ExitCode2) {
    ExitCode2[ExitCode2.Success = 0] = "Success", ExitCode2[ExitCode2.Failure = 1] = "Failure";
  })(ExitCode = exports2.ExitCode || (exports2.ExitCode = {}));
  function exportVariable(name, val) {
    let convertedVal = utils_1.toCommandValue(val);
    if (process.env[name] = convertedVal, process.env.GITHUB_ENV || "") {
      let delimiter2 = "_GitHubActionsFileCommandDelimeter_", commandValue = `${name}<<${delimiter2}${os4.EOL}${convertedVal}${os4.EOL}${delimiter2}`;
      file_command_1.issueCommand("ENV", commandValue);
    } else
      command_1.issueCommand("set-env", {name}, convertedVal);
  }
  __name(exportVariable, "exportVariable");
  exports2.exportVariable = exportVariable;
  function setSecret(secret) {
    command_1.issueCommand("add-mask", {}, secret);
  }
  __name(setSecret, "setSecret");
  exports2.setSecret = setSecret;
  function addPath(inputPath) {
    process.env.GITHUB_PATH || "" ? file_command_1.issueCommand("PATH", inputPath) : command_1.issueCommand("add-path", {}, inputPath), process.env.PATH = `${inputPath}${path3.delimiter}${process.env.PATH}`;
  }
  __name(addPath, "addPath");
  exports2.addPath = addPath;
  function getInput2(name, options) {
    let val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
    if (options && options.required && !val)
      throw new Error(`Input required and not supplied: ${name}`);
    return val.trim();
  }
  __name(getInput2, "getInput");
  exports2.getInput = getInput2;
  function setOutput(name, value) {
    command_1.issueCommand("set-output", {name}, value);
  }
  __name(setOutput, "setOutput");
  exports2.setOutput = setOutput;
  function setCommandEcho(enabled2) {
    command_1.issue("echo", enabled2 ? "on" : "off");
  }
  __name(setCommandEcho, "setCommandEcho");
  exports2.setCommandEcho = setCommandEcho;
  function setFailed2(message) {
    process.exitCode = ExitCode.Failure, error(message);
  }
  __name(setFailed2, "setFailed");
  exports2.setFailed = setFailed2;
  function isDebug() {
    return process.env.RUNNER_DEBUG === "1";
  }
  __name(isDebug, "isDebug");
  exports2.isDebug = isDebug;
  function debug(message) {
    command_1.issueCommand("debug", {}, message);
  }
  __name(debug, "debug");
  exports2.debug = debug;
  function error(message) {
    command_1.issue("error", message instanceof Error ? message.toString() : message);
  }
  __name(error, "error");
  exports2.error = error;
  function warning2(message) {
    command_1.issue("warning", message instanceof Error ? message.toString() : message);
  }
  __name(warning2, "warning");
  exports2.warning = warning2;
  function info2(message) {
    process.stdout.write(message + os4.EOL);
  }
  __name(info2, "info");
  exports2.info = info2;
  function startGroup(name) {
    command_1.issue("group", name);
  }
  __name(startGroup, "startGroup");
  exports2.startGroup = startGroup;
  function endGroup() {
    command_1.issue("endgroup");
  }
  __name(endGroup, "endGroup");
  exports2.endGroup = endGroup;
  function group2(name, fn) {
    return __awaiter2(this, void 0, void 0, function* () {
      startGroup(name);
      let result;
      try {
        result = yield fn();
      } finally {
        endGroup();
      }
      return result;
    });
  }
  __name(group2, "group");
  exports2.group = group2;
  function saveState(name, value) {
    command_1.issueCommand("save-state", {name}, value);
  }
  __name(saveState, "saveState");
  exports2.saveState = saveState;
  function getState(name) {
    return process.env[`STATE_${name}`] || "";
  }
  __name(getState, "getState");
  exports2.getState = getState;
});

// ../node_modules/@actions/io/lib/io-util.js
var require_io_util = __commonJS((exports2) => {
  "use strict";
  var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return __name(adopt, "adopt"), new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(fulfilled, "fulfilled");
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(rejected, "rejected");
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      __name(step, "step"), step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }, _a;
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var assert_1 = require("assert"), fs4 = require("fs"), path3 = require("path");
  _a = fs4.promises, exports2.chmod = _a.chmod, exports2.copyFile = _a.copyFile, exports2.lstat = _a.lstat, exports2.mkdir = _a.mkdir, exports2.readdir = _a.readdir, exports2.readlink = _a.readlink, exports2.rename = _a.rename, exports2.rmdir = _a.rmdir, exports2.stat = _a.stat, exports2.symlink = _a.symlink, exports2.unlink = _a.unlink;
  exports2.IS_WINDOWS = process.platform === "win32";
  function exists(fsPath) {
    return __awaiter2(this, void 0, void 0, function* () {
      try {
        yield exports2.stat(fsPath);
      } catch (err) {
        if (err.code === "ENOENT")
          return !1;
        throw err;
      }
      return !0;
    });
  }
  __name(exists, "exists");
  exports2.exists = exists;
  function isDirectory(fsPath, useStat = !1) {
    return __awaiter2(this, void 0, void 0, function* () {
      return (useStat ? yield exports2.stat(fsPath) : yield exports2.lstat(fsPath)).isDirectory();
    });
  }
  __name(isDirectory, "isDirectory");
  exports2.isDirectory = isDirectory;
  function isRooted(p) {
    if (p = normalizeSeparators(p), !p)
      throw new Error('isRooted() parameter "p" cannot be empty');
    return exports2.IS_WINDOWS ? p.startsWith("\\") || /^[A-Z]:/i.test(p) : p.startsWith("/");
  }
  __name(isRooted, "isRooted");
  exports2.isRooted = isRooted;
  function mkdirP(fsPath, maxDepth = 1e3, depth = 1) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (assert_1.ok(fsPath, "a path argument must be provided"), fsPath = path3.resolve(fsPath), depth >= maxDepth)
        return exports2.mkdir(fsPath);
      try {
        yield exports2.mkdir(fsPath);
        return;
      } catch (err) {
        switch (err.code) {
          case "ENOENT": {
            yield mkdirP(path3.dirname(fsPath), maxDepth, depth + 1), yield exports2.mkdir(fsPath);
            return;
          }
          default: {
            let stats;
            try {
              stats = yield exports2.stat(fsPath);
            } catch (err2) {
              throw err;
            }
            if (!stats.isDirectory())
              throw err;
          }
        }
      }
    });
  }
  __name(mkdirP, "mkdirP");
  exports2.mkdirP = mkdirP;
  function tryGetExecutablePath(filePath, extensions) {
    return __awaiter2(this, void 0, void 0, function* () {
      let stats;
      try {
        stats = yield exports2.stat(filePath);
      } catch (err) {
        err.code !== "ENOENT" && console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
      }
      if (stats && stats.isFile()) {
        if (exports2.IS_WINDOWS) {
          let upperExt = path3.extname(filePath).toUpperCase();
          if (extensions.some((validExt) => validExt.toUpperCase() === upperExt))
            return filePath;
        } else if (isUnixExecutable(stats))
          return filePath;
      }
      let originalFilePath = filePath;
      for (let extension of extensions) {
        filePath = originalFilePath + extension, stats = void 0;
        try {
          stats = yield exports2.stat(filePath);
        } catch (err) {
          err.code !== "ENOENT" && console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
        }
        if (stats && stats.isFile()) {
          if (exports2.IS_WINDOWS) {
            try {
              let directory = path3.dirname(filePath), upperName = path3.basename(filePath).toUpperCase();
              for (let actualName of yield exports2.readdir(directory))
                if (upperName === actualName.toUpperCase()) {
                  filePath = path3.join(directory, actualName);
                  break;
                }
            } catch (err) {
              console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
            }
            return filePath;
          } else if (isUnixExecutable(stats))
            return filePath;
        }
      }
      return "";
    });
  }
  __name(tryGetExecutablePath, "tryGetExecutablePath");
  exports2.tryGetExecutablePath = tryGetExecutablePath;
  function normalizeSeparators(p) {
    return p = p || "", exports2.IS_WINDOWS ? (p = p.replace(/\//g, "\\"), p.replace(/\\\\+/g, "\\")) : p.replace(/\/\/+/g, "/");
  }
  __name(normalizeSeparators, "normalizeSeparators");
  function isUnixExecutable(stats) {
    return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && stats.uid === process.getuid();
  }
  __name(isUnixExecutable, "isUnixExecutable");
});

// ../node_modules/@actions/io/lib/io.js
var require_io = __commonJS((exports2) => {
  "use strict";
  var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return __name(adopt, "adopt"), new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(fulfilled, "fulfilled");
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(rejected, "rejected");
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      __name(step, "step"), step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var childProcess = require("child_process"), path3 = require("path"), util_1 = require("util"), ioUtil = require_io_util(), exec = util_1.promisify(childProcess.exec);
  function cp(source, dest, options = {}) {
    return __awaiter2(this, void 0, void 0, function* () {
      let {force, recursive} = readCopyOptions(options), destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
      if (destStat && destStat.isFile() && !force)
        return;
      let newDest = destStat && destStat.isDirectory() ? path3.join(dest, path3.basename(source)) : dest;
      if (!(yield ioUtil.exists(source)))
        throw new Error(`no such file or directory: ${source}`);
      if ((yield ioUtil.stat(source)).isDirectory())
        if (recursive)
          yield cpDirRecursive(source, newDest, 0, force);
        else
          throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
      else {
        if (path3.relative(source, newDest) === "")
          throw new Error(`'${newDest}' and '${source}' are the same file`);
        yield copyFile(source, newDest, force);
      }
    });
  }
  __name(cp, "cp");
  exports2.cp = cp;
  function mv(source, dest, options = {}) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (yield ioUtil.exists(dest)) {
        let destExists = !0;
        if ((yield ioUtil.isDirectory(dest)) && (dest = path3.join(dest, path3.basename(source)), destExists = yield ioUtil.exists(dest)), destExists)
          if (options.force == null || options.force)
            yield rmRF(dest);
          else
            throw new Error("Destination already exists");
      }
      yield mkdirP(path3.dirname(dest)), yield ioUtil.rename(source, dest);
    });
  }
  __name(mv, "mv");
  exports2.mv = mv;
  function rmRF(inputPath) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (ioUtil.IS_WINDOWS) {
        try {
          (yield ioUtil.isDirectory(inputPath, !0)) ? yield exec(`rd /s /q "${inputPath}"`) : yield exec(`del /f /a "${inputPath}"`);
        } catch (err) {
          if (err.code !== "ENOENT")
            throw err;
        }
        try {
          yield ioUtil.unlink(inputPath);
        } catch (err) {
          if (err.code !== "ENOENT")
            throw err;
        }
      } else {
        let isDir = !1;
        try {
          isDir = yield ioUtil.isDirectory(inputPath);
        } catch (err) {
          if (err.code !== "ENOENT")
            throw err;
          return;
        }
        isDir ? yield exec(`rm -rf "${inputPath}"`) : yield ioUtil.unlink(inputPath);
      }
    });
  }
  __name(rmRF, "rmRF");
  exports2.rmRF = rmRF;
  function mkdirP(fsPath) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield ioUtil.mkdirP(fsPath);
    });
  }
  __name(mkdirP, "mkdirP");
  exports2.mkdirP = mkdirP;
  function which(tool, check) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (!tool)
        throw new Error("parameter 'tool' is required");
      if (check && !(yield which(tool, !1)))
        throw ioUtil.IS_WINDOWS ? new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`) : new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
      try {
        let extensions = [];
        if (ioUtil.IS_WINDOWS && process.env.PATHEXT)
          for (let extension of process.env.PATHEXT.split(path3.delimiter))
            extension && extensions.push(extension);
        if (ioUtil.isRooted(tool)) {
          let filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
          return filePath || "";
        }
        if (tool.includes("/") || ioUtil.IS_WINDOWS && tool.includes("\\"))
          return "";
        let directories = [];
        if (process.env.PATH)
          for (let p of process.env.PATH.split(path3.delimiter))
            p && directories.push(p);
        for (let directory of directories) {
          let filePath = yield ioUtil.tryGetExecutablePath(directory + path3.sep + tool, extensions);
          if (filePath)
            return filePath;
        }
        return "";
      } catch (err) {
        throw new Error(`which failed with message ${err.message}`);
      }
    });
  }
  __name(which, "which");
  exports2.which = which;
  function readCopyOptions(options) {
    let force = options.force == null ? !0 : options.force, recursive = Boolean(options.recursive);
    return {force, recursive};
  }
  __name(readCopyOptions, "readCopyOptions");
  function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (currentDepth >= 255)
        return;
      currentDepth++, yield mkdirP(destDir);
      let files = yield ioUtil.readdir(sourceDir);
      for (let fileName of files) {
        let srcFile = `${sourceDir}/${fileName}`, destFile = `${destDir}/${fileName}`;
        (yield ioUtil.lstat(srcFile)).isDirectory() ? yield cpDirRecursive(srcFile, destFile, currentDepth, force) : yield copyFile(srcFile, destFile, force);
      }
      yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
    });
  }
  __name(cpDirRecursive, "cpDirRecursive");
  function copyFile(srcFile, destFile, force) {
    return __awaiter2(this, void 0, void 0, function* () {
      if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
        try {
          yield ioUtil.lstat(destFile), yield ioUtil.unlink(destFile);
        } catch (e) {
          e.code === "EPERM" && (yield ioUtil.chmod(destFile, "0666"), yield ioUtil.unlink(destFile));
        }
        let symlinkFull = yield ioUtil.readlink(srcFile);
        yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? "junction" : null);
      } else
        (!(yield ioUtil.exists(destFile)) || force) && (yield ioUtil.copyFile(srcFile, destFile));
    });
  }
  __name(copyFile, "copyFile");
});

// ../node_modules/@actions/exec/lib/toolrunner.js
var require_toolrunner = __commonJS((exports2) => {
  "use strict";
  var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return __name(adopt, "adopt"), new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(fulfilled, "fulfilled");
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(rejected, "rejected");
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      __name(step, "step"), step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }, __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
    return result.default = mod, result;
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var os4 = __importStar(require("os")), events = __importStar(require("events")), child = __importStar(require("child_process")), path3 = __importStar(require("path")), io = __importStar(require_io()), ioUtil = __importStar(require_io_util()), IS_WINDOWS = process.platform === "win32", ToolRunner = class extends events.EventEmitter {
    constructor(toolPath, args, options) {
      super();
      if (!toolPath)
        throw new Error("Parameter 'toolPath' cannot be null or empty.");
      this.toolPath = toolPath, this.args = args || [], this.options = options || {};
    }
    _debug(message) {
      this.options.listeners && this.options.listeners.debug && this.options.listeners.debug(message);
    }
    _getCommandString(options, noPrefix) {
      let toolPath = this._getSpawnFileName(), args = this._getSpawnArgs(options), cmd = noPrefix ? "" : "[command]";
      if (IS_WINDOWS)
        if (this._isCmdFile()) {
          cmd += toolPath;
          for (let a of args)
            cmd += ` ${a}`;
        } else if (options.windowsVerbatimArguments) {
          cmd += `"${toolPath}"`;
          for (let a of args)
            cmd += ` ${a}`;
        } else {
          cmd += this._windowsQuoteCmdArg(toolPath);
          for (let a of args)
            cmd += ` ${this._windowsQuoteCmdArg(a)}`;
        }
      else {
        cmd += toolPath;
        for (let a of args)
          cmd += ` ${a}`;
      }
      return cmd;
    }
    _processLineBuffer(data, strBuffer, onLine) {
      try {
        let s = strBuffer + data.toString(), n = s.indexOf(os4.EOL);
        for (; n > -1; ) {
          let line = s.substring(0, n);
          onLine(line), s = s.substring(n + os4.EOL.length), n = s.indexOf(os4.EOL);
        }
        strBuffer = s;
      } catch (err) {
        this._debug(`error processing line. Failed with error ${err}`);
      }
    }
    _getSpawnFileName() {
      return IS_WINDOWS && this._isCmdFile() ? process.env.COMSPEC || "cmd.exe" : this.toolPath;
    }
    _getSpawnArgs(options) {
      if (IS_WINDOWS && this._isCmdFile()) {
        let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
        for (let a of this.args)
          argline += " ", argline += options.windowsVerbatimArguments ? a : this._windowsQuoteCmdArg(a);
        return argline += '"', [argline];
      }
      return this.args;
    }
    _endsWith(str, end) {
      return str.endsWith(end);
    }
    _isCmdFile() {
      let upperToolPath = this.toolPath.toUpperCase();
      return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
    }
    _windowsQuoteCmdArg(arg) {
      if (!this._isCmdFile())
        return this._uvQuoteCmdArg(arg);
      if (!arg)
        return '""';
      let cmdSpecialChars = [
        " ",
        "	",
        "&",
        "(",
        ")",
        "[",
        "]",
        "{",
        "}",
        "^",
        "=",
        ";",
        "!",
        "'",
        "+",
        ",",
        "`",
        "~",
        "|",
        "<",
        ">",
        '"'
      ], needsQuotes = !1;
      for (let char of arg)
        if (cmdSpecialChars.some((x) => x === char)) {
          needsQuotes = !0;
          break;
        }
      if (!needsQuotes)
        return arg;
      let reverse = '"', quoteHit = !0;
      for (let i = arg.length; i > 0; i--)
        reverse += arg[i - 1], quoteHit && arg[i - 1] === "\\" ? reverse += "\\" : arg[i - 1] === '"' ? (quoteHit = !0, reverse += '"') : quoteHit = !1;
      return reverse += '"', reverse.split("").reverse().join("");
    }
    _uvQuoteCmdArg(arg) {
      if (!arg)
        return '""';
      if (!arg.includes(" ") && !arg.includes("	") && !arg.includes('"'))
        return arg;
      if (!arg.includes('"') && !arg.includes("\\"))
        return `"${arg}"`;
      let reverse = '"', quoteHit = !0;
      for (let i = arg.length; i > 0; i--)
        reverse += arg[i - 1], quoteHit && arg[i - 1] === "\\" ? reverse += "\\" : arg[i - 1] === '"' ? (quoteHit = !0, reverse += "\\") : quoteHit = !1;
      return reverse += '"', reverse.split("").reverse().join("");
    }
    _cloneExecOptions(options) {
      options = options || {};
      let result = {
        cwd: options.cwd || process.cwd(),
        env: options.env || process.env,
        silent: options.silent || !1,
        windowsVerbatimArguments: options.windowsVerbatimArguments || !1,
        failOnStdErr: options.failOnStdErr || !1,
        ignoreReturnCode: options.ignoreReturnCode || !1,
        delay: options.delay || 1e4
      };
      return result.outStream = options.outStream || process.stdout, result.errStream = options.errStream || process.stderr, result;
    }
    _getSpawnOptions(options, toolPath) {
      options = options || {};
      let result = {};
      return result.cwd = options.cwd, result.env = options.env, result.windowsVerbatimArguments = options.windowsVerbatimArguments || this._isCmdFile(), options.windowsVerbatimArguments && (result.argv0 = `"${toolPath}"`), result;
    }
    exec() {
      return __awaiter2(this, void 0, void 0, function* () {
        return !ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\")) && (this.toolPath = path3.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath)), this.toolPath = yield io.which(this.toolPath, !0), new Promise((resolve, reject) => {
          this._debug(`exec tool: ${this.toolPath}`), this._debug("arguments:");
          for (let arg of this.args)
            this._debug(`   ${arg}`);
          let optionsNonNull = this._cloneExecOptions(this.options);
          !optionsNonNull.silent && optionsNonNull.outStream && optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os4.EOL);
          let state = new ExecState(optionsNonNull, this.toolPath);
          state.on("debug", (message) => {
            this._debug(message);
          });
          let fileName = this._getSpawnFileName(), cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName)), stdbuffer = "";
          cp.stdout && cp.stdout.on("data", (data) => {
            this.options.listeners && this.options.listeners.stdout && this.options.listeners.stdout(data), !optionsNonNull.silent && optionsNonNull.outStream && optionsNonNull.outStream.write(data), this._processLineBuffer(data, stdbuffer, (line) => {
              this.options.listeners && this.options.listeners.stdline && this.options.listeners.stdline(line);
            });
          });
          let errbuffer = "";
          if (cp.stderr && cp.stderr.on("data", (data) => {
            state.processStderr = !0, this.options.listeners && this.options.listeners.stderr && this.options.listeners.stderr(data), !optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream && (optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream).write(data), this._processLineBuffer(data, errbuffer, (line) => {
              this.options.listeners && this.options.listeners.errline && this.options.listeners.errline(line);
            });
          }), cp.on("error", (err) => {
            state.processError = err.message, state.processExited = !0, state.processClosed = !0, state.CheckComplete();
          }), cp.on("exit", (code) => {
            state.processExitCode = code, state.processExited = !0, this._debug(`Exit code ${code} received from tool '${this.toolPath}'`), state.CheckComplete();
          }), cp.on("close", (code) => {
            state.processExitCode = code, state.processExited = !0, state.processClosed = !0, this._debug(`STDIO streams have closed for tool '${this.toolPath}'`), state.CheckComplete();
          }), state.on("done", (error, exitCode) => {
            stdbuffer.length > 0 && this.emit("stdline", stdbuffer), errbuffer.length > 0 && this.emit("errline", errbuffer), cp.removeAllListeners(), error ? reject(error) : resolve(exitCode);
          }), this.options.input) {
            if (!cp.stdin)
              throw new Error("child process missing stdin");
            cp.stdin.end(this.options.input);
          }
        });
      });
    }
  };
  __name(ToolRunner, "ToolRunner");
  exports2.ToolRunner = ToolRunner;
  function argStringToArray(argString) {
    let args = [], inQuotes = !1, escaped = !1, arg = "";
    function append(c) {
      escaped && c !== '"' && (arg += "\\"), arg += c, escaped = !1;
    }
    __name(append, "append");
    for (let i = 0; i < argString.length; i++) {
      let c = argString.charAt(i);
      if (c === '"') {
        escaped ? append(c) : inQuotes = !inQuotes;
        continue;
      }
      if (c === "\\" && escaped) {
        append(c);
        continue;
      }
      if (c === "\\" && inQuotes) {
        escaped = !0;
        continue;
      }
      if (c === " " && !inQuotes) {
        arg.length > 0 && (args.push(arg), arg = "");
        continue;
      }
      append(c);
    }
    return arg.length > 0 && args.push(arg.trim()), args;
  }
  __name(argStringToArray, "argStringToArray");
  exports2.argStringToArray = argStringToArray;
  var ExecState = class extends events.EventEmitter {
    constructor(options, toolPath) {
      super();
      if (this.processClosed = !1, this.processError = "", this.processExitCode = 0, this.processExited = !1, this.processStderr = !1, this.delay = 1e4, this.done = !1, this.timeout = null, !toolPath)
        throw new Error("toolPath must not be empty");
      this.options = options, this.toolPath = toolPath, options.delay && (this.delay = options.delay);
    }
    CheckComplete() {
      this.done || (this.processClosed ? this._setResult() : this.processExited && (this.timeout = setTimeout(ExecState.HandleTimeout, this.delay, this)));
    }
    _debug(message) {
      this.emit("debug", message);
    }
    _setResult() {
      let error;
      this.processExited && (this.processError ? error = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`) : this.processExitCode !== 0 && !this.options.ignoreReturnCode ? error = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`) : this.processStderr && this.options.failOnStdErr && (error = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`))), this.timeout && (clearTimeout(this.timeout), this.timeout = null), this.done = !0, this.emit("done", error, this.processExitCode);
    }
    static HandleTimeout(state) {
      if (!state.done) {
        if (!state.processClosed && state.processExited) {
          let message = `The STDIO streams did not close within ${state.delay / 1e3} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
          state._debug(message);
        }
        state._setResult();
      }
    }
  };
  __name(ExecState, "ExecState");
});

// ../node_modules/@actions/exec/lib/exec.js
var require_exec = __commonJS((exports2) => {
  "use strict";
  var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return __name(adopt, "adopt"), new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(fulfilled, "fulfilled");
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(rejected, "rejected");
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      __name(step, "step"), step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }, __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
    return result.default = mod, result;
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var tr = __importStar(require_toolrunner());
  function exec(commandLine, args, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      let commandArgs = tr.argStringToArray(commandLine);
      if (commandArgs.length === 0)
        throw new Error("Parameter 'commandLine' cannot be null or empty.");
      let toolPath = commandArgs[0];
      return args = commandArgs.slice(1).concat(args || []), new tr.ToolRunner(toolPath, args, options).exec();
    });
  }
  __name(exec, "exec");
  exports2.exec = exec;
});

// ../node_modules/@actions/glob/lib/internal-glob-options-helper.js
var require_internal_glob_options_helper = __commonJS((exports2) => {
  "use strict";
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
    return result.default = mod, result;
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var core = __importStar(require_core());
  function getOptions(copy) {
    let result = {
      followSymbolicLinks: !0,
      implicitDescendants: !0,
      omitBrokenSymbolicLinks: !0
    };
    return copy && (typeof copy.followSymbolicLinks == "boolean" && (result.followSymbolicLinks = copy.followSymbolicLinks, core.debug(`followSymbolicLinks '${result.followSymbolicLinks}'`)), typeof copy.implicitDescendants == "boolean" && (result.implicitDescendants = copy.implicitDescendants, core.debug(`implicitDescendants '${result.implicitDescendants}'`)), typeof copy.omitBrokenSymbolicLinks == "boolean" && (result.omitBrokenSymbolicLinks = copy.omitBrokenSymbolicLinks, core.debug(`omitBrokenSymbolicLinks '${result.omitBrokenSymbolicLinks}'`))), result;
  }
  __name(getOptions, "getOptions");
  exports2.getOptions = getOptions;
});

// ../node_modules/@actions/glob/lib/internal-path-helper.js
var require_internal_path_helper = __commonJS((exports2) => {
  "use strict";
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
    return result.default = mod, result;
  }, __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var path3 = __importStar(require("path")), assert_1 = __importDefault(require("assert")), IS_WINDOWS = process.platform === "win32";
  function dirname(p) {
    if (p = safeTrimTrailingSeparator(p), IS_WINDOWS && /^\\\\[^\\]+(\\[^\\]+)?$/.test(p))
      return p;
    let result = path3.dirname(p);
    return IS_WINDOWS && /^\\\\[^\\]+\\[^\\]+\\$/.test(result) && (result = safeTrimTrailingSeparator(result)), result;
  }
  __name(dirname, "dirname");
  exports2.dirname = dirname;
  function ensureAbsoluteRoot(root, itemPath) {
    if (assert_1.default(root, "ensureAbsoluteRoot parameter 'root' must not be empty"), assert_1.default(itemPath, "ensureAbsoluteRoot parameter 'itemPath' must not be empty"), hasAbsoluteRoot(itemPath))
      return itemPath;
    if (IS_WINDOWS) {
      if (itemPath.match(/^[A-Z]:[^\\/]|^[A-Z]:$/i)) {
        let cwd = process.cwd();
        return assert_1.default(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`), itemPath[0].toUpperCase() === cwd[0].toUpperCase() ? itemPath.length === 2 ? `${itemPath[0]}:\\${cwd.substr(3)}` : (cwd.endsWith("\\") || (cwd += "\\"), `${itemPath[0]}:\\${cwd.substr(3)}${itemPath.substr(2)}`) : `${itemPath[0]}:\\${itemPath.substr(2)}`;
      } else if (normalizeSeparators(itemPath).match(/^\\$|^\\[^\\]/)) {
        let cwd = process.cwd();
        return assert_1.default(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`), `${cwd[0]}:\\${itemPath.substr(1)}`;
      }
    }
    return assert_1.default(hasAbsoluteRoot(root), "ensureAbsoluteRoot parameter 'root' must have an absolute root"), root.endsWith("/") || IS_WINDOWS && root.endsWith("\\") || (root += path3.sep), root + itemPath;
  }
  __name(ensureAbsoluteRoot, "ensureAbsoluteRoot");
  exports2.ensureAbsoluteRoot = ensureAbsoluteRoot;
  function hasAbsoluteRoot(itemPath) {
    return assert_1.default(itemPath, "hasAbsoluteRoot parameter 'itemPath' must not be empty"), itemPath = normalizeSeparators(itemPath), IS_WINDOWS ? itemPath.startsWith("\\\\") || /^[A-Z]:\\/i.test(itemPath) : itemPath.startsWith("/");
  }
  __name(hasAbsoluteRoot, "hasAbsoluteRoot");
  exports2.hasAbsoluteRoot = hasAbsoluteRoot;
  function hasRoot(itemPath) {
    return assert_1.default(itemPath, "isRooted parameter 'itemPath' must not be empty"), itemPath = normalizeSeparators(itemPath), IS_WINDOWS ? itemPath.startsWith("\\") || /^[A-Z]:/i.test(itemPath) : itemPath.startsWith("/");
  }
  __name(hasRoot, "hasRoot");
  exports2.hasRoot = hasRoot;
  function normalizeSeparators(p) {
    return p = p || "", IS_WINDOWS ? (p = p.replace(/\//g, "\\"), (/^\\\\+[^\\]/.test(p) ? "\\" : "") + p.replace(/\\\\+/g, "\\")) : p.replace(/\/\/+/g, "/");
  }
  __name(normalizeSeparators, "normalizeSeparators");
  exports2.normalizeSeparators = normalizeSeparators;
  function safeTrimTrailingSeparator(p) {
    return p ? (p = normalizeSeparators(p), !p.endsWith(path3.sep) || p === path3.sep || IS_WINDOWS && /^[A-Z]:\\$/i.test(p) ? p : p.substr(0, p.length - 1)) : "";
  }
  __name(safeTrimTrailingSeparator, "safeTrimTrailingSeparator");
  exports2.safeTrimTrailingSeparator = safeTrimTrailingSeparator;
});

// ../node_modules/@actions/glob/lib/internal-match-kind.js
var require_internal_match_kind = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var MatchKind;
  (function(MatchKind2) {
    MatchKind2[MatchKind2.None = 0] = "None", MatchKind2[MatchKind2.Directory = 1] = "Directory", MatchKind2[MatchKind2.File = 2] = "File", MatchKind2[MatchKind2.All = 3] = "All";
  })(MatchKind = exports2.MatchKind || (exports2.MatchKind = {}));
});

// ../node_modules/@actions/glob/lib/internal-pattern-helper.js
var require_internal_pattern_helper = __commonJS((exports2) => {
  "use strict";
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
    return result.default = mod, result;
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var pathHelper = __importStar(require_internal_path_helper()), internal_match_kind_1 = require_internal_match_kind(), IS_WINDOWS = process.platform === "win32";
  function getSearchPaths(patterns) {
    patterns = patterns.filter((x) => !x.negate);
    let searchPathMap = {};
    for (let pattern of patterns) {
      let key = IS_WINDOWS ? pattern.searchPath.toUpperCase() : pattern.searchPath;
      searchPathMap[key] = "candidate";
    }
    let result = [];
    for (let pattern of patterns) {
      let key = IS_WINDOWS ? pattern.searchPath.toUpperCase() : pattern.searchPath;
      if (searchPathMap[key] === "included")
        continue;
      let foundAncestor = !1, tempKey = key, parent = pathHelper.dirname(tempKey);
      for (; parent !== tempKey; ) {
        if (searchPathMap[parent]) {
          foundAncestor = !0;
          break;
        }
        tempKey = parent, parent = pathHelper.dirname(tempKey);
      }
      foundAncestor || (result.push(pattern.searchPath), searchPathMap[key] = "included");
    }
    return result;
  }
  __name(getSearchPaths, "getSearchPaths");
  exports2.getSearchPaths = getSearchPaths;
  function match(patterns, itemPath) {
    let result = internal_match_kind_1.MatchKind.None;
    for (let pattern of patterns)
      pattern.negate ? result &= ~pattern.match(itemPath) : result |= pattern.match(itemPath);
    return result;
  }
  __name(match, "match");
  exports2.match = match;
  function partialMatch(patterns, itemPath) {
    return patterns.some((x) => !x.negate && x.partialMatch(itemPath));
  }
  __name(partialMatch, "partialMatch");
  exports2.partialMatch = partialMatch;
});

// ../node_modules/concat-map/index.js
var require_concat_map = __commonJS((exports2, module2) => {
  module2.exports = function(xs, fn) {
    for (var res = [], i = 0; i < xs.length; i++) {
      var x = fn(xs[i], i);
      isArray(x) ? res.push.apply(res, x) : res.push(x);
    }
    return res;
  };
  var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
});

// ../node_modules/balanced-match/index.js
var require_balanced_match = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = balanced;
  function balanced(a, b, str) {
    a instanceof RegExp && (a = maybeMatch(a, str)), b instanceof RegExp && (b = maybeMatch(b, str));
    var r = range(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  __name(balanced, "balanced");
  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }
  __name(maybeMatch, "maybeMatch");
  balanced.range = range;
  function range(a, b, str) {
    var begs, beg, left, right, result, ai = str.indexOf(a), bi = str.indexOf(b, ai + 1), i = ai;
    if (ai >= 0 && bi > 0) {
      for (begs = [], left = str.length; i >= 0 && !result; )
        i == ai ? (begs.push(i), ai = str.indexOf(a, i + 1)) : begs.length == 1 ? result = [begs.pop(), bi] : (beg = begs.pop(), beg < left && (left = beg, right = bi), bi = str.indexOf(b, i + 1)), i = ai < bi && ai >= 0 ? ai : bi;
      begs.length && (result = [left, right]);
    }
    return result;
  }
  __name(range, "range");
});

// ../node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS((exports2, module2) => {
  var concatMap = require_concat_map(), balanced = require_balanced_match();
  module2.exports = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0", escOpen = "\0OPEN" + Math.random() + "\0", escClose = "\0CLOSE" + Math.random() + "\0", escComma = "\0COMMA" + Math.random() + "\0", escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  __name(numeric, "numeric");
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  __name(escapeBraces, "escapeBraces");
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  __name(unescapeBraces, "unescapeBraces");
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [], m = balanced("{", "}", str);
    if (!m)
      return str.split(",");
    var pre = m.pre, body = m.body, post = m.post, p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    return post.length && (p[p.length - 1] += postParts.shift(), p.push.apply(p, postParts)), parts.push.apply(parts, p), parts;
  }
  __name(parseCommaParts, "parseCommaParts");
  function expandTop(str) {
    return str ? (str.substr(0, 2) === "{}" && (str = "\\{\\}" + str.substr(2)), expand(escapeBraces(str), !0).map(unescapeBraces)) : [];
  }
  __name(expandTop, "expandTop");
  function embrace(str) {
    return "{" + str + "}";
  }
  __name(embrace, "embrace");
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  __name(isPadded, "isPadded");
  function lte(i, y) {
    return i <= y;
  }
  __name(lte, "lte");
  function gte(i, y) {
    return i >= y;
  }
  __name(gte, "gte");
  function expand(str, isTop) {
    var expansions = [], m = balanced("{", "}", str);
    if (!m || /\$$/.test(m.pre))
      return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body), isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body), isSequence = isNumericSequence || isAlphaSequence, isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions)
      return m.post.match(/,.*\}/) ? (str = m.pre + "{" + m.body + escClose + m.post, expand(str)) : [str];
    var n;
    if (isSequence)
      n = m.body.split(/\.\./);
    else if (n = parseCommaParts(m.body), n.length === 1 && (n = expand(n[0], !1).map(embrace), n.length === 1)) {
      var post = m.post.length ? expand(m.post, !1) : [""];
      return post.map(function(p) {
        return m.pre + n[0] + p;
      });
    }
    var pre = m.pre, post = m.post.length ? expand(m.post, !1) : [""], N;
    if (isSequence) {
      var x = numeric(n[0]), y = numeric(n[1]), width = Math.max(n[0].length, n[1].length), incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1, test = lte, reverse = y < x;
      reverse && (incr *= -1, test = gte);
      var pad = n.some(isPadded);
      N = [];
      for (var i = x; test(i, y); i += incr) {
        var c;
        if (isAlphaSequence)
          c = String.fromCharCode(i), c === "\\" && (c = "");
        else if (c = String(i), pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join("0");
            i < 0 ? c = "-" + z + c.slice(1) : c = z + c;
          }
        }
        N.push(c);
      }
    } else
      N = concatMap(n, function(el) {
        return expand(el, !1);
      });
    for (var j = 0; j < N.length; j++)
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        (!isTop || isSequence || expansion) && expansions.push(expansion);
      }
    return expansions;
  }
  __name(expand, "expand");
});

// ../node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS((exports2, module2) => {
  module2.exports = minimatch;
  minimatch.Minimatch = Minimatch;
  var path3 = {sep: "/"};
  try {
    path3 = require("path");
  } catch (er) {
  }
  var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}, expand = require_brace_expansion(), plTypes = {
    "!": {open: "(?:(?!(?:", close: "))[^/]*?)"},
    "?": {open: "(?:", close: ")?"},
    "+": {open: "(?:", close: ")+"},
    "*": {open: "(?:", close: ")*"},
    "@": {open: "(?:", close: ")"}
  }, qmark = "[^/]", star = qmark + "*?", twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?", reSpecials = charSet("().*{}+?[]^$\\!");
  function charSet(s) {
    return s.split("").reduce(function(set, c) {
      return set[c] = !0, set;
    }, {});
  }
  __name(charSet, "charSet");
  var slashSplit = /\/+/;
  minimatch.filter = filter;
  function filter(pattern, options) {
    return options = options || {}, function(p, i, list) {
      return minimatch(p, pattern, options);
    };
  }
  __name(filter, "filter");
  function ext(a, b) {
    a = a || {}, b = b || {};
    var t = {};
    return Object.keys(b).forEach(function(k) {
      t[k] = b[k];
    }), Object.keys(a).forEach(function(k) {
      t[k] = a[k];
    }), t;
  }
  __name(ext, "ext");
  minimatch.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return minimatch;
    var orig = minimatch, m = /* @__PURE__ */ __name(function(p, pattern, options) {
      return orig.minimatch(p, pattern, ext(def, options));
    }, "minimatch");
    return m.Minimatch = /* @__PURE__ */ __name(function(pattern, options) {
      return new orig.Minimatch(pattern, ext(def, options));
    }, "Minimatch"), m;
  };
  Minimatch.defaults = function(def) {
    return !def || !Object.keys(def).length ? Minimatch : minimatch.defaults(def).Minimatch;
  };
  function minimatch(p, pattern, options) {
    if (typeof pattern != "string")
      throw new TypeError("glob pattern string required");
    return options || (options = {}), !options.nocomment && pattern.charAt(0) === "#" ? !1 : pattern.trim() === "" ? p === "" : new Minimatch(pattern, options).match(p);
  }
  __name(minimatch, "minimatch");
  function Minimatch(pattern, options) {
    if (!(this instanceof Minimatch))
      return new Minimatch(pattern, options);
    if (typeof pattern != "string")
      throw new TypeError("glob pattern string required");
    options || (options = {}), pattern = pattern.trim(), path3.sep !== "/" && (pattern = pattern.split(path3.sep).join("/")), this.options = options, this.set = [], this.pattern = pattern, this.regexp = null, this.negate = !1, this.comment = !1, this.empty = !1, this.make();
  }
  __name(Minimatch, "Minimatch");
  Minimatch.prototype.debug = function() {
  };
  Minimatch.prototype.make = make;
  function make() {
    if (!this._made) {
      var pattern = this.pattern, options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = !0;
        return;
      }
      if (!pattern) {
        this.empty = !0;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      options.debug && (this.debug = console.error), this.debug(this.pattern, set), set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      }), this.debug(this.pattern, set), set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this), this.debug(this.pattern, set), set = set.filter(function(s) {
        return s.indexOf(!1) === -1;
      }), this.debug(this.pattern, set), this.set = set;
    }
  }
  __name(make, "make");
  Minimatch.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern = this.pattern, negate = !1, options = this.options, negateOffset = 0;
    if (!options.nonegate) {
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++)
        negate = !negate, negateOffset++;
      negateOffset && (this.pattern = pattern.substr(negateOffset)), this.negate = negate;
    }
  }
  __name(parseNegate, "parseNegate");
  minimatch.braceExpand = function(pattern, options) {
    return braceExpand(pattern, options);
  };
  Minimatch.prototype.braceExpand = braceExpand;
  function braceExpand(pattern, options) {
    if (options || (this instanceof Minimatch ? options = this.options : options = {}), pattern = typeof pattern == "undefined" ? this.pattern : pattern, typeof pattern == "undefined")
      throw new TypeError("undefined pattern");
    return options.nobrace || !pattern.match(/\{.*\}/) ? [pattern] : expand(pattern);
  }
  __name(braceExpand, "braceExpand");
  Minimatch.prototype.parse = parse2;
  var SUBPARSE = {};
  function parse2(pattern, isSub) {
    if (pattern.length > 1024 * 64)
      throw new TypeError("pattern is too long");
    var options = this.options;
    if (!options.noglobstar && pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    var re = "", hasMagic = !!options.nocase, escaping = !1, patternListStack = [], negativeLists = [], stateChar, inClass = !1, reClassStart = -1, classStart = -1, patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", self = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star, hasMagic = !0;
            break;
          case "?":
            re += qmark, hasMagic = !0;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        self.debug("clearStateChar %j %j", stateChar, re), stateChar = !1;
      }
    }
    __name(clearStateChar, "clearStateChar");
    for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
      if (this.debug("%s	%s %s %j", pattern, i, re, c), escaping && reSpecials[c]) {
        re += "\\" + c, escaping = !1;
        continue;
      }
      switch (c) {
        case "/":
          return !1;
        case "\\":
          clearStateChar(), escaping = !0;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          if (this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c), inClass) {
            this.debug("  in class"), c === "!" && i === classStart + 1 && (c = "^"), re += c;
            continue;
          }
          self.debug("call clearStateChar %j", stateChar), clearStateChar(), stateChar = c, options.noext && clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          }), re += stateChar === "!" ? "(?:(?!(?:" : "(?:", this.debug("plType %j %j", stateChar, re), stateChar = !1;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re += "\\)";
            continue;
          }
          clearStateChar(), hasMagic = !0;
          var pl = patternListStack.pop();
          re += pl.close, pl.type === "!" && negativeLists.push(pl), pl.reEnd = re.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re += "\\|", escaping = !1;
            continue;
          }
          clearStateChar(), re += "|";
          continue;
        case "[":
          if (clearStateChar(), inClass) {
            re += "\\" + c;
            continue;
          }
          inClass = !0, classStart = i, reClassStart = re.length, re += c;
          continue;
        case "]":
          if (i === classStart + 1 || !inClass) {
            re += "\\" + c, escaping = !1;
            continue;
          }
          if (inClass) {
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]", hasMagic = hasMagic || sp[1], inClass = !1;
              continue;
            }
          }
          hasMagic = !0, inClass = !1, re += c;
          continue;
        default:
          clearStateChar(), escaping ? escaping = !1 : reSpecials[c] && !(c === "^" && inClass) && (re += "\\"), re += c;
      }
    }
    for (inClass && (cs = pattern.substr(classStart + 1), sp = this.parse(cs, SUBPARSE), re = re.substr(0, reClassStart) + "\\[" + sp[0], hasMagic = hasMagic || sp[1]), pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re, pl), tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
        return $2 || ($2 = "\\"), $1 + $1 + $2 + "|";
      }), this.debug(`tail=%j
   %s`, tail, tail, pl, re);
      var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = !0, re = re.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar(), escaping && (re += "\\\\");
    var addPatternStart = !1;
    switch (re.charAt(0)) {
      case ".":
      case "[":
      case "(":
        addPatternStart = !0;
    }
    for (var n = negativeLists.length - 1; n > -1; n--) {
      var nl = negativeLists[n], nlBefore = re.slice(0, nl.reStart), nlFirst = re.slice(nl.reStart, nl.reEnd - 8), nlLast = re.slice(nl.reEnd - 8, nl.reEnd), nlAfter = re.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1, cleanAfter = nlAfter;
      for (i = 0; i < openParensBefore; i++)
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      nlAfter = cleanAfter;
      var dollar = "";
      nlAfter === "" && isSub !== SUBPARSE && (dollar = "$");
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re = newRe;
    }
    if (re !== "" && hasMagic && (re = "(?=.)" + re), addPatternStart && (re = patternStart + re), isSub === SUBPARSE)
      return [re, hasMagic];
    if (!hasMagic)
      return globUnescape(pattern);
    var flags = options.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re + "$", flags);
    } catch (er) {
      return new RegExp("$.");
    }
    return regExp._glob = pattern, regExp._src = re, regExp;
  }
  __name(parse2, "parse");
  minimatch.makeRe = function(pattern, options) {
    return new Minimatch(pattern, options || {}).makeRe();
  };
  Minimatch.prototype.makeRe = makeRe;
  function makeRe() {
    if (this.regexp || this.regexp === !1)
      return this.regexp;
    var set = this.set;
    if (!set.length)
      return this.regexp = !1, this.regexp;
    var options = this.options, twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot, flags = options.nocase ? "i" : "", re = set.map(function(pattern) {
      return pattern.map(function(p) {
        return p === GLOBSTAR ? twoStar : typeof p == "string" ? regExpEscape(p) : p._src;
      }).join("\\/");
    }).join("|");
    re = "^(?:" + re + ")$", this.negate && (re = "^(?!" + re + ").*$");
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) {
      this.regexp = !1;
    }
    return this.regexp;
  }
  __name(makeRe, "makeRe");
  minimatch.match = function(list, pattern, options) {
    options = options || {};
    var mm = new Minimatch(pattern, options);
    return list = list.filter(function(f) {
      return mm.match(f);
    }), mm.options.nonull && !list.length && list.push(pattern), list;
  };
  Minimatch.prototype.match = match;
  function match(f, partial) {
    if (this.debug("match", f, this.pattern), this.comment)
      return !1;
    if (this.empty)
      return f === "";
    if (f === "/" && partial)
      return !0;
    var options = this.options;
    path3.sep !== "/" && (f = f.split(path3.sep).join("/")), f = f.split(slashSplit), this.debug(this.pattern, "split", f);
    var set = this.set;
    this.debug(this.pattern, "set", set);
    var filename, i;
    for (i = f.length - 1; i >= 0 && (filename = f[i], !filename); i--)
      ;
    for (i = 0; i < set.length; i++) {
      var pattern = set[i], file = f;
      options.matchBase && pattern.length === 1 && (file = [filename]);
      var hit = this.matchOne(file, pattern, partial);
      if (hit)
        return options.flipNegate ? !0 : !this.negate;
    }
    return options.flipNegate ? !1 : this.negate;
  }
  __name(match, "match");
  Minimatch.prototype.matchOne = function(file, pattern, partial) {
    var options = this.options;
    this.debug("matchOne", {this: this, file, pattern}), this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi], f = file[fi];
      if (this.debug(pattern, p, f), p === !1)
        return !1;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi, pr = pi + 1;
        if (pr === pl) {
          for (this.debug("** at the end"); fi < fl; fi++)
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return !1;
          return !0;
        }
        for (; fr < fl; ) {
          var swallowee = file[fr];
          if (this.debug(`
globstar while`, file, fr, pattern, pr, swallowee), this.matchOne(file.slice(fr), pattern.slice(pr), partial))
            return this.debug("globstar found match!", fr, fl, swallowee), !0;
          if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
            this.debug("dot detected!", file, fr, pattern, pr);
            break;
          }
          this.debug("globstar swallow a segment, and continue"), fr++;
        }
        return !!(partial && (this.debug(`
>>> no match, partial?`, file, fr, pattern, pr), fr === fl));
      }
      var hit;
      if (typeof p == "string" ? (options.nocase ? hit = f.toLowerCase() === p.toLowerCase() : hit = f === p, this.debug("string match", p, f, hit)) : (hit = f.match(p), this.debug("pattern match", p, f, hit)), !hit)
        return !1;
    }
    if (fi === fl && pi === pl)
      return !0;
    if (fi === fl)
      return partial;
    if (pi === pl) {
      var emptyFileEnd = fi === fl - 1 && file[fi] === "";
      return emptyFileEnd;
    }
    throw new Error("wtf?");
  };
  function globUnescape(s) {
    return s.replace(/\\(.)/g, "$1");
  }
  __name(globUnescape, "globUnescape");
  function regExpEscape(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  __name(regExpEscape, "regExpEscape");
});

// ../node_modules/@actions/glob/lib/internal-path.js
var require_internal_path = __commonJS((exports2) => {
  "use strict";
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
    return result.default = mod, result;
  }, __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var path3 = __importStar(require("path")), pathHelper = __importStar(require_internal_path_helper()), assert_1 = __importDefault(require("assert")), IS_WINDOWS = process.platform === "win32", Path = class {
    constructor(itemPath) {
      if (this.segments = [], typeof itemPath == "string")
        if (assert_1.default(itemPath, "Parameter 'itemPath' must not be empty"), itemPath = pathHelper.safeTrimTrailingSeparator(itemPath), !pathHelper.hasRoot(itemPath))
          this.segments = itemPath.split(path3.sep);
        else {
          let remaining = itemPath, dir = pathHelper.dirname(remaining);
          for (; dir !== remaining; ) {
            let basename = path3.basename(remaining);
            this.segments.unshift(basename), remaining = dir, dir = pathHelper.dirname(remaining);
          }
          this.segments.unshift(remaining);
        }
      else {
        assert_1.default(itemPath.length > 0, "Parameter 'itemPath' must not be an empty array");
        for (let i = 0; i < itemPath.length; i++) {
          let segment = itemPath[i];
          assert_1.default(segment, "Parameter 'itemPath' must not contain any empty segments"), segment = pathHelper.normalizeSeparators(itemPath[i]), i === 0 && pathHelper.hasRoot(segment) ? (segment = pathHelper.safeTrimTrailingSeparator(segment), assert_1.default(segment === pathHelper.dirname(segment), "Parameter 'itemPath' root segment contains information for multiple segments"), this.segments.push(segment)) : (assert_1.default(!segment.includes(path3.sep), "Parameter 'itemPath' contains unexpected path separators"), this.segments.push(segment));
        }
      }
    }
    toString() {
      let result = this.segments[0], skipSlash = result.endsWith(path3.sep) || IS_WINDOWS && /^[A-Z]:$/i.test(result);
      for (let i = 1; i < this.segments.length; i++)
        skipSlash ? skipSlash = !1 : result += path3.sep, result += this.segments[i];
      return result;
    }
  };
  __name(Path, "Path");
  exports2.Path = Path;
});

// ../node_modules/@actions/glob/lib/internal-pattern.js
var require_internal_pattern = __commonJS((exports2) => {
  "use strict";
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
    return result.default = mod, result;
  }, __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var os4 = __importStar(require("os")), path3 = __importStar(require("path")), pathHelper = __importStar(require_internal_path_helper()), assert_1 = __importDefault(require("assert")), minimatch_1 = require_minimatch(), internal_match_kind_1 = require_internal_match_kind(), internal_path_1 = require_internal_path(), IS_WINDOWS = process.platform === "win32", Pattern = class {
    constructor(patternOrNegate, segments, homedir) {
      this.negate = !1;
      let pattern;
      if (typeof patternOrNegate == "string")
        pattern = patternOrNegate.trim();
      else {
        segments = segments || [], assert_1.default(segments.length, "Parameter 'segments' must not empty");
        let root = Pattern.getLiteral(segments[0]);
        assert_1.default(root && pathHelper.hasAbsoluteRoot(root), "Parameter 'segments' first element must be a root path"), pattern = new internal_path_1.Path(segments).toString().trim(), patternOrNegate && (pattern = `!${pattern}`);
      }
      for (; pattern.startsWith("!"); )
        this.negate = !this.negate, pattern = pattern.substr(1).trim();
      pattern = Pattern.fixupPattern(pattern, homedir), this.segments = new internal_path_1.Path(pattern).segments, this.trailingSeparator = pathHelper.normalizeSeparators(pattern).endsWith(path3.sep), pattern = pathHelper.safeTrimTrailingSeparator(pattern);
      let foundGlob = !1, searchSegments = this.segments.map((x) => Pattern.getLiteral(x)).filter((x) => !foundGlob && !(foundGlob = x === ""));
      this.searchPath = new internal_path_1.Path(searchSegments).toString(), this.rootRegExp = new RegExp(Pattern.regExpEscape(searchSegments[0]), IS_WINDOWS ? "i" : "");
      let minimatchOptions = {
        dot: !0,
        nobrace: !0,
        nocase: IS_WINDOWS,
        nocomment: !0,
        noext: !0,
        nonegate: !0
      };
      pattern = IS_WINDOWS ? pattern.replace(/\\/g, "/") : pattern, this.minimatch = new minimatch_1.Minimatch(pattern, minimatchOptions);
    }
    match(itemPath) {
      return this.segments[this.segments.length - 1] === "**" ? (itemPath = pathHelper.normalizeSeparators(itemPath), itemPath.endsWith(path3.sep) || (itemPath = `${itemPath}${path3.sep}`)) : itemPath = pathHelper.safeTrimTrailingSeparator(itemPath), this.minimatch.match(itemPath) ? this.trailingSeparator ? internal_match_kind_1.MatchKind.Directory : internal_match_kind_1.MatchKind.All : internal_match_kind_1.MatchKind.None;
    }
    partialMatch(itemPath) {
      return itemPath = pathHelper.safeTrimTrailingSeparator(itemPath), pathHelper.dirname(itemPath) === itemPath ? this.rootRegExp.test(itemPath) : this.minimatch.matchOne(itemPath.split(IS_WINDOWS ? /\\+/ : /\/+/), this.minimatch.set[0], !0);
    }
    static globEscape(s) {
      return (IS_WINDOWS ? s : s.replace(/\\/g, "\\\\")).replace(/(\[)(?=[^/]+\])/g, "[[]").replace(/\?/g, "[?]").replace(/\*/g, "[*]");
    }
    static fixupPattern(pattern, homedir) {
      assert_1.default(pattern, "pattern cannot be empty");
      let literalSegments = new internal_path_1.Path(pattern).segments.map((x) => Pattern.getLiteral(x));
      if (assert_1.default(literalSegments.every((x, i) => (x !== "." || i === 0) && x !== ".."), `Invalid pattern '${pattern}'. Relative pathing '.' and '..' is not allowed.`), assert_1.default(!pathHelper.hasRoot(pattern) || literalSegments[0], `Invalid pattern '${pattern}'. Root segment must not contain globs.`), pattern = pathHelper.normalizeSeparators(pattern), pattern === "." || pattern.startsWith(`.${path3.sep}`))
        pattern = Pattern.globEscape(process.cwd()) + pattern.substr(1);
      else if (pattern === "~" || pattern.startsWith(`~${path3.sep}`))
        homedir = homedir || os4.homedir(), assert_1.default(homedir, "Unable to determine HOME directory"), assert_1.default(pathHelper.hasAbsoluteRoot(homedir), `Expected HOME directory to be a rooted path. Actual '${homedir}'`), pattern = Pattern.globEscape(homedir) + pattern.substr(1);
      else if (IS_WINDOWS && (pattern.match(/^[A-Z]:$/i) || pattern.match(/^[A-Z]:[^\\]/i))) {
        let root = pathHelper.ensureAbsoluteRoot("C:\\dummy-root", pattern.substr(0, 2));
        pattern.length > 2 && !root.endsWith("\\") && (root += "\\"), pattern = Pattern.globEscape(root) + pattern.substr(2);
      } else if (IS_WINDOWS && (pattern === "\\" || pattern.match(/^\\[^\\]/))) {
        let root = pathHelper.ensureAbsoluteRoot("C:\\dummy-root", "\\");
        root.endsWith("\\") || (root += "\\"), pattern = Pattern.globEscape(root) + pattern.substr(1);
      } else
        pattern = pathHelper.ensureAbsoluteRoot(Pattern.globEscape(process.cwd()), pattern);
      return pathHelper.normalizeSeparators(pattern);
    }
    static getLiteral(segment) {
      let literal = "";
      for (let i = 0; i < segment.length; i++) {
        let c = segment[i];
        if (c === "\\" && !IS_WINDOWS && i + 1 < segment.length) {
          literal += segment[++i];
          continue;
        } else {
          if (c === "*" || c === "?")
            return "";
          if (c === "[" && i + 1 < segment.length) {
            let set = "", closed = -1;
            for (let i2 = i + 1; i2 < segment.length; i2++) {
              let c2 = segment[i2];
              if (c2 === "\\" && !IS_WINDOWS && i2 + 1 < segment.length) {
                set += segment[++i2];
                continue;
              } else if (c2 === "]") {
                closed = i2;
                break;
              } else
                set += c2;
            }
            if (closed >= 0) {
              if (set.length > 1)
                return "";
              if (set) {
                literal += set, i = closed;
                continue;
              }
            }
          }
        }
        literal += c;
      }
      return literal;
    }
    static regExpEscape(s) {
      return s.replace(/[[\\^$.|?*+()]/g, "\\$&");
    }
  };
  __name(Pattern, "Pattern");
  exports2.Pattern = Pattern;
});

// ../node_modules/@actions/glob/lib/internal-search-state.js
var require_internal_search_state = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var SearchState = class {
    constructor(path3, level) {
      this.path = path3, this.level = level;
    }
  };
  __name(SearchState, "SearchState");
  exports2.SearchState = SearchState;
});

// ../node_modules/@actions/glob/lib/internal-globber.js
var require_internal_globber = __commonJS((exports2) => {
  "use strict";
  var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return __name(adopt, "adopt"), new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(fulfilled, "fulfilled");
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(rejected, "rejected");
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      __name(step, "step"), step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }, __asyncValues2 = exports2 && exports2.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values == "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({value: v2, done: d});
      }, reject);
    }
  }, __await2 = exports2 && exports2.__await || function(v) {
    return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
  }, __asyncGenerator2 = exports2 && exports2.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      g[n] && (i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      });
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      f(v), q.shift(), q.length && resume(q[0][0], q[0][1]);
    }
  }, __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
    return result.default = mod, result;
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var core = __importStar(require_core()), fs4 = __importStar(require("fs")), globOptionsHelper = __importStar(require_internal_glob_options_helper()), path3 = __importStar(require("path")), patternHelper = __importStar(require_internal_pattern_helper()), internal_match_kind_1 = require_internal_match_kind(), internal_pattern_1 = require_internal_pattern(), internal_search_state_1 = require_internal_search_state(), IS_WINDOWS = process.platform === "win32", DefaultGlobber = class {
    constructor(options) {
      this.patterns = [], this.searchPaths = [], this.options = globOptionsHelper.getOptions(options);
    }
    getSearchPaths() {
      return this.searchPaths.slice();
    }
    glob() {
      var e_1, _a;
      return __awaiter2(this, void 0, void 0, function* () {
        let result = [];
        try {
          for (var _b = __asyncValues2(this.globGenerator()), _c; _c = yield _b.next(), !_c.done; ) {
            let itemPath = _c.value;
            result.push(itemPath);
          }
        } catch (e_1_1) {
          e_1 = {error: e_1_1};
        } finally {
          try {
            _c && !_c.done && (_a = _b.return) && (yield _a.call(_b));
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return result;
      });
    }
    globGenerator() {
      return __asyncGenerator2(this, arguments, /* @__PURE__ */ __name(function* () {
        let options = globOptionsHelper.getOptions(this.options), patterns = [];
        for (let pattern of this.patterns)
          patterns.push(pattern), options.implicitDescendants && (pattern.trailingSeparator || pattern.segments[pattern.segments.length - 1] !== "**") && patterns.push(new internal_pattern_1.Pattern(pattern.negate, pattern.segments.concat("**")));
        let stack = [];
        for (let searchPath of patternHelper.getSearchPaths(patterns)) {
          core.debug(`Search path '${searchPath}'`);
          try {
            yield __await2(fs4.promises.lstat(searchPath));
          } catch (err) {
            if (err.code === "ENOENT")
              continue;
            throw err;
          }
          stack.unshift(new internal_search_state_1.SearchState(searchPath, 1));
        }
        let traversalChain = [];
        for (; stack.length; ) {
          let item = stack.pop(), match = patternHelper.match(patterns, item.path), partialMatch = !!match || patternHelper.partialMatch(patterns, item.path);
          if (!match && !partialMatch)
            continue;
          let stats = yield __await2(DefaultGlobber.stat(item, options, traversalChain));
          if (!!stats)
            if (stats.isDirectory()) {
              if (match & internal_match_kind_1.MatchKind.Directory)
                yield yield __await2(item.path);
              else if (!partialMatch)
                continue;
              let childLevel = item.level + 1, childItems = (yield __await2(fs4.promises.readdir(item.path))).map((x) => new internal_search_state_1.SearchState(path3.join(item.path, x), childLevel));
              stack.push(...childItems.reverse());
            } else
              match & internal_match_kind_1.MatchKind.File && (yield yield __await2(item.path));
        }
      }, "globGenerator_1"));
    }
    static create(patterns, options) {
      return __awaiter2(this, void 0, void 0, function* () {
        let result = new DefaultGlobber(options);
        IS_WINDOWS && (patterns = patterns.replace(/\r\n/g, `
`), patterns = patterns.replace(/\r/g, `
`));
        let lines = patterns.split(`
`).map((x) => x.trim());
        for (let line of lines)
          !line || line.startsWith("#") || result.patterns.push(new internal_pattern_1.Pattern(line));
        return result.searchPaths.push(...patternHelper.getSearchPaths(result.patterns)), result;
      });
    }
    static stat(item, options, traversalChain) {
      return __awaiter2(this, void 0, void 0, function* () {
        let stats;
        if (options.followSymbolicLinks)
          try {
            stats = yield fs4.promises.stat(item.path);
          } catch (err) {
            if (err.code === "ENOENT") {
              if (options.omitBrokenSymbolicLinks) {
                core.debug(`Broken symlink '${item.path}'`);
                return;
              }
              throw new Error(`No information found for the path '${item.path}'. This may indicate a broken symbolic link.`);
            }
            throw err;
          }
        else
          stats = yield fs4.promises.lstat(item.path);
        if (stats.isDirectory() && options.followSymbolicLinks) {
          let realPath = yield fs4.promises.realpath(item.path);
          for (; traversalChain.length >= item.level; )
            traversalChain.pop();
          if (traversalChain.some((x) => x === realPath)) {
            core.debug(`Symlink cycle detected for path '${item.path}' and realpath '${realPath}'`);
            return;
          }
          traversalChain.push(realPath);
        }
        return stats;
      });
    }
  };
  __name(DefaultGlobber, "DefaultGlobber");
  exports2.DefaultGlobber = DefaultGlobber;
});

// ../node_modules/@actions/glob/lib/glob.js
var require_glob = __commonJS((exports2) => {
  "use strict";
  var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return __name(adopt, "adopt"), new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(fulfilled, "fulfilled");
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(rejected, "rejected");
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      __name(step, "step"), step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var internal_globber_1 = require_internal_globber();
  function create(patterns, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield internal_globber_1.DefaultGlobber.create(patterns, options);
    });
  }
  __name(create, "create");
  exports2.create = create;
});

// ../node_modules/semver/semver.js
var require_semver = __commonJS((exports2, module2) => {
  exports2 = module2.exports = SemVer;
  var debug;
  typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? debug = /* @__PURE__ */ __name(function() {
    var args = Array.prototype.slice.call(arguments, 0);
    args.unshift("SEMVER"), console.log.apply(console, args);
  }, "debug") : debug = /* @__PURE__ */ __name(function() {
  }, "debug");
  exports2.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256, MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH = 16, re = exports2.re = [], src = exports2.src = [], t = exports2.tokens = {}, R = 0;
  function tok(n) {
    t[n] = R++;
  }
  __name(tok, "tok");
  tok("NUMERICIDENTIFIER");
  src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  tok("NUMERICIDENTIFIERLOOSE");
  src[t.NUMERICIDENTIFIERLOOSE] = "[0-9]+";
  tok("NONNUMERICIDENTIFIER");
  src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  tok("MAINVERSION");
  src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
  tok("MAINVERSIONLOOSE");
  src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
  tok("PRERELEASEIDENTIFIER");
  src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASEIDENTIFIERLOOSE");
  src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASE");
  src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
  tok("PRERELEASELOOSE");
  src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
  tok("BUILDIDENTIFIER");
  src[t.BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
  tok("BUILD");
  src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
  tok("FULL");
  tok("FULLPLAIN");
  src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
  src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
  tok("LOOSEPLAIN");
  src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
  tok("LOOSE");
  src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
  tok("GTLT");
  src[t.GTLT] = "((?:<|>)?=?)";
  tok("XRANGEIDENTIFIERLOOSE");
  src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  tok("XRANGEIDENTIFIER");
  src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
  tok("XRANGEPLAIN");
  src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGEPLAINLOOSE");
  src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGE");
  src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
  tok("XRANGELOOSE");
  src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COERCE");
  src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  tok("COERCERTL");
  re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
  tok("LONETILDE");
  src[t.LONETILDE] = "(?:~>?)";
  tok("TILDETRIM");
  src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
  re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
  var tildeTrimReplace = "$1~";
  tok("TILDE");
  src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
  tok("TILDELOOSE");
  src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("LONECARET");
  src[t.LONECARET] = "(?:\\^)";
  tok("CARETTRIM");
  src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
  re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
  var caretTrimReplace = "$1^";
  tok("CARET");
  src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
  tok("CARETLOOSE");
  src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COMPARATORLOOSE");
  src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
  tok("COMPARATOR");
  src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
  tok("COMPARATORTRIM");
  src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
  re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
  var comparatorTrimReplace = "$1$2$3";
  tok("HYPHENRANGE");
  src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
  tok("HYPHENRANGELOOSE");
  src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
  tok("STAR");
  src[t.STAR] = "(<|>)?=?\\s*\\*";
  for (var i = 0; i < R; i++)
    debug(i, src[i]), re[i] || (re[i] = new RegExp(src[i]));
  exports2.parse = parse2;
  function parse2(version2, options) {
    if ((!options || typeof options != "object") && (options = {
      loose: !!options,
      includePrerelease: !1
    }), version2 instanceof SemVer)
      return version2;
    if (typeof version2 != "string" || version2.length > MAX_LENGTH)
      return null;
    var r = options.loose ? re[t.LOOSE] : re[t.FULL];
    if (!r.test(version2))
      return null;
    try {
      return new SemVer(version2, options);
    } catch (er) {
      return null;
    }
  }
  __name(parse2, "parse");
  exports2.valid = valid;
  function valid(version2, options) {
    var v = parse2(version2, options);
    return v ? v.version : null;
  }
  __name(valid, "valid");
  exports2.clean = clean;
  function clean(version2, options) {
    var s = parse2(version2.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  }
  __name(clean, "clean");
  exports2.SemVer = SemVer;
  function SemVer(version2, options) {
    if ((!options || typeof options != "object") && (options = {
      loose: !!options,
      includePrerelease: !1
    }), version2 instanceof SemVer) {
      if (version2.loose === options.loose)
        return version2;
      version2 = version2.version;
    } else if (typeof version2 != "string")
      throw new TypeError("Invalid Version: " + version2);
    if (version2.length > MAX_LENGTH)
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    if (!(this instanceof SemVer))
      return new SemVer(version2, options);
    debug("SemVer", version2, options), this.options = options, this.loose = !!options.loose;
    var m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
    if (!m)
      throw new TypeError("Invalid Version: " + version2);
    if (this.raw = version2, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], this.major > MAX_SAFE_INTEGER || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
      throw new TypeError("Invalid patch version");
    m[4] ? this.prerelease = m[4].split(".").map(function(id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id;
        if (num >= 0 && num < MAX_SAFE_INTEGER)
          return num;
      }
      return id;
    }) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
  }
  __name(SemVer, "SemVer");
  SemVer.prototype.format = function() {
    return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    return debug("SemVer.compare", this.version, this.options, other), other instanceof SemVer || (other = new SemVer(other, this.options)), this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    return other instanceof SemVer || (other = new SemVer(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (other instanceof SemVer || (other = new SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length)
      return -1;
    if (!this.prerelease.length && other.prerelease.length)
      return 1;
    if (!this.prerelease.length && !other.prerelease.length)
      return 0;
    var i2 = 0;
    do {
      var a = this.prerelease[i2], b = other.prerelease[i2];
      if (debug("prerelease compare", i2, a, b), a === void 0 && b === void 0)
        return 0;
      if (b === void 0)
        return 1;
      if (a === void 0)
        return -1;
      if (a === b)
        continue;
      return compareIdentifiers(a, b);
    } while (++i2);
  };
  SemVer.prototype.compareBuild = function(other) {
    other instanceof SemVer || (other = new SemVer(other, this.options));
    var i2 = 0;
    do {
      var a = this.build[i2], b = other.build[i2];
      if (debug("prerelease compare", i2, a, b), a === void 0 && b === void 0)
        return 0;
      if (b === void 0)
        return 1;
      if (a === void 0)
        return -1;
      if (a === b)
        continue;
      return compareIdentifiers(a, b);
    } while (++i2);
  };
  SemVer.prototype.inc = function(release3, identifier) {
    switch (release3) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", identifier), this.inc("pre", identifier);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", identifier), this.inc("pre", identifier);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0)
          this.prerelease = [0];
        else {
          for (var i2 = this.prerelease.length; --i2 >= 0; )
            typeof this.prerelease[i2] == "number" && (this.prerelease[i2]++, i2 = -2);
          i2 === -1 && this.prerelease.push(0);
        }
        identifier && (this.prerelease[0] === identifier ? isNaN(this.prerelease[1]) && (this.prerelease = [identifier, 0]) : this.prerelease = [identifier, 0]);
        break;
      default:
        throw new Error("invalid increment argument: " + release3);
    }
    return this.format(), this.raw = this.version, this;
  };
  exports2.inc = inc;
  function inc(version2, release3, loose, identifier) {
    typeof loose == "string" && (identifier = loose, loose = void 0);
    try {
      return new SemVer(version2, loose).inc(release3, identifier).version;
    } catch (er) {
      return null;
    }
  }
  __name(inc, "inc");
  exports2.diff = diff;
  function diff(version1, version2) {
    if (eq(version1, version2))
      return null;
    var v1 = parse2(version1), v2 = parse2(version2), prefix2 = "";
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix2 = "pre";
      var defaultResult = "prerelease";
    }
    for (var key in v1)
      if ((key === "major" || key === "minor" || key === "patch") && v1[key] !== v2[key])
        return prefix2 + key;
    return defaultResult;
  }
  __name(diff, "diff");
  exports2.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a, b) {
    var anum = numeric.test(a), bnum = numeric.test(b);
    return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }
  __name(compareIdentifiers, "compareIdentifiers");
  exports2.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }
  __name(rcompareIdentifiers, "rcompareIdentifiers");
  exports2.major = major;
  function major(a, loose) {
    return new SemVer(a, loose).major;
  }
  __name(major, "major");
  exports2.minor = minor;
  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }
  __name(minor, "minor");
  exports2.patch = patch;
  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }
  __name(patch, "patch");
  exports2.compare = compare;
  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }
  __name(compare, "compare");
  exports2.compareLoose = compareLoose;
  function compareLoose(a, b) {
    return compare(a, b, !0);
  }
  __name(compareLoose, "compareLoose");
  exports2.compareBuild = compareBuild;
  function compareBuild(a, b, loose) {
    var versionA = new SemVer(a, loose), versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  }
  __name(compareBuild, "compareBuild");
  exports2.rcompare = rcompare;
  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }
  __name(rcompare, "rcompare");
  exports2.sort = sort;
  function sort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.compareBuild(a, b, loose);
    });
  }
  __name(sort, "sort");
  exports2.rsort = rsort;
  function rsort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.compareBuild(b, a, loose);
    });
  }
  __name(rsort, "rsort");
  exports2.gt = gt;
  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }
  __name(gt, "gt");
  exports2.lt = lt;
  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }
  __name(lt, "lt");
  exports2.eq = eq;
  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }
  __name(eq, "eq");
  exports2.neq = neq;
  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }
  __name(neq, "neq");
  exports2.gte = gte;
  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }
  __name(gte, "gte");
  exports2.lte = lte;
  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }
  __name(lte, "lte");
  exports2.cmp = cmp;
  function cmp(a, op, b, loose) {
    switch (op) {
      case "===":
        return typeof a == "object" && (a = a.version), typeof b == "object" && (b = b.version), a === b;
      case "!==":
        return typeof a == "object" && (a = a.version), typeof b == "object" && (b = b.version), a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  __name(cmp, "cmp");
  exports2.Comparator = Comparator;
  function Comparator(comp, options) {
    if ((!options || typeof options != "object") && (options = {
      loose: !!options,
      includePrerelease: !1
    }), comp instanceof Comparator) {
      if (comp.loose === !!options.loose)
        return comp;
      comp = comp.value;
    }
    if (!(this instanceof Comparator))
      return new Comparator(comp, options);
    debug("comparator", comp, options), this.options = options, this.loose = !!options.loose, this.parse(comp), this.semver === ANY ? this.value = "" : this.value = this.operator + this.semver.version, debug("comp", this);
  }
  __name(Comparator, "Comparator");
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR], m = comp.match(r);
    if (!m)
      throw new TypeError("Invalid comparator: " + comp);
    this.operator = m[1] !== void 0 ? m[1] : "", this.operator === "=" && (this.operator = ""), m[2] ? this.semver = new SemVer(m[2], this.options.loose) : this.semver = ANY;
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version2) {
    if (debug("Comparator.test", version2, this.options.loose), this.semver === ANY || version2 === ANY)
      return !0;
    if (typeof version2 == "string")
      try {
        version2 = new SemVer(version2, this.options);
      } catch (er) {
        return !1;
      }
    return cmp(version2, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator))
      throw new TypeError("a Comparator is required");
    (!options || typeof options != "object") && (options = {
      loose: !!options,
      includePrerelease: !1
    });
    var rangeTmp;
    if (this.operator === "")
      return this.value === "" ? !0 : (rangeTmp = new Range(comp.value, options), satisfies(this.value, rangeTmp, options));
    if (comp.operator === "")
      return comp.value === "" ? !0 : (rangeTmp = new Range(this.value, options), satisfies(comp.semver, rangeTmp, options));
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">"), sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<"), sameSemVer = this.semver.version === comp.semver.version, differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<="), oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"), oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports2.Range = Range;
  function Range(range, options) {
    if ((!options || typeof options != "object") && (options = {
      loose: !!options,
      includePrerelease: !1
    }), range instanceof Range)
      return range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease ? range : new Range(range.raw, options);
    if (range instanceof Comparator)
      return new Range(range.value, options);
    if (!(this instanceof Range))
      return new Range(range, options);
    if (this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease, this.raw = range, this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c) {
      return c.length;
    }), !this.set.length)
      throw new TypeError("Invalid SemVer Range: " + range);
    this.format();
  }
  __name(Range, "Range");
  Range.prototype.format = function() {
    return this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim(), this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    range = range.trim();
    var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
    range = range.replace(hr, hyphenReplace), debug("hyphen replace", range), range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace), debug("comparator trim", range, re[t.COMPARATORTRIM]), range = range.replace(re[t.TILDETRIM], tildeTrimReplace), range = range.replace(re[t.CARETTRIM], caretTrimReplace), range = range.split(/\s+/).join(" ");
    var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR], set = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    return this.options.loose && (set = set.filter(function(comp) {
      return !!comp.match(compRe);
    })), set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this), set;
  };
  Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range))
      throw new TypeError("a Range is required");
    return this.set.some(function(thisComparators) {
      return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
        return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  function isSatisfiable(comparators, options) {
    for (var result = !0, remainingComparators = comparators.slice(), testComparator = remainingComparators.pop(); result && remainingComparators.length; )
      result = remainingComparators.every(function(otherComparator) {
        return testComparator.intersects(otherComparator, options);
      }), testComparator = remainingComparators.pop();
    return result;
  }
  __name(isSatisfiable, "isSatisfiable");
  exports2.toComparators = toComparators;
  function toComparators(range, options) {
    return new Range(range, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  }
  __name(toComparators, "toComparators");
  function parseComparator(comp, options) {
    return debug("comp", comp, options), comp = replaceCarets(comp, options), debug("caret", comp), comp = replaceTildes(comp, options), debug("tildes", comp), comp = replaceXRanges(comp, options), debug("xrange", comp), comp = replaceStars(comp, options), debug("stars", comp), comp;
  }
  __name(parseComparator, "parseComparator");
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  __name(isX, "isX");
  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp23) {
      return replaceTilde(comp23, options);
    }).join(" ");
  }
  __name(replaceTildes, "replaceTildes");
  function replaceTilde(comp, options) {
    var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("tilde", comp, _, M, m, p, pr);
      var ret;
      return isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : pr ? (debug("replaceTilde pr", pr), ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0") : ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0", debug("tilde return", ret), ret;
    });
  }
  __name(replaceTilde, "replaceTilde");
  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp23) {
      return replaceCaret(comp23, options);
    }).join(" ");
  }
  __name(replaceCarets, "replaceCarets");
  function replaceCaret(comp, options) {
    debug("caret", comp, options);
    var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("caret", comp, _, M, m, p, pr);
      var ret;
      return isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? M === "0" ? ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0" : pr ? (debug("replaceCaret pr", pr), M === "0" ? m === "0" ? ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1) : ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0" : ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0") : (debug("no pr"), M === "0" ? m === "0" ? ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1) : ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0" : ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0"), debug("caret return", ret), ret;
    });
  }
  __name(replaceCaret, "replaceCaret");
  function replaceXRanges(comp, options) {
    return debug("replaceXRanges", comp, options), comp.split(/\s+/).map(function(comp23) {
      return replaceXRange(comp23, options);
    }).join(" ");
  }
  __name(replaceXRanges, "replaceXRanges");
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M), xm = xM || isX(m), xp = xm || isX(p), anyX = xp;
      return gtlt === "=" && anyX && (gtlt = ""), pr = options.includePrerelease ? "-0" : "", xM ? gtlt === ">" || gtlt === "<" ? ret = "<0.0.0-0" : ret = "*" : gtlt && anyX ? (xm && (m = 0), p = 0, gtlt === ">" ? (gtlt = ">=", xm ? (M = +M + 1, m = 0, p = 0) : (m = +m + 1, p = 0)) : gtlt === "<=" && (gtlt = "<", xm ? M = +M + 1 : m = +m + 1), ret = gtlt + M + "." + m + "." + p + pr) : xm ? ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr : xp && (ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr), debug("xRange return", ret), ret;
    });
  }
  __name(replaceXRange, "replaceXRange");
  function replaceStars(comp, options) {
    return debug("replaceStars", comp, options), comp.trim().replace(re[t.STAR], "");
  }
  __name(replaceStars, "replaceStars");
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    return isX(fM) ? from = "" : isX(fm) ? from = ">=" + fM + ".0.0" : isX(fp) ? from = ">=" + fM + "." + fm + ".0" : from = ">=" + from, isX(tM) ? to = "" : isX(tm) ? to = "<" + (+tM + 1) + ".0.0" : isX(tp) ? to = "<" + tM + "." + (+tm + 1) + ".0" : tpr ? to = "<=" + tM + "." + tm + "." + tp + "-" + tpr : to = "<=" + to, (from + " " + to).trim();
  }
  __name(hyphenReplace, "hyphenReplace");
  Range.prototype.test = function(version2) {
    if (!version2)
      return !1;
    if (typeof version2 == "string")
      try {
        version2 = new SemVer(version2, this.options);
      } catch (er) {
        return !1;
      }
    for (var i2 = 0; i2 < this.set.length; i2++)
      if (testSet(this.set[i2], version2, this.options))
        return !0;
    return !1;
  };
  function testSet(set, version2, options) {
    for (var i2 = 0; i2 < set.length; i2++)
      if (!set[i2].test(version2))
        return !1;
    if (version2.prerelease.length && !options.includePrerelease) {
      for (i2 = 0; i2 < set.length; i2++)
        if (debug(set[i2].semver), set[i2].semver !== ANY && set[i2].semver.prerelease.length > 0) {
          var allowed = set[i2].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  }
  __name(testSet, "testSet");
  exports2.satisfies = satisfies;
  function satisfies(version2, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return !1;
    }
    return range.test(version2);
  }
  __name(satisfies, "satisfies");
  exports2.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions, range, options) {
    var max = null, maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    return versions.forEach(function(v) {
      rangeObj.test(v) && (!max || maxSV.compare(v) === -1) && (max = v, maxSV = new SemVer(max, options));
    }), max;
  }
  __name(maxSatisfying, "maxSatisfying");
  exports2.minSatisfying = minSatisfying;
  function minSatisfying(versions, range, options) {
    var min = null, minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    return versions.forEach(function(v) {
      rangeObj.test(v) && (!min || minSV.compare(v) === 1) && (min = v, minSV = new SemVer(min, options));
    }), min;
  }
  __name(minSatisfying, "minSatisfying");
  exports2.minVersion = minVersion;
  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver) || (minver = new SemVer("0.0.0-0"), range.test(minver)))
      return minver;
    minver = null;
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            compver.prerelease.length === 0 ? compver.patch++ : compver.prerelease.push(0), compver.raw = compver.format();
          case "":
          case ">=":
            (!minver || gt(minver, compver)) && (minver = compver);
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    return minver && range.test(minver) ? minver : null;
  }
  __name(minVersion, "minVersion");
  exports2.validRange = validRange;
  function validRange(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  }
  __name(validRange, "validRange");
  exports2.ltr = ltr;
  function ltr(version2, range, options) {
    return outside(version2, range, "<", options);
  }
  __name(ltr, "ltr");
  exports2.gtr = gtr;
  function gtr(version2, range, options) {
    return outside(version2, range, ">", options);
  }
  __name(gtr, "gtr");
  exports2.outside = outside;
  function outside(version2, range, hilo, options) {
    version2 = new SemVer(version2, options), range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt, ltefn = lte, ltfn = lt, comp = ">", ecomp = ">=";
        break;
      case "<":
        gtfn = lt, ltefn = gte, ltfn = gt, comp = "<", ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version2, range, options))
      return !1;
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2], high = null, low = null;
      if (comparators.forEach(function(comparator) {
        comparator.semver === ANY && (comparator = new Comparator(">=0.0.0")), high = high || comparator, low = low || comparator, gtfn(comparator.semver, high.semver, options) ? high = comparator : ltfn(comparator.semver, low.semver, options) && (low = comparator);
      }), high.operator === comp || high.operator === ecomp || (!low.operator || low.operator === comp) && ltefn(version2, low.semver))
        return !1;
      if (low.operator === ecomp && ltfn(version2, low.semver))
        return !1;
    }
    return !0;
  }
  __name(outside, "outside");
  exports2.prerelease = prerelease;
  function prerelease(version2, options) {
    var parsed = parse2(version2, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  __name(prerelease, "prerelease");
  exports2.intersects = intersects;
  function intersects(r1, r2, options) {
    return r1 = new Range(r1, options), r2 = new Range(r2, options), r1.intersects(r2);
  }
  __name(intersects, "intersects");
  exports2.coerce = coerce;
  function coerce(version2, options) {
    if (version2 instanceof SemVer)
      return version2;
    if (typeof version2 == "number" && (version2 = String(version2)), typeof version2 != "string")
      return null;
    options = options || {};
    var match = null;
    if (!options.rtl)
      match = version2.match(re[t.COERCE]);
    else {
      for (var next; (next = re[t.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length); )
        (!match || next.index + next[0].length !== match.index + match[0].length) && (match = next), re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      re[t.COERCERTL].lastIndex = -1;
    }
    return match === null ? null : parse2(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
  }
  __name(coerce, "coerce");
});

// ../node_modules/uuid/lib/rng.js
var require_rng = __commonJS((exports2, module2) => {
  var crypto2 = require("crypto");
  module2.exports = /* @__PURE__ */ __name(function() {
    return crypto2.randomBytes(16);
  }, "nodeRNG");
});

// ../node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS((exports2, module2) => {
  var byteToHex2 = [];
  for (var i = 0; i < 256; ++i)
    byteToHex2[i] = (i + 256).toString(16).substr(1);
  function bytesToUuid(buf, offset) {
    var i2 = offset || 0, bth = byteToHex2;
    return [
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]]
    ].join("");
  }
  __name(bytesToUuid, "bytesToUuid");
  module2.exports = bytesToUuid;
});

// ../node_modules/uuid/v1.js
var require_v1 = __commonJS((exports2, module2) => {
  var rng2 = require_rng(), bytesToUuid = require_bytesToUuid(), _nodeId, _clockseq, _lastMSecs = 0, _lastNSecs = 0;
  function v1(options, buf, offset) {
    var i = buf && offset || 0, b = buf || [];
    options = options || {};
    var node = options.node || _nodeId, clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      var seedBytes = rng2();
      node == null && (node = _nodeId = [
        seedBytes[0] | 1,
        seedBytes[1],
        seedBytes[2],
        seedBytes[3],
        seedBytes[4],
        seedBytes[5]
      ]), clockseq == null && (clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383);
    }
    var msecs = options.msecs !== void 0 ? options.msecs : new Date().getTime(), nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1, dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === void 0 && (clockseq = clockseq + 1 & 16383), (dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0 && (nsecs = 0), nsecs >= 1e4)
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    _lastMSecs = msecs, _lastNSecs = nsecs, _clockseq = clockseq, msecs += 122192928e5;
    var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255, b[i++] = tl >>> 16 & 255, b[i++] = tl >>> 8 & 255, b[i++] = tl & 255;
    var tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255, b[i++] = tmh & 255, b[i++] = tmh >>> 24 & 15 | 16, b[i++] = tmh >>> 16 & 255, b[i++] = clockseq >>> 8 | 128, b[i++] = clockseq & 255;
    for (var n = 0; n < 6; ++n)
      b[i + n] = node[n];
    return buf || bytesToUuid(b);
  }
  __name(v1, "v1");
  module2.exports = v1;
});

// ../node_modules/uuid/v4.js
var require_v4 = __commonJS((exports2, module2) => {
  var rng2 = require_rng(), bytesToUuid = require_bytesToUuid();
  function v42(options, buf, offset) {
    var i = buf && offset || 0;
    typeof options == "string" && (buf = options === "binary" ? new Array(16) : null, options = null), options = options || {};
    var rnds = options.random || (options.rng || rng2)();
    if (rnds[6] = rnds[6] & 15 | 64, rnds[8] = rnds[8] & 63 | 128, buf)
      for (var ii = 0; ii < 16; ++ii)
        buf[i + ii] = rnds[ii];
    return buf || bytesToUuid(rnds);
  }
  __name(v42, "v4");
  module2.exports = v42;
});

// ../node_modules/uuid/index.js
var require_uuid = __commonJS((exports2, module2) => {
  var v1 = require_v1(), v42 = require_v4(), uuid = v42;
  uuid.v1 = v1;
  uuid.v4 = v42;
  module2.exports = uuid;
});

// ../node_modules/@actions/cache/lib/internal/constants.js
var require_constants = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var CacheFilename;
  (function(CacheFilename2) {
    CacheFilename2.Gzip = "cache.tgz", CacheFilename2.Zstd = "cache.tzst";
  })(CacheFilename = exports2.CacheFilename || (exports2.CacheFilename = {}));
  var CompressionMethod;
  (function(CompressionMethod2) {
    CompressionMethod2.Gzip = "gzip", CompressionMethod2.ZstdWithoutLong = "zstd-without-long", CompressionMethod2.Zstd = "zstd";
  })(CompressionMethod = exports2.CompressionMethod || (exports2.CompressionMethod = {}));
  exports2.DefaultRetryAttempts = 2;
  exports2.DefaultRetryDelay = 5e3;
  exports2.SocketTimeout = 5e3;
});

// ../node_modules/@actions/cache/lib/internal/cacheUtils.js
var require_cacheUtils = __commonJS((exports2) => {
  "use strict";
  var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return __name(adopt, "adopt"), new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(fulfilled, "fulfilled");
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(rejected, "rejected");
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      __name(step, "step"), step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }, __asyncValues2 = exports2 && exports2.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values == "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({value: v2, done: d});
      }, reject);
    }
  }, __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
    return result.default = mod, result;
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var core = __importStar(require_core()), exec = __importStar(require_exec()), glob = __importStar(require_glob()), io = __importStar(require_io()), fs4 = __importStar(require("fs")), path3 = __importStar(require("path")), semver = __importStar(require_semver()), util3 = __importStar(require("util")), uuid_1 = require_uuid(), constants_1 = require_constants();
  function createTempDirectory() {
    return __awaiter2(this, void 0, void 0, function* () {
      let IS_WINDOWS = process.platform === "win32", tempDirectory = process.env.RUNNER_TEMP || "";
      if (!tempDirectory) {
        let baseLocation;
        IS_WINDOWS ? baseLocation = process.env.USERPROFILE || "C:\\" : process.platform === "darwin" ? baseLocation = "/Users" : baseLocation = "/home", tempDirectory = path3.join(baseLocation, "actions", "temp");
      }
      let dest = path3.join(tempDirectory, uuid_1.v4());
      return yield io.mkdirP(dest), dest;
    });
  }
  __name(createTempDirectory, "createTempDirectory");
  exports2.createTempDirectory = createTempDirectory;
  function getArchiveFileSizeIsBytes(filePath) {
    return fs4.statSync(filePath).size;
  }
  __name(getArchiveFileSizeIsBytes, "getArchiveFileSizeIsBytes");
  exports2.getArchiveFileSizeIsBytes = getArchiveFileSizeIsBytes;
  function resolvePaths(patterns) {
    var e_1, _a, _b;
    return __awaiter2(this, void 0, void 0, function* () {
      let paths = [], workspace = (_b = process.env.GITHUB_WORKSPACE) !== null && _b !== void 0 ? _b : process.cwd(), globber = yield glob.create(patterns.join(`
`), {
        implicitDescendants: !1
      });
      try {
        for (var _c = __asyncValues2(globber.globGenerator()), _d; _d = yield _c.next(), !_d.done; ) {
          let file = _d.value, relativeFile = path3.relative(workspace, file).replace(new RegExp(`\\${path3.sep}`, "g"), "/");
          core.debug(`Matched: ${relativeFile}`), paths.push(`${relativeFile}`);
        }
      } catch (e_1_1) {
        e_1 = {error: e_1_1};
      } finally {
        try {
          _d && !_d.done && (_a = _c.return) && (yield _a.call(_c));
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return paths;
    });
  }
  __name(resolvePaths, "resolvePaths");
  exports2.resolvePaths = resolvePaths;
  function unlinkFile(filePath) {
    return __awaiter2(this, void 0, void 0, function* () {
      return util3.promisify(fs4.unlink)(filePath);
    });
  }
  __name(unlinkFile, "unlinkFile");
  exports2.unlinkFile = unlinkFile;
  function getVersion(app) {
    return __awaiter2(this, void 0, void 0, function* () {
      core.debug(`Checking ${app} --version`);
      let versionOutput = "";
      try {
        yield exec.exec(`${app} --version`, [], {
          ignoreReturnCode: !0,
          silent: !0,
          listeners: {
            stdout: (data) => versionOutput += data.toString(),
            stderr: (data) => versionOutput += data.toString()
          }
        });
      } catch (err) {
        core.debug(err.message);
      }
      return versionOutput = versionOutput.trim(), core.debug(versionOutput), versionOutput;
    });
  }
  __name(getVersion, "getVersion");
  function getCompressionMethod() {
    return __awaiter2(this, void 0, void 0, function* () {
      if (process.platform === "win32" && !(yield isGnuTarInstalled()))
        return constants_1.CompressionMethod.Gzip;
      let versionOutput = yield getVersion("zstd"), version2 = semver.clean(versionOutput);
      return versionOutput.toLowerCase().includes("zstd command line interface") ? !version2 || semver.lt(version2, "v1.3.2") ? constants_1.CompressionMethod.ZstdWithoutLong : constants_1.CompressionMethod.Zstd : constants_1.CompressionMethod.Gzip;
    });
  }
  __name(getCompressionMethod, "getCompressionMethod");
  exports2.getCompressionMethod = getCompressionMethod;
  function getCacheFileName(compressionMethod) {
    return compressionMethod === constants_1.CompressionMethod.Gzip ? constants_1.CacheFilename.Gzip : constants_1.CacheFilename.Zstd;
  }
  __name(getCacheFileName, "getCacheFileName");
  exports2.getCacheFileName = getCacheFileName;
  function isGnuTarInstalled() {
    return __awaiter2(this, void 0, void 0, function* () {
      return (yield getVersion("tar")).toLowerCase().includes("gnu tar");
    });
  }
  __name(isGnuTarInstalled, "isGnuTarInstalled");
  exports2.isGnuTarInstalled = isGnuTarInstalled;
  function assertDefined(name, value) {
    if (value === void 0)
      throw Error(`Expected ${name} but value was undefiend`);
    return value;
  }
  __name(assertDefined, "assertDefined");
  exports2.assertDefined = assertDefined;
});

// ../node_modules/@actions/http-client/proxy.js
var require_proxy = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  function getProxyUrl(reqUrl) {
    let usingSsl = reqUrl.protocol === "https:", proxyUrl;
    if (checkBypass(reqUrl))
      return proxyUrl;
    let proxyVar;
    return usingSsl ? proxyVar = process.env.https_proxy || process.env.HTTPS_PROXY : proxyVar = process.env.http_proxy || process.env.HTTP_PROXY, proxyVar && (proxyUrl = new URL(proxyVar)), proxyUrl;
  }
  __name(getProxyUrl, "getProxyUrl");
  exports2.getProxyUrl = getProxyUrl;
  function checkBypass(reqUrl) {
    if (!reqUrl.hostname)
      return !1;
    let noProxy = process.env.no_proxy || process.env.NO_PROXY || "";
    if (!noProxy)
      return !1;
    let reqPort;
    reqUrl.port ? reqPort = Number(reqUrl.port) : reqUrl.protocol === "http:" ? reqPort = 80 : reqUrl.protocol === "https:" && (reqPort = 443);
    let upperReqHosts = [reqUrl.hostname.toUpperCase()];
    typeof reqPort == "number" && upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    for (let upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x))
      if (upperReqHosts.some((x) => x === upperNoProxyItem))
        return !0;
    return !1;
  }
  __name(checkBypass, "checkBypass");
  exports2.checkBypass = checkBypass;
});

// ../node_modules/tunnel/lib/tunnel.js
var require_tunnel = __commonJS((exports2) => {
  "use strict";
  var net = require("net"), tls = require("tls"), http3 = require("http"), https3 = require("https"), events = require("events"), assert = require("assert"), util3 = require("util");
  exports2.httpOverHttp = httpOverHttp2;
  exports2.httpsOverHttp = httpsOverHttp2;
  exports2.httpOverHttps = httpOverHttps2;
  exports2.httpsOverHttps = httpsOverHttps2;
  function httpOverHttp2(options) {
    var agent = new TunnelingAgent(options);
    return agent.request = http3.request, agent;
  }
  __name(httpOverHttp2, "httpOverHttp");
  function httpsOverHttp2(options) {
    var agent = new TunnelingAgent(options);
    return agent.request = http3.request, agent.createSocket = createSecureSocket, agent.defaultPort = 443, agent;
  }
  __name(httpsOverHttp2, "httpsOverHttp");
  function httpOverHttps2(options) {
    var agent = new TunnelingAgent(options);
    return agent.request = https3.request, agent;
  }
  __name(httpOverHttps2, "httpOverHttps");
  function httpsOverHttps2(options) {
    var agent = new TunnelingAgent(options);
    return agent.request = https3.request, agent.createSocket = createSecureSocket, agent.defaultPort = 443, agent;
  }
  __name(httpsOverHttps2, "httpsOverHttps");
  function TunnelingAgent(options) {
    var self = this;
    self.options = options || {}, self.proxyOptions = self.options.proxy || {}, self.maxSockets = self.options.maxSockets || http3.Agent.defaultMaxSockets, self.requests = [], self.sockets = [], self.on("free", /* @__PURE__ */ __name(function(socket, host, port, localAddress) {
      for (var options2 = toOptions(host, port, localAddress), i = 0, len = self.requests.length; i < len; ++i) {
        var pending = self.requests[i];
        if (pending.host === options2.host && pending.port === options2.port) {
          self.requests.splice(i, 1), pending.request.onSocket(socket);
          return;
        }
      }
      socket.destroy(), self.removeSocket(socket);
    }, "onFree"));
  }
  __name(TunnelingAgent, "TunnelingAgent");
  util3.inherits(TunnelingAgent, events.EventEmitter);
  TunnelingAgent.prototype.addRequest = /* @__PURE__ */ __name(function(req, host, port, localAddress) {
    var self = this, options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));
    if (self.sockets.length >= this.maxSockets) {
      self.requests.push(options);
      return;
    }
    self.createSocket(options, function(socket) {
      socket.on("free", onFree), socket.on("close", onCloseOrRemove), socket.on("agentRemove", onCloseOrRemove), req.onSocket(socket);
      function onFree() {
        self.emit("free", socket, options);
      }
      __name(onFree, "onFree");
      function onCloseOrRemove(err) {
        self.removeSocket(socket), socket.removeListener("free", onFree), socket.removeListener("close", onCloseOrRemove), socket.removeListener("agentRemove", onCloseOrRemove);
      }
      __name(onCloseOrRemove, "onCloseOrRemove");
    });
  }, "addRequest");
  TunnelingAgent.prototype.createSocket = /* @__PURE__ */ __name(function(options, cb) {
    var self = this, placeholder = {};
    self.sockets.push(placeholder);
    var connectOptions = mergeOptions({}, self.proxyOptions, {
      method: "CONNECT",
      path: options.host + ":" + options.port,
      agent: !1,
      headers: {
        host: options.host + ":" + options.port
      }
    });
    options.localAddress && (connectOptions.localAddress = options.localAddress), connectOptions.proxyAuth && (connectOptions.headers = connectOptions.headers || {}, connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64")), debug("making CONNECT request");
    var connectReq = self.request(connectOptions);
    connectReq.useChunkedEncodingByDefault = !1, connectReq.once("response", onResponse), connectReq.once("upgrade", onUpgrade), connectReq.once("connect", onConnect), connectReq.once("error", onError), connectReq.end();
    function onResponse(res) {
      res.upgrade = !0;
    }
    __name(onResponse, "onResponse");
    function onUpgrade(res, socket, head) {
      process.nextTick(function() {
        onConnect(res, socket, head);
      });
    }
    __name(onUpgrade, "onUpgrade");
    function onConnect(res, socket, head) {
      if (connectReq.removeAllListeners(), socket.removeAllListeners(), res.statusCode !== 200) {
        debug("tunneling socket could not be established, statusCode=%d", res.statusCode), socket.destroy();
        var error = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
        error.code = "ECONNRESET", options.request.emit("error", error), self.removeSocket(placeholder);
        return;
      }
      if (head.length > 0) {
        debug("got illegal response body from proxy"), socket.destroy();
        var error = new Error("got illegal response body from proxy");
        error.code = "ECONNRESET", options.request.emit("error", error), self.removeSocket(placeholder);
        return;
      }
      return debug("tunneling connection has established"), self.sockets[self.sockets.indexOf(placeholder)] = socket, cb(socket);
    }
    __name(onConnect, "onConnect");
    function onError(cause) {
      connectReq.removeAllListeners(), debug(`tunneling socket could not be established, cause=%s
`, cause.message, cause.stack);
      var error = new Error("tunneling socket could not be established, cause=" + cause.message);
      error.code = "ECONNRESET", options.request.emit("error", error), self.removeSocket(placeholder);
    }
    __name(onError, "onError");
  }, "createSocket");
  TunnelingAgent.prototype.removeSocket = /* @__PURE__ */ __name(function(socket) {
    var pos = this.sockets.indexOf(socket);
    if (pos !== -1) {
      this.sockets.splice(pos, 1);
      var pending = this.requests.shift();
      pending && this.createSocket(pending, function(socket2) {
        pending.request.onSocket(socket2);
      });
    }
  }, "removeSocket");
  function createSecureSocket(options, cb) {
    var self = this;
    TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
      var hostHeader = options.request.getHeader("host"), tlsOptions = mergeOptions({}, self.options, {
        socket,
        servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
      }), secureSocket = tls.connect(0, tlsOptions);
      self.sockets[self.sockets.indexOf(socket)] = secureSocket, cb(secureSocket);
    });
  }
  __name(createSecureSocket, "createSecureSocket");
  function toOptions(host, port, localAddress) {
    return typeof host == "string" ? {
      host,
      port,
      localAddress
    } : host;
  }
  __name(toOptions, "toOptions");
  function mergeOptions(target) {
    for (var i = 1, len = arguments.length; i < len; ++i) {
      var overrides = arguments[i];
      if (typeof overrides == "object")
        for (var keys = Object.keys(overrides), j = 0, keyLen = keys.length; j < keyLen; ++j) {
          var k = keys[j];
          overrides[k] !== void 0 && (target[k] = overrides[k]);
        }
    }
    return target;
  }
  __name(mergeOptions, "mergeOptions");
  var debug;
  process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG) ? debug = /* @__PURE__ */ __name(function() {
    var args = Array.prototype.slice.call(arguments);
    typeof args[0] == "string" ? args[0] = "TUNNEL: " + args[0] : args.unshift("TUNNEL:"), console.error.apply(console, args);
  }, "debug") : debug = /* @__PURE__ */ __name(function() {
  }, "debug");
  exports2.debug = debug;
});

// ../node_modules/tunnel/index.js
var require_tunnel2 = __commonJS((exports2, module2) => {
  module2.exports = require_tunnel();
});

// ../node_modules/@actions/http-client/index.js
var require_http_client = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var http3 = require("http"), https3 = require("https"), pm = require_proxy(), tunnel2, HttpCodes;
  (function(HttpCodes2) {
    HttpCodes2[HttpCodes2.OK = 200] = "OK", HttpCodes2[HttpCodes2.MultipleChoices = 300] = "MultipleChoices", HttpCodes2[HttpCodes2.MovedPermanently = 301] = "MovedPermanently", HttpCodes2[HttpCodes2.ResourceMoved = 302] = "ResourceMoved", HttpCodes2[HttpCodes2.SeeOther = 303] = "SeeOther", HttpCodes2[HttpCodes2.NotModified = 304] = "NotModified", HttpCodes2[HttpCodes2.UseProxy = 305] = "UseProxy", HttpCodes2[HttpCodes2.SwitchProxy = 306] = "SwitchProxy", HttpCodes2[HttpCodes2.TemporaryRedirect = 307] = "TemporaryRedirect", HttpCodes2[HttpCodes2.PermanentRedirect = 308] = "PermanentRedirect", HttpCodes2[HttpCodes2.BadRequest = 400] = "BadRequest", HttpCodes2[HttpCodes2.Unauthorized = 401] = "Unauthorized", HttpCodes2[HttpCodes2.PaymentRequired = 402] = "PaymentRequired", HttpCodes2[HttpCodes2.Forbidden = 403] = "Forbidden", HttpCodes2[HttpCodes2.NotFound = 404] = "NotFound", HttpCodes2[HttpCodes2.MethodNotAllowed = 405] = "MethodNotAllowed", HttpCodes2[HttpCodes2.NotAcceptable = 406] = "NotAcceptable", HttpCodes2[HttpCodes2.ProxyAuthenticationRequired = 407] = "ProxyAuthenticationRequired", HttpCodes2[HttpCodes2.RequestTimeout = 408] = "RequestTimeout", HttpCodes2[HttpCodes2.Conflict = 409] = "Conflict", HttpCodes2[HttpCodes2.Gone = 410] = "Gone", HttpCodes2[HttpCodes2.TooManyRequests = 429] = "TooManyRequests", HttpCodes2[HttpCodes2.InternalServerError = 500] = "InternalServerError", HttpCodes2[HttpCodes2.NotImplemented = 501] = "NotImplemented", HttpCodes2[HttpCodes2.BadGateway = 502] = "BadGateway", HttpCodes2[HttpCodes2.ServiceUnavailable = 503] = "ServiceUnavailable", HttpCodes2[HttpCodes2.GatewayTimeout = 504] = "GatewayTimeout";
  })(HttpCodes = exports2.HttpCodes || (exports2.HttpCodes = {}));
  var Headers2;
  (function(Headers3) {
    Headers3.Accept = "accept", Headers3.ContentType = "content-type";
  })(Headers2 = exports2.Headers || (exports2.Headers = {}));
  var MediaTypes;
  (function(MediaTypes2) {
    MediaTypes2.ApplicationJson = "application/json";
  })(MediaTypes = exports2.MediaTypes || (exports2.MediaTypes = {}));
  function getProxyUrl(serverUrl) {
    let proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : "";
  }
  __name(getProxyUrl, "getProxyUrl");
  exports2.getProxyUrl = getProxyUrl;
  var HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
  ], HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
  ], RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"], ExponentialBackoffCeiling = 10, ExponentialBackoffTimeSlice = 5, HttpClientError = class extends Error {
    constructor(message, statusCode) {
      super(message);
      this.name = "HttpClientError", this.statusCode = statusCode, Object.setPrototypeOf(this, HttpClientError.prototype);
    }
  };
  __name(HttpClientError, "HttpClientError");
  exports2.HttpClientError = HttpClientError;
  var HttpClientResponse = class {
    constructor(message) {
      this.message = message;
    }
    readBody() {
      return new Promise(async (resolve, reject) => {
        let output = Buffer.alloc(0);
        this.message.on("data", (chunk) => {
          output = Buffer.concat([output, chunk]);
        }), this.message.on("end", () => {
          resolve(output.toString());
        });
      });
    }
  };
  __name(HttpClientResponse, "HttpClientResponse");
  exports2.HttpClientResponse = HttpClientResponse;
  function isHttps(requestUrl) {
    return new URL(requestUrl).protocol === "https:";
  }
  __name(isHttps, "isHttps");
  exports2.isHttps = isHttps;
  var HttpClient = class {
    constructor(userAgent, handlers, requestOptions) {
      this._ignoreSslError = !1, this._allowRedirects = !0, this._allowRedirectDowngrade = !1, this._maxRedirects = 50, this._allowRetries = !1, this._maxRetries = 1, this._keepAlive = !1, this._disposed = !1, this.userAgent = userAgent, this.handlers = handlers || [], this.requestOptions = requestOptions, requestOptions && (requestOptions.ignoreSslError != null && (this._ignoreSslError = requestOptions.ignoreSslError), this._socketTimeout = requestOptions.socketTimeout, requestOptions.allowRedirects != null && (this._allowRedirects = requestOptions.allowRedirects), requestOptions.allowRedirectDowngrade != null && (this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade), requestOptions.maxRedirects != null && (this._maxRedirects = Math.max(requestOptions.maxRedirects, 0)), requestOptions.keepAlive != null && (this._keepAlive = requestOptions.keepAlive), requestOptions.allowRetries != null && (this._allowRetries = requestOptions.allowRetries), requestOptions.maxRetries != null && (this._maxRetries = requestOptions.maxRetries));
    }
    options(requestUrl, additionalHeaders) {
      return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
    }
    get(requestUrl, additionalHeaders) {
      return this.request("GET", requestUrl, null, additionalHeaders || {});
    }
    del(requestUrl, additionalHeaders) {
      return this.request("DELETE", requestUrl, null, additionalHeaders || {});
    }
    post(requestUrl, data, additionalHeaders) {
      return this.request("POST", requestUrl, data, additionalHeaders || {});
    }
    patch(requestUrl, data, additionalHeaders) {
      return this.request("PATCH", requestUrl, data, additionalHeaders || {});
    }
    put(requestUrl, data, additionalHeaders) {
      return this.request("PUT", requestUrl, data, additionalHeaders || {});
    }
    head(requestUrl, additionalHeaders) {
      return this.request("HEAD", requestUrl, null, additionalHeaders || {});
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
      return this.request(verb, requestUrl, stream, additionalHeaders);
    }
    async getJson(requestUrl, additionalHeaders = {}) {
      additionalHeaders[Headers2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers2.Accept, MediaTypes.ApplicationJson);
      let res = await this.get(requestUrl, additionalHeaders);
      return this._processResponse(res, this.requestOptions);
    }
    async postJson(requestUrl, obj, additionalHeaders = {}) {
      let data = JSON.stringify(obj, null, 2);
      additionalHeaders[Headers2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers2.Accept, MediaTypes.ApplicationJson), additionalHeaders[Headers2.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers2.ContentType, MediaTypes.ApplicationJson);
      let res = await this.post(requestUrl, data, additionalHeaders);
      return this._processResponse(res, this.requestOptions);
    }
    async putJson(requestUrl, obj, additionalHeaders = {}) {
      let data = JSON.stringify(obj, null, 2);
      additionalHeaders[Headers2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers2.Accept, MediaTypes.ApplicationJson), additionalHeaders[Headers2.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers2.ContentType, MediaTypes.ApplicationJson);
      let res = await this.put(requestUrl, data, additionalHeaders);
      return this._processResponse(res, this.requestOptions);
    }
    async patchJson(requestUrl, obj, additionalHeaders = {}) {
      let data = JSON.stringify(obj, null, 2);
      additionalHeaders[Headers2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers2.Accept, MediaTypes.ApplicationJson), additionalHeaders[Headers2.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers2.ContentType, MediaTypes.ApplicationJson);
      let res = await this.patch(requestUrl, data, additionalHeaders);
      return this._processResponse(res, this.requestOptions);
    }
    async request(verb, requestUrl, data, headers) {
      if (this._disposed)
        throw new Error("Client has already been disposed.");
      let parsedUrl = new URL(requestUrl), info2 = this._prepareRequest(verb, parsedUrl, headers), maxTries = this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1 ? this._maxRetries + 1 : 1, numTries = 0, response;
      for (; numTries < maxTries; ) {
        if (response = await this.requestRaw(info2, data), response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
          let authenticationHandler;
          for (let i = 0; i < this.handlers.length; i++)
            if (this.handlers[i].canHandleAuthentication(response)) {
              authenticationHandler = this.handlers[i];
              break;
            }
          return authenticationHandler ? authenticationHandler.handleAuthentication(this, info2, data) : response;
        }
        let redirectsRemaining = this._maxRedirects;
        for (; HttpRedirectCodes.indexOf(response.message.statusCode) != -1 && this._allowRedirects && redirectsRemaining > 0; ) {
          let redirectUrl = response.message.headers.location;
          if (!redirectUrl)
            break;
          let parsedRedirectUrl = new URL(redirectUrl);
          if (parsedUrl.protocol == "https:" && parsedUrl.protocol != parsedRedirectUrl.protocol && !this._allowRedirectDowngrade)
            throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
          if (await response.readBody(), parsedRedirectUrl.hostname !== parsedUrl.hostname)
            for (let header in headers)
              header.toLowerCase() === "authorization" && delete headers[header];
          info2 = this._prepareRequest(verb, parsedRedirectUrl, headers), response = await this.requestRaw(info2, data), redirectsRemaining--;
        }
        if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1)
          return response;
        numTries += 1, numTries < maxTries && (await response.readBody(), await this._performExponentialBackoff(numTries));
      }
      return response;
    }
    dispose() {
      this._agent && this._agent.destroy(), this._disposed = !0;
    }
    requestRaw(info2, data) {
      return new Promise((resolve, reject) => {
        let callbackForResult = /* @__PURE__ */ __name(function(err, res) {
          err && reject(err), resolve(res);
        }, "callbackForResult");
        this.requestRawWithCallback(info2, data, callbackForResult);
      });
    }
    requestRawWithCallback(info2, data, onResult) {
      let socket;
      typeof data == "string" && (info2.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8"));
      let callbackCalled = !1, handleResult = /* @__PURE__ */ __name((err, res) => {
        callbackCalled || (callbackCalled = !0, onResult(err, res));
      }, "handleResult"), req = info2.httpModule.request(info2.options, (msg) => {
        let res = new HttpClientResponse(msg);
        handleResult(null, res);
      });
      req.on("socket", (sock) => {
        socket = sock;
      }), req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
        socket && socket.end(), handleResult(new Error("Request timeout: " + info2.options.path), null);
      }), req.on("error", function(err) {
        handleResult(err, null);
      }), data && typeof data == "string" && req.write(data, "utf8"), data && typeof data != "string" ? (data.on("close", function() {
        req.end();
      }), data.pipe(req)) : req.end();
    }
    getAgent(serverUrl) {
      let parsedUrl = new URL(serverUrl);
      return this._getAgent(parsedUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
      let info2 = {};
      info2.parsedUrl = requestUrl;
      let usingSsl = info2.parsedUrl.protocol === "https:";
      info2.httpModule = usingSsl ? https3 : http3;
      let defaultPort = usingSsl ? 443 : 80;
      return info2.options = {}, info2.options.host = info2.parsedUrl.hostname, info2.options.port = info2.parsedUrl.port ? parseInt(info2.parsedUrl.port) : defaultPort, info2.options.path = (info2.parsedUrl.pathname || "") + (info2.parsedUrl.search || ""), info2.options.method = method, info2.options.headers = this._mergeHeaders(headers), this.userAgent != null && (info2.options.headers["user-agent"] = this.userAgent), info2.options.agent = this._getAgent(info2.parsedUrl), this.handlers && this.handlers.forEach((handler) => {
        handler.prepareRequest(info2.options);
      }), info2;
    }
    _mergeHeaders(headers) {
      let lowercaseKeys = /* @__PURE__ */ __name((obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {}), "lowercaseKeys");
      return this.requestOptions && this.requestOptions.headers ? Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers)) : lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
      let lowercaseKeys = /* @__PURE__ */ __name((obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {}), "lowercaseKeys"), clientHeader;
      return this.requestOptions && this.requestOptions.headers && (clientHeader = lowercaseKeys(this.requestOptions.headers)[header]), additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
      let agent, proxyUrl = pm.getProxyUrl(parsedUrl), useProxy = proxyUrl && proxyUrl.hostname;
      if (this._keepAlive && useProxy && (agent = this._proxyAgent), this._keepAlive && !useProxy && (agent = this._agent), agent)
        return agent;
      let usingSsl = parsedUrl.protocol === "https:", maxSockets = 100;
      if (this.requestOptions && (maxSockets = this.requestOptions.maxSockets || http3.globalAgent.maxSockets), useProxy) {
        tunnel2 || (tunnel2 = require_tunnel2());
        let agentOptions = {
          maxSockets,
          keepAlive: this._keepAlive,
          proxy: {
            proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`,
            host: proxyUrl.hostname,
            port: proxyUrl.port
          }
        }, tunnelAgent, overHttps = proxyUrl.protocol === "https:";
        usingSsl ? tunnelAgent = overHttps ? tunnel2.httpsOverHttps : tunnel2.httpsOverHttp : tunnelAgent = overHttps ? tunnel2.httpOverHttps : tunnel2.httpOverHttp, agent = tunnelAgent(agentOptions), this._proxyAgent = agent;
      }
      if (this._keepAlive && !agent) {
        let options = {keepAlive: this._keepAlive, maxSockets};
        agent = usingSsl ? new https3.Agent(options) : new http3.Agent(options), this._agent = agent;
      }
      return agent || (agent = usingSsl ? https3.globalAgent : http3.globalAgent), usingSsl && this._ignoreSslError && (agent.options = Object.assign(agent.options || {}, {
        rejectUnauthorized: !1
      })), agent;
    }
    _performExponentialBackoff(retryNumber) {
      retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
      let ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
      return new Promise((resolve) => setTimeout(() => resolve(), ms));
    }
    static dateTimeDeserializer(key, value) {
      if (typeof value == "string") {
        let a = new Date(value);
        if (!isNaN(a.valueOf()))
          return a;
      }
      return value;
    }
    async _processResponse(res, options) {
      return new Promise(async (resolve, reject) => {
        let statusCode = res.message.statusCode, response = {
          statusCode,
          result: null,
          headers: {}
        };
        statusCode == HttpCodes.NotFound && resolve(response);
        let obj, contents;
        try {
          contents = await res.readBody(), contents && contents.length > 0 && (options && options.deserializeDates ? obj = JSON.parse(contents, HttpClient.dateTimeDeserializer) : obj = JSON.parse(contents), response.result = obj), response.headers = res.message.headers;
        } catch (err) {
        }
        if (statusCode > 299) {
          let msg;
          obj && obj.message ? msg = obj.message : contents && contents.length > 0 ? msg = contents : msg = "Failed request: (" + statusCode + ")";
          let err = new HttpClientError(msg, statusCode);
          err.result = response.result, reject(err);
        } else
          resolve(response);
      });
    }
  };
  __name(HttpClient, "HttpClient");
  exports2.HttpClient = HttpClient;
});

// ../node_modules/@actions/http-client/auth.js
var require_auth = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var BasicCredentialHandler = class {
    constructor(username, password) {
      this.username = username, this.password = password;
    }
    prepareRequest(options) {
      options.headers.Authorization = "Basic " + Buffer.from(this.username + ":" + this.password).toString("base64");
    }
    canHandleAuthentication(response) {
      return !1;
    }
    handleAuthentication(httpClient, requestInfo, objs) {
      return null;
    }
  };
  __name(BasicCredentialHandler, "BasicCredentialHandler");
  exports2.BasicCredentialHandler = BasicCredentialHandler;
  var BearerCredentialHandler = class {
    constructor(token) {
      this.token = token;
    }
    prepareRequest(options) {
      options.headers.Authorization = "Bearer " + this.token;
    }
    canHandleAuthentication(response) {
      return !1;
    }
    handleAuthentication(httpClient, requestInfo, objs) {
      return null;
    }
  };
  __name(BearerCredentialHandler, "BearerCredentialHandler");
  exports2.BearerCredentialHandler = BearerCredentialHandler;
  var PersonalAccessTokenCredentialHandler = class {
    constructor(token) {
      this.token = token;
    }
    prepareRequest(options) {
      options.headers.Authorization = "Basic " + Buffer.from("PAT:" + this.token).toString("base64");
    }
    canHandleAuthentication(response) {
      return !1;
    }
    handleAuthentication(httpClient, requestInfo, objs) {
      return null;
    }
  };
  __name(PersonalAccessTokenCredentialHandler, "PersonalAccessTokenCredentialHandler");
  exports2.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
});

// ../node_modules/psl/data/rules.json
var require_rules = __commonJS((exports2, module2) => {
  module2.exports = [
    "ac",
    "com.ac",
    "edu.ac",
    "gov.ac",
    "net.ac",
    "mil.ac",
    "org.ac",
    "ad",
    "nom.ad",
    "ae",
    "co.ae",
    "net.ae",
    "org.ae",
    "sch.ae",
    "ac.ae",
    "gov.ae",
    "mil.ae",
    "aero",
    "accident-investigation.aero",
    "accident-prevention.aero",
    "aerobatic.aero",
    "aeroclub.aero",
    "aerodrome.aero",
    "agents.aero",
    "aircraft.aero",
    "airline.aero",
    "airport.aero",
    "air-surveillance.aero",
    "airtraffic.aero",
    "air-traffic-control.aero",
    "ambulance.aero",
    "amusement.aero",
    "association.aero",
    "author.aero",
    "ballooning.aero",
    "broker.aero",
    "caa.aero",
    "cargo.aero",
    "catering.aero",
    "certification.aero",
    "championship.aero",
    "charter.aero",
    "civilaviation.aero",
    "club.aero",
    "conference.aero",
    "consultant.aero",
    "consulting.aero",
    "control.aero",
    "council.aero",
    "crew.aero",
    "design.aero",
    "dgca.aero",
    "educator.aero",
    "emergency.aero",
    "engine.aero",
    "engineer.aero",
    "entertainment.aero",
    "equipment.aero",
    "exchange.aero",
    "express.aero",
    "federation.aero",
    "flight.aero",
    "freight.aero",
    "fuel.aero",
    "gliding.aero",
    "government.aero",
    "groundhandling.aero",
    "group.aero",
    "hanggliding.aero",
    "homebuilt.aero",
    "insurance.aero",
    "journal.aero",
    "journalist.aero",
    "leasing.aero",
    "logistics.aero",
    "magazine.aero",
    "maintenance.aero",
    "media.aero",
    "microlight.aero",
    "modelling.aero",
    "navigation.aero",
    "parachuting.aero",
    "paragliding.aero",
    "passenger-association.aero",
    "pilot.aero",
    "press.aero",
    "production.aero",
    "recreation.aero",
    "repbody.aero",
    "res.aero",
    "research.aero",
    "rotorcraft.aero",
    "safety.aero",
    "scientist.aero",
    "services.aero",
    "show.aero",
    "skydiving.aero",
    "software.aero",
    "student.aero",
    "trader.aero",
    "trading.aero",
    "trainer.aero",
    "union.aero",
    "workinggroup.aero",
    "works.aero",
    "af",
    "gov.af",
    "com.af",
    "org.af",
    "net.af",
    "edu.af",
    "ag",
    "com.ag",
    "org.ag",
    "net.ag",
    "co.ag",
    "nom.ag",
    "ai",
    "off.ai",
    "com.ai",
    "net.ai",
    "org.ai",
    "al",
    "com.al",
    "edu.al",
    "gov.al",
    "mil.al",
    "net.al",
    "org.al",
    "am",
    "co.am",
    "com.am",
    "commune.am",
    "net.am",
    "org.am",
    "ao",
    "ed.ao",
    "gv.ao",
    "og.ao",
    "co.ao",
    "pb.ao",
    "it.ao",
    "aq",
    "ar",
    "com.ar",
    "edu.ar",
    "gob.ar",
    "gov.ar",
    "int.ar",
    "mil.ar",
    "musica.ar",
    "net.ar",
    "org.ar",
    "tur.ar",
    "arpa",
    "e164.arpa",
    "in-addr.arpa",
    "ip6.arpa",
    "iris.arpa",
    "uri.arpa",
    "urn.arpa",
    "as",
    "gov.as",
    "asia",
    "at",
    "ac.at",
    "co.at",
    "gv.at",
    "or.at",
    "au",
    "com.au",
    "net.au",
    "org.au",
    "edu.au",
    "gov.au",
    "asn.au",
    "id.au",
    "info.au",
    "conf.au",
    "oz.au",
    "act.au",
    "nsw.au",
    "nt.au",
    "qld.au",
    "sa.au",
    "tas.au",
    "vic.au",
    "wa.au",
    "act.edu.au",
    "catholic.edu.au",
    "nsw.edu.au",
    "nt.edu.au",
    "qld.edu.au",
    "sa.edu.au",
    "tas.edu.au",
    "vic.edu.au",
    "wa.edu.au",
    "qld.gov.au",
    "sa.gov.au",
    "tas.gov.au",
    "vic.gov.au",
    "wa.gov.au",
    "education.tas.edu.au",
    "schools.nsw.edu.au",
    "aw",
    "com.aw",
    "ax",
    "az",
    "com.az",
    "net.az",
    "int.az",
    "gov.az",
    "org.az",
    "edu.az",
    "info.az",
    "pp.az",
    "mil.az",
    "name.az",
    "pro.az",
    "biz.az",
    "ba",
    "com.ba",
    "edu.ba",
    "gov.ba",
    "mil.ba",
    "net.ba",
    "org.ba",
    "bb",
    "biz.bb",
    "co.bb",
    "com.bb",
    "edu.bb",
    "gov.bb",
    "info.bb",
    "net.bb",
    "org.bb",
    "store.bb",
    "tv.bb",
    "*.bd",
    "be",
    "ac.be",
    "bf",
    "gov.bf",
    "bg",
    "a.bg",
    "b.bg",
    "c.bg",
    "d.bg",
    "e.bg",
    "f.bg",
    "g.bg",
    "h.bg",
    "i.bg",
    "j.bg",
    "k.bg",
    "l.bg",
    "m.bg",
    "n.bg",
    "o.bg",
    "p.bg",
    "q.bg",
    "r.bg",
    "s.bg",
    "t.bg",
    "u.bg",
    "v.bg",
    "w.bg",
    "x.bg",
    "y.bg",
    "z.bg",
    "0.bg",
    "1.bg",
    "2.bg",
    "3.bg",
    "4.bg",
    "5.bg",
    "6.bg",
    "7.bg",
    "8.bg",
    "9.bg",
    "bh",
    "com.bh",
    "edu.bh",
    "net.bh",
    "org.bh",
    "gov.bh",
    "bi",
    "co.bi",
    "com.bi",
    "edu.bi",
    "or.bi",
    "org.bi",
    "biz",
    "bj",
    "asso.bj",
    "barreau.bj",
    "gouv.bj",
    "bm",
    "com.bm",
    "edu.bm",
    "gov.bm",
    "net.bm",
    "org.bm",
    "bn",
    "com.bn",
    "edu.bn",
    "gov.bn",
    "net.bn",
    "org.bn",
    "bo",
    "com.bo",
    "edu.bo",
    "gob.bo",
    "int.bo",
    "org.bo",
    "net.bo",
    "mil.bo",
    "tv.bo",
    "web.bo",
    "academia.bo",
    "agro.bo",
    "arte.bo",
    "blog.bo",
    "bolivia.bo",
    "ciencia.bo",
    "cooperativa.bo",
    "democracia.bo",
    "deporte.bo",
    "ecologia.bo",
    "economia.bo",
    "empresa.bo",
    "indigena.bo",
    "industria.bo",
    "info.bo",
    "medicina.bo",
    "movimiento.bo",
    "musica.bo",
    "natural.bo",
    "nombre.bo",
    "noticias.bo",
    "patria.bo",
    "politica.bo",
    "profesional.bo",
    "plurinacional.bo",
    "pueblo.bo",
    "revista.bo",
    "salud.bo",
    "tecnologia.bo",
    "tksat.bo",
    "transporte.bo",
    "wiki.bo",
    "br",
    "9guacu.br",
    "abc.br",
    "adm.br",
    "adv.br",
    "agr.br",
    "aju.br",
    "am.br",
    "anani.br",
    "aparecida.br",
    "arq.br",
    "art.br",
    "ato.br",
    "b.br",
    "barueri.br",
    "belem.br",
    "bhz.br",
    "bio.br",
    "blog.br",
    "bmd.br",
    "boavista.br",
    "bsb.br",
    "campinagrande.br",
    "campinas.br",
    "caxias.br",
    "cim.br",
    "cng.br",
    "cnt.br",
    "com.br",
    "contagem.br",
    "coop.br",
    "cri.br",
    "cuiaba.br",
    "curitiba.br",
    "def.br",
    "ecn.br",
    "eco.br",
    "edu.br",
    "emp.br",
    "eng.br",
    "esp.br",
    "etc.br",
    "eti.br",
    "far.br",
    "feira.br",
    "flog.br",
    "floripa.br",
    "fm.br",
    "fnd.br",
    "fortal.br",
    "fot.br",
    "foz.br",
    "fst.br",
    "g12.br",
    "ggf.br",
    "goiania.br",
    "gov.br",
    "ac.gov.br",
    "al.gov.br",
    "am.gov.br",
    "ap.gov.br",
    "ba.gov.br",
    "ce.gov.br",
    "df.gov.br",
    "es.gov.br",
    "go.gov.br",
    "ma.gov.br",
    "mg.gov.br",
    "ms.gov.br",
    "mt.gov.br",
    "pa.gov.br",
    "pb.gov.br",
    "pe.gov.br",
    "pi.gov.br",
    "pr.gov.br",
    "rj.gov.br",
    "rn.gov.br",
    "ro.gov.br",
    "rr.gov.br",
    "rs.gov.br",
    "sc.gov.br",
    "se.gov.br",
    "sp.gov.br",
    "to.gov.br",
    "gru.br",
    "imb.br",
    "ind.br",
    "inf.br",
    "jab.br",
    "jampa.br",
    "jdf.br",
    "joinville.br",
    "jor.br",
    "jus.br",
    "leg.br",
    "lel.br",
    "londrina.br",
    "macapa.br",
    "maceio.br",
    "manaus.br",
    "maringa.br",
    "mat.br",
    "med.br",
    "mil.br",
    "morena.br",
    "mp.br",
    "mus.br",
    "natal.br",
    "net.br",
    "niteroi.br",
    "*.nom.br",
    "not.br",
    "ntr.br",
    "odo.br",
    "ong.br",
    "org.br",
    "osasco.br",
    "palmas.br",
    "poa.br",
    "ppg.br",
    "pro.br",
    "psc.br",
    "psi.br",
    "pvh.br",
    "qsl.br",
    "radio.br",
    "rec.br",
    "recife.br",
    "ribeirao.br",
    "rio.br",
    "riobranco.br",
    "riopreto.br",
    "salvador.br",
    "sampa.br",
    "santamaria.br",
    "santoandre.br",
    "saobernardo.br",
    "saogonca.br",
    "sjc.br",
    "slg.br",
    "slz.br",
    "sorocaba.br",
    "srv.br",
    "taxi.br",
    "tc.br",
    "teo.br",
    "the.br",
    "tmp.br",
    "trd.br",
    "tur.br",
    "tv.br",
    "udi.br",
    "vet.br",
    "vix.br",
    "vlog.br",
    "wiki.br",
    "zlg.br",
    "bs",
    "com.bs",
    "net.bs",
    "org.bs",
    "edu.bs",
    "gov.bs",
    "bt",
    "com.bt",
    "edu.bt",
    "gov.bt",
    "net.bt",
    "org.bt",
    "bv",
    "bw",
    "co.bw",
    "org.bw",
    "by",
    "gov.by",
    "mil.by",
    "com.by",
    "of.by",
    "bz",
    "com.bz",
    "net.bz",
    "org.bz",
    "edu.bz",
    "gov.bz",
    "ca",
    "ab.ca",
    "bc.ca",
    "mb.ca",
    "nb.ca",
    "nf.ca",
    "nl.ca",
    "ns.ca",
    "nt.ca",
    "nu.ca",
    "on.ca",
    "pe.ca",
    "qc.ca",
    "sk.ca",
    "yk.ca",
    "gc.ca",
    "cat",
    "cc",
    "cd",
    "gov.cd",
    "cf",
    "cg",
    "ch",
    "ci",
    "org.ci",
    "or.ci",
    "com.ci",
    "co.ci",
    "edu.ci",
    "ed.ci",
    "ac.ci",
    "net.ci",
    "go.ci",
    "asso.ci",
    "a\xE9roport.ci",
    "int.ci",
    "presse.ci",
    "md.ci",
    "gouv.ci",
    "*.ck",
    "!www.ck",
    "cl",
    "aprendemas.cl",
    "co.cl",
    "gob.cl",
    "gov.cl",
    "mil.cl",
    "cm",
    "co.cm",
    "com.cm",
    "gov.cm",
    "net.cm",
    "cn",
    "ac.cn",
    "com.cn",
    "edu.cn",
    "gov.cn",
    "net.cn",
    "org.cn",
    "mil.cn",
    "\u516C\u53F8.cn",
    "\u7F51\u7EDC.cn",
    "\u7DB2\u7D61.cn",
    "ah.cn",
    "bj.cn",
    "cq.cn",
    "fj.cn",
    "gd.cn",
    "gs.cn",
    "gz.cn",
    "gx.cn",
    "ha.cn",
    "hb.cn",
    "he.cn",
    "hi.cn",
    "hl.cn",
    "hn.cn",
    "jl.cn",
    "js.cn",
    "jx.cn",
    "ln.cn",
    "nm.cn",
    "nx.cn",
    "qh.cn",
    "sc.cn",
    "sd.cn",
    "sh.cn",
    "sn.cn",
    "sx.cn",
    "tj.cn",
    "xj.cn",
    "xz.cn",
    "yn.cn",
    "zj.cn",
    "hk.cn",
    "mo.cn",
    "tw.cn",
    "co",
    "arts.co",
    "com.co",
    "edu.co",
    "firm.co",
    "gov.co",
    "info.co",
    "int.co",
    "mil.co",
    "net.co",
    "nom.co",
    "org.co",
    "rec.co",
    "web.co",
    "com",
    "coop",
    "cr",
    "ac.cr",
    "co.cr",
    "ed.cr",
    "fi.cr",
    "go.cr",
    "or.cr",
    "sa.cr",
    "cu",
    "com.cu",
    "edu.cu",
    "org.cu",
    "net.cu",
    "gov.cu",
    "inf.cu",
    "cv",
    "cw",
    "com.cw",
    "edu.cw",
    "net.cw",
    "org.cw",
    "cx",
    "gov.cx",
    "cy",
    "ac.cy",
    "biz.cy",
    "com.cy",
    "ekloges.cy",
    "gov.cy",
    "ltd.cy",
    "name.cy",
    "net.cy",
    "org.cy",
    "parliament.cy",
    "press.cy",
    "pro.cy",
    "tm.cy",
    "cz",
    "de",
    "dj",
    "dk",
    "dm",
    "com.dm",
    "net.dm",
    "org.dm",
    "edu.dm",
    "gov.dm",
    "do",
    "art.do",
    "com.do",
    "edu.do",
    "gob.do",
    "gov.do",
    "mil.do",
    "net.do",
    "org.do",
    "sld.do",
    "web.do",
    "dz",
    "com.dz",
    "org.dz",
    "net.dz",
    "gov.dz",
    "edu.dz",
    "asso.dz",
    "pol.dz",
    "art.dz",
    "ec",
    "com.ec",
    "info.ec",
    "net.ec",
    "fin.ec",
    "k12.ec",
    "med.ec",
    "pro.ec",
    "org.ec",
    "edu.ec",
    "gov.ec",
    "gob.ec",
    "mil.ec",
    "edu",
    "ee",
    "edu.ee",
    "gov.ee",
    "riik.ee",
    "lib.ee",
    "med.ee",
    "com.ee",
    "pri.ee",
    "aip.ee",
    "org.ee",
    "fie.ee",
    "eg",
    "com.eg",
    "edu.eg",
    "eun.eg",
    "gov.eg",
    "mil.eg",
    "name.eg",
    "net.eg",
    "org.eg",
    "sci.eg",
    "*.er",
    "es",
    "com.es",
    "nom.es",
    "org.es",
    "gob.es",
    "edu.es",
    "et",
    "com.et",
    "gov.et",
    "org.et",
    "edu.et",
    "biz.et",
    "name.et",
    "info.et",
    "net.et",
    "eu",
    "fi",
    "aland.fi",
    "fj",
    "ac.fj",
    "biz.fj",
    "com.fj",
    "gov.fj",
    "info.fj",
    "mil.fj",
    "name.fj",
    "net.fj",
    "org.fj",
    "pro.fj",
    "*.fk",
    "fm",
    "fo",
    "fr",
    "asso.fr",
    "com.fr",
    "gouv.fr",
    "nom.fr",
    "prd.fr",
    "tm.fr",
    "aeroport.fr",
    "avocat.fr",
    "avoues.fr",
    "cci.fr",
    "chambagri.fr",
    "chirurgiens-dentistes.fr",
    "experts-comptables.fr",
    "geometre-expert.fr",
    "greta.fr",
    "huissier-justice.fr",
    "medecin.fr",
    "notaires.fr",
    "pharmacien.fr",
    "port.fr",
    "veterinaire.fr",
    "ga",
    "gb",
    "gd",
    "ge",
    "com.ge",
    "edu.ge",
    "gov.ge",
    "org.ge",
    "mil.ge",
    "net.ge",
    "pvt.ge",
    "gf",
    "gg",
    "co.gg",
    "net.gg",
    "org.gg",
    "gh",
    "com.gh",
    "edu.gh",
    "gov.gh",
    "org.gh",
    "mil.gh",
    "gi",
    "com.gi",
    "ltd.gi",
    "gov.gi",
    "mod.gi",
    "edu.gi",
    "org.gi",
    "gl",
    "co.gl",
    "com.gl",
    "edu.gl",
    "net.gl",
    "org.gl",
    "gm",
    "gn",
    "ac.gn",
    "com.gn",
    "edu.gn",
    "gov.gn",
    "org.gn",
    "net.gn",
    "gov",
    "gp",
    "com.gp",
    "net.gp",
    "mobi.gp",
    "edu.gp",
    "org.gp",
    "asso.gp",
    "gq",
    "gr",
    "com.gr",
    "edu.gr",
    "net.gr",
    "org.gr",
    "gov.gr",
    "gs",
    "gt",
    "com.gt",
    "edu.gt",
    "gob.gt",
    "ind.gt",
    "mil.gt",
    "net.gt",
    "org.gt",
    "gu",
    "com.gu",
    "edu.gu",
    "gov.gu",
    "guam.gu",
    "info.gu",
    "net.gu",
    "org.gu",
    "web.gu",
    "gw",
    "gy",
    "co.gy",
    "com.gy",
    "edu.gy",
    "gov.gy",
    "net.gy",
    "org.gy",
    "hk",
    "com.hk",
    "edu.hk",
    "gov.hk",
    "idv.hk",
    "net.hk",
    "org.hk",
    "\u516C\u53F8.hk",
    "\u6559\u80B2.hk",
    "\u654E\u80B2.hk",
    "\u653F\u5E9C.hk",
    "\u500B\u4EBA.hk",
    "\u4E2A\u4EBA.hk",
    "\u7B87\u4EBA.hk",
    "\u7DB2\u7EDC.hk",
    "\u7F51\u7EDC.hk",
    "\u7EC4\u7E54.hk",
    "\u7DB2\u7D61.hk",
    "\u7F51\u7D61.hk",
    "\u7EC4\u7EC7.hk",
    "\u7D44\u7E54.hk",
    "\u7D44\u7EC7.hk",
    "hm",
    "hn",
    "com.hn",
    "edu.hn",
    "org.hn",
    "net.hn",
    "mil.hn",
    "gob.hn",
    "hr",
    "iz.hr",
    "from.hr",
    "name.hr",
    "com.hr",
    "ht",
    "com.ht",
    "shop.ht",
    "firm.ht",
    "info.ht",
    "adult.ht",
    "net.ht",
    "pro.ht",
    "org.ht",
    "med.ht",
    "art.ht",
    "coop.ht",
    "pol.ht",
    "asso.ht",
    "edu.ht",
    "rel.ht",
    "gouv.ht",
    "perso.ht",
    "hu",
    "co.hu",
    "info.hu",
    "org.hu",
    "priv.hu",
    "sport.hu",
    "tm.hu",
    "2000.hu",
    "agrar.hu",
    "bolt.hu",
    "casino.hu",
    "city.hu",
    "erotica.hu",
    "erotika.hu",
    "film.hu",
    "forum.hu",
    "games.hu",
    "hotel.hu",
    "ingatlan.hu",
    "jogasz.hu",
    "konyvelo.hu",
    "lakas.hu",
    "media.hu",
    "news.hu",
    "reklam.hu",
    "sex.hu",
    "shop.hu",
    "suli.hu",
    "szex.hu",
    "tozsde.hu",
    "utazas.hu",
    "video.hu",
    "id",
    "ac.id",
    "biz.id",
    "co.id",
    "desa.id",
    "go.id",
    "mil.id",
    "my.id",
    "net.id",
    "or.id",
    "ponpes.id",
    "sch.id",
    "web.id",
    "ie",
    "gov.ie",
    "il",
    "ac.il",
    "co.il",
    "gov.il",
    "idf.il",
    "k12.il",
    "muni.il",
    "net.il",
    "org.il",
    "im",
    "ac.im",
    "co.im",
    "com.im",
    "ltd.co.im",
    "net.im",
    "org.im",
    "plc.co.im",
    "tt.im",
    "tv.im",
    "in",
    "co.in",
    "firm.in",
    "net.in",
    "org.in",
    "gen.in",
    "ind.in",
    "nic.in",
    "ac.in",
    "edu.in",
    "res.in",
    "gov.in",
    "mil.in",
    "info",
    "int",
    "eu.int",
    "io",
    "com.io",
    "iq",
    "gov.iq",
    "edu.iq",
    "mil.iq",
    "com.iq",
    "org.iq",
    "net.iq",
    "ir",
    "ac.ir",
    "co.ir",
    "gov.ir",
    "id.ir",
    "net.ir",
    "org.ir",
    "sch.ir",
    "\u0627\u06CC\u0631\u0627\u0646.ir",
    "\u0627\u064A\u0631\u0627\u0646.ir",
    "is",
    "net.is",
    "com.is",
    "edu.is",
    "gov.is",
    "org.is",
    "int.is",
    "it",
    "gov.it",
    "edu.it",
    "abr.it",
    "abruzzo.it",
    "aosta-valley.it",
    "aostavalley.it",
    "bas.it",
    "basilicata.it",
    "cal.it",
    "calabria.it",
    "cam.it",
    "campania.it",
    "emilia-romagna.it",
    "emiliaromagna.it",
    "emr.it",
    "friuli-v-giulia.it",
    "friuli-ve-giulia.it",
    "friuli-vegiulia.it",
    "friuli-venezia-giulia.it",
    "friuli-veneziagiulia.it",
    "friuli-vgiulia.it",
    "friuliv-giulia.it",
    "friulive-giulia.it",
    "friulivegiulia.it",
    "friulivenezia-giulia.it",
    "friuliveneziagiulia.it",
    "friulivgiulia.it",
    "fvg.it",
    "laz.it",
    "lazio.it",
    "lig.it",
    "liguria.it",
    "lom.it",
    "lombardia.it",
    "lombardy.it",
    "lucania.it",
    "mar.it",
    "marche.it",
    "mol.it",
    "molise.it",
    "piedmont.it",
    "piemonte.it",
    "pmn.it",
    "pug.it",
    "puglia.it",
    "sar.it",
    "sardegna.it",
    "sardinia.it",
    "sic.it",
    "sicilia.it",
    "sicily.it",
    "taa.it",
    "tos.it",
    "toscana.it",
    "trentin-sud-tirol.it",
    "trentin-s\xFCd-tirol.it",
    "trentin-sudtirol.it",
    "trentin-s\xFCdtirol.it",
    "trentin-sued-tirol.it",
    "trentin-suedtirol.it",
    "trentino-a-adige.it",
    "trentino-aadige.it",
    "trentino-alto-adige.it",
    "trentino-altoadige.it",
    "trentino-s-tirol.it",
    "trentino-stirol.it",
    "trentino-sud-tirol.it",
    "trentino-s\xFCd-tirol.it",
    "trentino-sudtirol.it",
    "trentino-s\xFCdtirol.it",
    "trentino-sued-tirol.it",
    "trentino-suedtirol.it",
    "trentino.it",
    "trentinoa-adige.it",
    "trentinoaadige.it",
    "trentinoalto-adige.it",
    "trentinoaltoadige.it",
    "trentinos-tirol.it",
    "trentinostirol.it",
    "trentinosud-tirol.it",
    "trentinos\xFCd-tirol.it",
    "trentinosudtirol.it",
    "trentinos\xFCdtirol.it",
    "trentinosued-tirol.it",
    "trentinosuedtirol.it",
    "trentinsud-tirol.it",
    "trentins\xFCd-tirol.it",
    "trentinsudtirol.it",
    "trentins\xFCdtirol.it",
    "trentinsued-tirol.it",
    "trentinsuedtirol.it",
    "tuscany.it",
    "umb.it",
    "umbria.it",
    "val-d-aosta.it",
    "val-daosta.it",
    "vald-aosta.it",
    "valdaosta.it",
    "valle-aosta.it",
    "valle-d-aosta.it",
    "valle-daosta.it",
    "valleaosta.it",
    "valled-aosta.it",
    "valledaosta.it",
    "vallee-aoste.it",
    "vall\xE9e-aoste.it",
    "vallee-d-aoste.it",
    "vall\xE9e-d-aoste.it",
    "valleeaoste.it",
    "vall\xE9eaoste.it",
    "valleedaoste.it",
    "vall\xE9edaoste.it",
    "vao.it",
    "vda.it",
    "ven.it",
    "veneto.it",
    "ag.it",
    "agrigento.it",
    "al.it",
    "alessandria.it",
    "alto-adige.it",
    "altoadige.it",
    "an.it",
    "ancona.it",
    "andria-barletta-trani.it",
    "andria-trani-barletta.it",
    "andriabarlettatrani.it",
    "andriatranibarletta.it",
    "ao.it",
    "aosta.it",
    "aoste.it",
    "ap.it",
    "aq.it",
    "aquila.it",
    "ar.it",
    "arezzo.it",
    "ascoli-piceno.it",
    "ascolipiceno.it",
    "asti.it",
    "at.it",
    "av.it",
    "avellino.it",
    "ba.it",
    "balsan-sudtirol.it",
    "balsan-s\xFCdtirol.it",
    "balsan-suedtirol.it",
    "balsan.it",
    "bari.it",
    "barletta-trani-andria.it",
    "barlettatraniandria.it",
    "belluno.it",
    "benevento.it",
    "bergamo.it",
    "bg.it",
    "bi.it",
    "biella.it",
    "bl.it",
    "bn.it",
    "bo.it",
    "bologna.it",
    "bolzano-altoadige.it",
    "bolzano.it",
    "bozen-sudtirol.it",
    "bozen-s\xFCdtirol.it",
    "bozen-suedtirol.it",
    "bozen.it",
    "br.it",
    "brescia.it",
    "brindisi.it",
    "bs.it",
    "bt.it",
    "bulsan-sudtirol.it",
    "bulsan-s\xFCdtirol.it",
    "bulsan-suedtirol.it",
    "bulsan.it",
    "bz.it",
    "ca.it",
    "cagliari.it",
    "caltanissetta.it",
    "campidano-medio.it",
    "campidanomedio.it",
    "campobasso.it",
    "carbonia-iglesias.it",
    "carboniaiglesias.it",
    "carrara-massa.it",
    "carraramassa.it",
    "caserta.it",
    "catania.it",
    "catanzaro.it",
    "cb.it",
    "ce.it",
    "cesena-forli.it",
    "cesena-forl\xEC.it",
    "cesenaforli.it",
    "cesenaforl\xEC.it",
    "ch.it",
    "chieti.it",
    "ci.it",
    "cl.it",
    "cn.it",
    "co.it",
    "como.it",
    "cosenza.it",
    "cr.it",
    "cremona.it",
    "crotone.it",
    "cs.it",
    "ct.it",
    "cuneo.it",
    "cz.it",
    "dell-ogliastra.it",
    "dellogliastra.it",
    "en.it",
    "enna.it",
    "fc.it",
    "fe.it",
    "fermo.it",
    "ferrara.it",
    "fg.it",
    "fi.it",
    "firenze.it",
    "florence.it",
    "fm.it",
    "foggia.it",
    "forli-cesena.it",
    "forl\xEC-cesena.it",
    "forlicesena.it",
    "forl\xECcesena.it",
    "fr.it",
    "frosinone.it",
    "ge.it",
    "genoa.it",
    "genova.it",
    "go.it",
    "gorizia.it",
    "gr.it",
    "grosseto.it",
    "iglesias-carbonia.it",
    "iglesiascarbonia.it",
    "im.it",
    "imperia.it",
    "is.it",
    "isernia.it",
    "kr.it",
    "la-spezia.it",
    "laquila.it",
    "laspezia.it",
    "latina.it",
    "lc.it",
    "le.it",
    "lecce.it",
    "lecco.it",
    "li.it",
    "livorno.it",
    "lo.it",
    "lodi.it",
    "lt.it",
    "lu.it",
    "lucca.it",
    "macerata.it",
    "mantova.it",
    "massa-carrara.it",
    "massacarrara.it",
    "matera.it",
    "mb.it",
    "mc.it",
    "me.it",
    "medio-campidano.it",
    "mediocampidano.it",
    "messina.it",
    "mi.it",
    "milan.it",
    "milano.it",
    "mn.it",
    "mo.it",
    "modena.it",
    "monza-brianza.it",
    "monza-e-della-brianza.it",
    "monza.it",
    "monzabrianza.it",
    "monzaebrianza.it",
    "monzaedellabrianza.it",
    "ms.it",
    "mt.it",
    "na.it",
    "naples.it",
    "napoli.it",
    "no.it",
    "novara.it",
    "nu.it",
    "nuoro.it",
    "og.it",
    "ogliastra.it",
    "olbia-tempio.it",
    "olbiatempio.it",
    "or.it",
    "oristano.it",
    "ot.it",
    "pa.it",
    "padova.it",
    "padua.it",
    "palermo.it",
    "parma.it",
    "pavia.it",
    "pc.it",
    "pd.it",
    "pe.it",
    "perugia.it",
    "pesaro-urbino.it",
    "pesarourbino.it",
    "pescara.it",
    "pg.it",
    "pi.it",
    "piacenza.it",
    "pisa.it",
    "pistoia.it",
    "pn.it",
    "po.it",
    "pordenone.it",
    "potenza.it",
    "pr.it",
    "prato.it",
    "pt.it",
    "pu.it",
    "pv.it",
    "pz.it",
    "ra.it",
    "ragusa.it",
    "ravenna.it",
    "rc.it",
    "re.it",
    "reggio-calabria.it",
    "reggio-emilia.it",
    "reggiocalabria.it",
    "reggioemilia.it",
    "rg.it",
    "ri.it",
    "rieti.it",
    "rimini.it",
    "rm.it",
    "rn.it",
    "ro.it",
    "roma.it",
    "rome.it",
    "rovigo.it",
    "sa.it",
    "salerno.it",
    "sassari.it",
    "savona.it",
    "si.it",
    "siena.it",
    "siracusa.it",
    "so.it",
    "sondrio.it",
    "sp.it",
    "sr.it",
    "ss.it",
    "suedtirol.it",
    "s\xFCdtirol.it",
    "sv.it",
    "ta.it",
    "taranto.it",
    "te.it",
    "tempio-olbia.it",
    "tempioolbia.it",
    "teramo.it",
    "terni.it",
    "tn.it",
    "to.it",
    "torino.it",
    "tp.it",
    "tr.it",
    "trani-andria-barletta.it",
    "trani-barletta-andria.it",
    "traniandriabarletta.it",
    "tranibarlettaandria.it",
    "trapani.it",
    "trento.it",
    "treviso.it",
    "trieste.it",
    "ts.it",
    "turin.it",
    "tv.it",
    "ud.it",
    "udine.it",
    "urbino-pesaro.it",
    "urbinopesaro.it",
    "va.it",
    "varese.it",
    "vb.it",
    "vc.it",
    "ve.it",
    "venezia.it",
    "venice.it",
    "verbania.it",
    "vercelli.it",
    "verona.it",
    "vi.it",
    "vibo-valentia.it",
    "vibovalentia.it",
    "vicenza.it",
    "viterbo.it",
    "vr.it",
    "vs.it",
    "vt.it",
    "vv.it",
    "je",
    "co.je",
    "net.je",
    "org.je",
    "*.jm",
    "jo",
    "com.jo",
    "org.jo",
    "net.jo",
    "edu.jo",
    "sch.jo",
    "gov.jo",
    "mil.jo",
    "name.jo",
    "jobs",
    "jp",
    "ac.jp",
    "ad.jp",
    "co.jp",
    "ed.jp",
    "go.jp",
    "gr.jp",
    "lg.jp",
    "ne.jp",
    "or.jp",
    "aichi.jp",
    "akita.jp",
    "aomori.jp",
    "chiba.jp",
    "ehime.jp",
    "fukui.jp",
    "fukuoka.jp",
    "fukushima.jp",
    "gifu.jp",
    "gunma.jp",
    "hiroshima.jp",
    "hokkaido.jp",
    "hyogo.jp",
    "ibaraki.jp",
    "ishikawa.jp",
    "iwate.jp",
    "kagawa.jp",
    "kagoshima.jp",
    "kanagawa.jp",
    "kochi.jp",
    "kumamoto.jp",
    "kyoto.jp",
    "mie.jp",
    "miyagi.jp",
    "miyazaki.jp",
    "nagano.jp",
    "nagasaki.jp",
    "nara.jp",
    "niigata.jp",
    "oita.jp",
    "okayama.jp",
    "okinawa.jp",
    "osaka.jp",
    "saga.jp",
    "saitama.jp",
    "shiga.jp",
    "shimane.jp",
    "shizuoka.jp",
    "tochigi.jp",
    "tokushima.jp",
    "tokyo.jp",
    "tottori.jp",
    "toyama.jp",
    "wakayama.jp",
    "yamagata.jp",
    "yamaguchi.jp",
    "yamanashi.jp",
    "\u6803\u6728.jp",
    "\u611B\u77E5.jp",
    "\u611B\u5A9B.jp",
    "\u5175\u5EAB.jp",
    "\u718A\u672C.jp",
    "\u8328\u57CE.jp",
    "\u5317\u6D77\u9053.jp",
    "\u5343\u8449.jp",
    "\u548C\u6B4C\u5C71.jp",
    "\u9577\u5D0E.jp",
    "\u9577\u91CE.jp",
    "\u65B0\u6F5F.jp",
    "\u9752\u68EE.jp",
    "\u9759\u5CA1.jp",
    "\u6771\u4EAC.jp",
    "\u77F3\u5DDD.jp",
    "\u57FC\u7389.jp",
    "\u4E09\u91CD.jp",
    "\u4EAC\u90FD.jp",
    "\u4F50\u8CC0.jp",
    "\u5927\u5206.jp",
    "\u5927\u962A.jp",
    "\u5948\u826F.jp",
    "\u5BAE\u57CE.jp",
    "\u5BAE\u5D0E.jp",
    "\u5BCC\u5C71.jp",
    "\u5C71\u53E3.jp",
    "\u5C71\u5F62.jp",
    "\u5C71\u68A8.jp",
    "\u5CA9\u624B.jp",
    "\u5C90\u961C.jp",
    "\u5CA1\u5C71.jp",
    "\u5CF6\u6839.jp",
    "\u5E83\u5CF6.jp",
    "\u5FB3\u5CF6.jp",
    "\u6C96\u7E04.jp",
    "\u6ECB\u8CC0.jp",
    "\u795E\u5948\u5DDD.jp",
    "\u798F\u4E95.jp",
    "\u798F\u5CA1.jp",
    "\u798F\u5CF6.jp",
    "\u79CB\u7530.jp",
    "\u7FA4\u99AC.jp",
    "\u9999\u5DDD.jp",
    "\u9AD8\u77E5.jp",
    "\u9CE5\u53D6.jp",
    "\u9E7F\u5150\u5CF6.jp",
    "*.kawasaki.jp",
    "*.kitakyushu.jp",
    "*.kobe.jp",
    "*.nagoya.jp",
    "*.sapporo.jp",
    "*.sendai.jp",
    "*.yokohama.jp",
    "!city.kawasaki.jp",
    "!city.kitakyushu.jp",
    "!city.kobe.jp",
    "!city.nagoya.jp",
    "!city.sapporo.jp",
    "!city.sendai.jp",
    "!city.yokohama.jp",
    "aisai.aichi.jp",
    "ama.aichi.jp",
    "anjo.aichi.jp",
    "asuke.aichi.jp",
    "chiryu.aichi.jp",
    "chita.aichi.jp",
    "fuso.aichi.jp",
    "gamagori.aichi.jp",
    "handa.aichi.jp",
    "hazu.aichi.jp",
    "hekinan.aichi.jp",
    "higashiura.aichi.jp",
    "ichinomiya.aichi.jp",
    "inazawa.aichi.jp",
    "inuyama.aichi.jp",
    "isshiki.aichi.jp",
    "iwakura.aichi.jp",
    "kanie.aichi.jp",
    "kariya.aichi.jp",
    "kasugai.aichi.jp",
    "kira.aichi.jp",
    "kiyosu.aichi.jp",
    "komaki.aichi.jp",
    "konan.aichi.jp",
    "kota.aichi.jp",
    "mihama.aichi.jp",
    "miyoshi.aichi.jp",
    "nishio.aichi.jp",
    "nisshin.aichi.jp",
    "obu.aichi.jp",
    "oguchi.aichi.jp",
    "oharu.aichi.jp",
    "okazaki.aichi.jp",
    "owariasahi.aichi.jp",
    "seto.aichi.jp",
    "shikatsu.aichi.jp",
    "shinshiro.aichi.jp",
    "shitara.aichi.jp",
    "tahara.aichi.jp",
    "takahama.aichi.jp",
    "tobishima.aichi.jp",
    "toei.aichi.jp",
    "togo.aichi.jp",
    "tokai.aichi.jp",
    "tokoname.aichi.jp",
    "toyoake.aichi.jp",
    "toyohashi.aichi.jp",
    "toyokawa.aichi.jp",
    "toyone.aichi.jp",
    "toyota.aichi.jp",
    "tsushima.aichi.jp",
    "yatomi.aichi.jp",
    "akita.akita.jp",
    "daisen.akita.jp",
    "fujisato.akita.jp",
    "gojome.akita.jp",
    "hachirogata.akita.jp",
    "happou.akita.jp",
    "higashinaruse.akita.jp",
    "honjo.akita.jp",
    "honjyo.akita.jp",
    "ikawa.akita.jp",
    "kamikoani.akita.jp",
    "kamioka.akita.jp",
    "katagami.akita.jp",
    "kazuno.akita.jp",
    "kitaakita.akita.jp",
    "kosaka.akita.jp",
    "kyowa.akita.jp",
    "misato.akita.jp",
    "mitane.akita.jp",
    "moriyoshi.akita.jp",
    "nikaho.akita.jp",
    "noshiro.akita.jp",
    "odate.akita.jp",
    "oga.akita.jp",
    "ogata.akita.jp",
    "semboku.akita.jp",
    "yokote.akita.jp",
    "yurihonjo.akita.jp",
    "aomori.aomori.jp",
    "gonohe.aomori.jp",
    "hachinohe.aomori.jp",
    "hashikami.aomori.jp",
    "hiranai.aomori.jp",
    "hirosaki.aomori.jp",
    "itayanagi.aomori.jp",
    "kuroishi.aomori.jp",
    "misawa.aomori.jp",
    "mutsu.aomori.jp",
    "nakadomari.aomori.jp",
    "noheji.aomori.jp",
    "oirase.aomori.jp",
    "owani.aomori.jp",
    "rokunohe.aomori.jp",
    "sannohe.aomori.jp",
    "shichinohe.aomori.jp",
    "shingo.aomori.jp",
    "takko.aomori.jp",
    "towada.aomori.jp",
    "tsugaru.aomori.jp",
    "tsuruta.aomori.jp",
    "abiko.chiba.jp",
    "asahi.chiba.jp",
    "chonan.chiba.jp",
    "chosei.chiba.jp",
    "choshi.chiba.jp",
    "chuo.chiba.jp",
    "funabashi.chiba.jp",
    "futtsu.chiba.jp",
    "hanamigawa.chiba.jp",
    "ichihara.chiba.jp",
    "ichikawa.chiba.jp",
    "ichinomiya.chiba.jp",
    "inzai.chiba.jp",
    "isumi.chiba.jp",
    "kamagaya.chiba.jp",
    "kamogawa.chiba.jp",
    "kashiwa.chiba.jp",
    "katori.chiba.jp",
    "katsuura.chiba.jp",
    "kimitsu.chiba.jp",
    "kisarazu.chiba.jp",
    "kozaki.chiba.jp",
    "kujukuri.chiba.jp",
    "kyonan.chiba.jp",
    "matsudo.chiba.jp",
    "midori.chiba.jp",
    "mihama.chiba.jp",
    "minamiboso.chiba.jp",
    "mobara.chiba.jp",
    "mutsuzawa.chiba.jp",
    "nagara.chiba.jp",
    "nagareyama.chiba.jp",
    "narashino.chiba.jp",
    "narita.chiba.jp",
    "noda.chiba.jp",
    "oamishirasato.chiba.jp",
    "omigawa.chiba.jp",
    "onjuku.chiba.jp",
    "otaki.chiba.jp",
    "sakae.chiba.jp",
    "sakura.chiba.jp",
    "shimofusa.chiba.jp",
    "shirako.chiba.jp",
    "shiroi.chiba.jp",
    "shisui.chiba.jp",
    "sodegaura.chiba.jp",
    "sosa.chiba.jp",
    "tako.chiba.jp",
    "tateyama.chiba.jp",
    "togane.chiba.jp",
    "tohnosho.chiba.jp",
    "tomisato.chiba.jp",
    "urayasu.chiba.jp",
    "yachimata.chiba.jp",
    "yachiyo.chiba.jp",
    "yokaichiba.chiba.jp",
    "yokoshibahikari.chiba.jp",
    "yotsukaido.chiba.jp",
    "ainan.ehime.jp",
    "honai.ehime.jp",
    "ikata.ehime.jp",
    "imabari.ehime.jp",
    "iyo.ehime.jp",
    "kamijima.ehime.jp",
    "kihoku.ehime.jp",
    "kumakogen.ehime.jp",
    "masaki.ehime.jp",
    "matsuno.ehime.jp",
    "matsuyama.ehime.jp",
    "namikata.ehime.jp",
    "niihama.ehime.jp",
    "ozu.ehime.jp",
    "saijo.ehime.jp",
    "seiyo.ehime.jp",
    "shikokuchuo.ehime.jp",
    "tobe.ehime.jp",
    "toon.ehime.jp",
    "uchiko.ehime.jp",
    "uwajima.ehime.jp",
    "yawatahama.ehime.jp",
    "echizen.fukui.jp",
    "eiheiji.fukui.jp",
    "fukui.fukui.jp",
    "ikeda.fukui.jp",
    "katsuyama.fukui.jp",
    "mihama.fukui.jp",
    "minamiechizen.fukui.jp",
    "obama.fukui.jp",
    "ohi.fukui.jp",
    "ono.fukui.jp",
    "sabae.fukui.jp",
    "sakai.fukui.jp",
    "takahama.fukui.jp",
    "tsuruga.fukui.jp",
    "wakasa.fukui.jp",
    "ashiya.fukuoka.jp",
    "buzen.fukuoka.jp",
    "chikugo.fukuoka.jp",
    "chikuho.fukuoka.jp",
    "chikujo.fukuoka.jp",
    "chikushino.fukuoka.jp",
    "chikuzen.fukuoka.jp",
    "chuo.fukuoka.jp",
    "dazaifu.fukuoka.jp",
    "fukuchi.fukuoka.jp",
    "hakata.fukuoka.jp",
    "higashi.fukuoka.jp",
    "hirokawa.fukuoka.jp",
    "hisayama.fukuoka.jp",
    "iizuka.fukuoka.jp",
    "inatsuki.fukuoka.jp",
    "kaho.fukuoka.jp",
    "kasuga.fukuoka.jp",
    "kasuya.fukuoka.jp",
    "kawara.fukuoka.jp",
    "keisen.fukuoka.jp",
    "koga.fukuoka.jp",
    "kurate.fukuoka.jp",
    "kurogi.fukuoka.jp",
    "kurume.fukuoka.jp",
    "minami.fukuoka.jp",
    "miyako.fukuoka.jp",
    "miyama.fukuoka.jp",
    "miyawaka.fukuoka.jp",
    "mizumaki.fukuoka.jp",
    "munakata.fukuoka.jp",
    "nakagawa.fukuoka.jp",
    "nakama.fukuoka.jp",
    "nishi.fukuoka.jp",
    "nogata.fukuoka.jp",
    "ogori.fukuoka.jp",
    "okagaki.fukuoka.jp",
    "okawa.fukuoka.jp",
    "oki.fukuoka.jp",
    "omuta.fukuoka.jp",
    "onga.fukuoka.jp",
    "onojo.fukuoka.jp",
    "oto.fukuoka.jp",
    "saigawa.fukuoka.jp",
    "sasaguri.fukuoka.jp",
    "shingu.fukuoka.jp",
    "shinyoshitomi.fukuoka.jp",
    "shonai.fukuoka.jp",
    "soeda.fukuoka.jp",
    "sue.fukuoka.jp",
    "tachiarai.fukuoka.jp",
    "tagawa.fukuoka.jp",
    "takata.fukuoka.jp",
    "toho.fukuoka.jp",
    "toyotsu.fukuoka.jp",
    "tsuiki.fukuoka.jp",
    "ukiha.fukuoka.jp",
    "umi.fukuoka.jp",
    "usui.fukuoka.jp",
    "yamada.fukuoka.jp",
    "yame.fukuoka.jp",
    "yanagawa.fukuoka.jp",
    "yukuhashi.fukuoka.jp",
    "aizubange.fukushima.jp",
    "aizumisato.fukushima.jp",
    "aizuwakamatsu.fukushima.jp",
    "asakawa.fukushima.jp",
    "bandai.fukushima.jp",
    "date.fukushima.jp",
    "fukushima.fukushima.jp",
    "furudono.fukushima.jp",
    "futaba.fukushima.jp",
    "hanawa.fukushima.jp",
    "higashi.fukushima.jp",
    "hirata.fukushima.jp",
    "hirono.fukushima.jp",
    "iitate.fukushima.jp",
    "inawashiro.fukushima.jp",
    "ishikawa.fukushima.jp",
    "iwaki.fukushima.jp",
    "izumizaki.fukushima.jp",
    "kagamiishi.fukushima.jp",
    "kaneyama.fukushima.jp",
    "kawamata.fukushima.jp",
    "kitakata.fukushima.jp",
    "kitashiobara.fukushima.jp",
    "koori.fukushima.jp",
    "koriyama.fukushima.jp",
    "kunimi.fukushima.jp",
    "miharu.fukushima.jp",
    "mishima.fukushima.jp",
    "namie.fukushima.jp",
    "nango.fukushima.jp",
    "nishiaizu.fukushima.jp",
    "nishigo.fukushima.jp",
    "okuma.fukushima.jp",
    "omotego.fukushima.jp",
    "ono.fukushima.jp",
    "otama.fukushima.jp",
    "samegawa.fukushima.jp",
    "shimogo.fukushima.jp",
    "shirakawa.fukushima.jp",
    "showa.fukushima.jp",
    "soma.fukushima.jp",
    "sukagawa.fukushima.jp",
    "taishin.fukushima.jp",
    "tamakawa.fukushima.jp",
    "tanagura.fukushima.jp",
    "tenei.fukushima.jp",
    "yabuki.fukushima.jp",
    "yamato.fukushima.jp",
    "yamatsuri.fukushima.jp",
    "yanaizu.fukushima.jp",
    "yugawa.fukushima.jp",
    "anpachi.gifu.jp",
    "ena.gifu.jp",
    "gifu.gifu.jp",
    "ginan.gifu.jp",
    "godo.gifu.jp",
    "gujo.gifu.jp",
    "hashima.gifu.jp",
    "hichiso.gifu.jp",
    "hida.gifu.jp",
    "higashishirakawa.gifu.jp",
    "ibigawa.gifu.jp",
    "ikeda.gifu.jp",
    "kakamigahara.gifu.jp",
    "kani.gifu.jp",
    "kasahara.gifu.jp",
    "kasamatsu.gifu.jp",
    "kawaue.gifu.jp",
    "kitagata.gifu.jp",
    "mino.gifu.jp",
    "minokamo.gifu.jp",
    "mitake.gifu.jp",
    "mizunami.gifu.jp",
    "motosu.gifu.jp",
    "nakatsugawa.gifu.jp",
    "ogaki.gifu.jp",
    "sakahogi.gifu.jp",
    "seki.gifu.jp",
    "sekigahara.gifu.jp",
    "shirakawa.gifu.jp",
    "tajimi.gifu.jp",
    "takayama.gifu.jp",
    "tarui.gifu.jp",
    "toki.gifu.jp",
    "tomika.gifu.jp",
    "wanouchi.gifu.jp",
    "yamagata.gifu.jp",
    "yaotsu.gifu.jp",
    "yoro.gifu.jp",
    "annaka.gunma.jp",
    "chiyoda.gunma.jp",
    "fujioka.gunma.jp",
    "higashiagatsuma.gunma.jp",
    "isesaki.gunma.jp",
    "itakura.gunma.jp",
    "kanna.gunma.jp",
    "kanra.gunma.jp",
    "katashina.gunma.jp",
    "kawaba.gunma.jp",
    "kiryu.gunma.jp",
    "kusatsu.gunma.jp",
    "maebashi.gunma.jp",
    "meiwa.gunma.jp",
    "midori.gunma.jp",
    "minakami.gunma.jp",
    "naganohara.gunma.jp",
    "nakanojo.gunma.jp",
    "nanmoku.gunma.jp",
    "numata.gunma.jp",
    "oizumi.gunma.jp",
    "ora.gunma.jp",
    "ota.gunma.jp",
    "shibukawa.gunma.jp",
    "shimonita.gunma.jp",
    "shinto.gunma.jp",
    "showa.gunma.jp",
    "takasaki.gunma.jp",
    "takayama.gunma.jp",
    "tamamura.gunma.jp",
    "tatebayashi.gunma.jp",
    "tomioka.gunma.jp",
    "tsukiyono.gunma.jp",
    "tsumagoi.gunma.jp",
    "ueno.gunma.jp",
    "yoshioka.gunma.jp",
    "asaminami.hiroshima.jp",
    "daiwa.hiroshima.jp",
    "etajima.hiroshima.jp",
    "fuchu.hiroshima.jp",
    "fukuyama.hiroshima.jp",
    "hatsukaichi.hiroshima.jp",
    "higashihiroshima.hiroshima.jp",
    "hongo.hiroshima.jp",
    "jinsekikogen.hiroshima.jp",
    "kaita.hiroshima.jp",
    "kui.hiroshima.jp",
    "kumano.hiroshima.jp",
    "kure.hiroshima.jp",
    "mihara.hiroshima.jp",
    "miyoshi.hiroshima.jp",
    "naka.hiroshima.jp",
    "onomichi.hiroshima.jp",
    "osakikamijima.hiroshima.jp",
    "otake.hiroshima.jp",
    "saka.hiroshima.jp",
    "sera.hiroshima.jp",
    "seranishi.hiroshima.jp",
    "shinichi.hiroshima.jp",
    "shobara.hiroshima.jp",
    "takehara.hiroshima.jp",
    "abashiri.hokkaido.jp",
    "abira.hokkaido.jp",
    "aibetsu.hokkaido.jp",
    "akabira.hokkaido.jp",
    "akkeshi.hokkaido.jp",
    "asahikawa.hokkaido.jp",
    "ashibetsu.hokkaido.jp",
    "ashoro.hokkaido.jp",
    "assabu.hokkaido.jp",
    "atsuma.hokkaido.jp",
    "bibai.hokkaido.jp",
    "biei.hokkaido.jp",
    "bifuka.hokkaido.jp",
    "bihoro.hokkaido.jp",
    "biratori.hokkaido.jp",
    "chippubetsu.hokkaido.jp",
    "chitose.hokkaido.jp",
    "date.hokkaido.jp",
    "ebetsu.hokkaido.jp",
    "embetsu.hokkaido.jp",
    "eniwa.hokkaido.jp",
    "erimo.hokkaido.jp",
    "esan.hokkaido.jp",
    "esashi.hokkaido.jp",
    "fukagawa.hokkaido.jp",
    "fukushima.hokkaido.jp",
    "furano.hokkaido.jp",
    "furubira.hokkaido.jp",
    "haboro.hokkaido.jp",
    "hakodate.hokkaido.jp",
    "hamatonbetsu.hokkaido.jp",
    "hidaka.hokkaido.jp",
    "higashikagura.hokkaido.jp",
    "higashikawa.hokkaido.jp",
    "hiroo.hokkaido.jp",
    "hokuryu.hokkaido.jp",
    "hokuto.hokkaido.jp",
    "honbetsu.hokkaido.jp",
    "horokanai.hokkaido.jp",
    "horonobe.hokkaido.jp",
    "ikeda.hokkaido.jp",
    "imakane.hokkaido.jp",
    "ishikari.hokkaido.jp",
    "iwamizawa.hokkaido.jp",
    "iwanai.hokkaido.jp",
    "kamifurano.hokkaido.jp",
    "kamikawa.hokkaido.jp",
    "kamishihoro.hokkaido.jp",
    "kamisunagawa.hokkaido.jp",
    "kamoenai.hokkaido.jp",
    "kayabe.hokkaido.jp",
    "kembuchi.hokkaido.jp",
    "kikonai.hokkaido.jp",
    "kimobetsu.hokkaido.jp",
    "kitahiroshima.hokkaido.jp",
    "kitami.hokkaido.jp",
    "kiyosato.hokkaido.jp",
    "koshimizu.hokkaido.jp",
    "kunneppu.hokkaido.jp",
    "kuriyama.hokkaido.jp",
    "kuromatsunai.hokkaido.jp",
    "kushiro.hokkaido.jp",
    "kutchan.hokkaido.jp",
    "kyowa.hokkaido.jp",
    "mashike.hokkaido.jp",
    "matsumae.hokkaido.jp",
    "mikasa.hokkaido.jp",
    "minamifurano.hokkaido.jp",
    "mombetsu.hokkaido.jp",
    "moseushi.hokkaido.jp",
    "mukawa.hokkaido.jp",
    "muroran.hokkaido.jp",
    "naie.hokkaido.jp",
    "nakagawa.hokkaido.jp",
    "nakasatsunai.hokkaido.jp",
    "nakatombetsu.hokkaido.jp",
    "nanae.hokkaido.jp",
    "nanporo.hokkaido.jp",
    "nayoro.hokkaido.jp",
    "nemuro.hokkaido.jp",
    "niikappu.hokkaido.jp",
    "niki.hokkaido.jp",
    "nishiokoppe.hokkaido.jp",
    "noboribetsu.hokkaido.jp",
    "numata.hokkaido.jp",
    "obihiro.hokkaido.jp",
    "obira.hokkaido.jp",
    "oketo.hokkaido.jp",
    "okoppe.hokkaido.jp",
    "otaru.hokkaido.jp",
    "otobe.hokkaido.jp",
    "otofuke.hokkaido.jp",
    "otoineppu.hokkaido.jp",
    "oumu.hokkaido.jp",
    "ozora.hokkaido.jp",
    "pippu.hokkaido.jp",
    "rankoshi.hokkaido.jp",
    "rebun.hokkaido.jp",
    "rikubetsu.hokkaido.jp",
    "rishiri.hokkaido.jp",
    "rishirifuji.hokkaido.jp",
    "saroma.hokkaido.jp",
    "sarufutsu.hokkaido.jp",
    "shakotan.hokkaido.jp",
    "shari.hokkaido.jp",
    "shibecha.hokkaido.jp",
    "shibetsu.hokkaido.jp",
    "shikabe.hokkaido.jp",
    "shikaoi.hokkaido.jp",
    "shimamaki.hokkaido.jp",
    "shimizu.hokkaido.jp",
    "shimokawa.hokkaido.jp",
    "shinshinotsu.hokkaido.jp",
    "shintoku.hokkaido.jp",
    "shiranuka.hokkaido.jp",
    "shiraoi.hokkaido.jp",
    "shiriuchi.hokkaido.jp",
    "sobetsu.hokkaido.jp",
    "sunagawa.hokkaido.jp",
    "taiki.hokkaido.jp",
    "takasu.hokkaido.jp",
    "takikawa.hokkaido.jp",
    "takinoue.hokkaido.jp",
    "teshikaga.hokkaido.jp",
    "tobetsu.hokkaido.jp",
    "tohma.hokkaido.jp",
    "tomakomai.hokkaido.jp",
    "tomari.hokkaido.jp",
    "toya.hokkaido.jp",
    "toyako.hokkaido.jp",
    "toyotomi.hokkaido.jp",
    "toyoura.hokkaido.jp",
    "tsubetsu.hokkaido.jp",
    "tsukigata.hokkaido.jp",
    "urakawa.hokkaido.jp",
    "urausu.hokkaido.jp",
    "uryu.hokkaido.jp",
    "utashinai.hokkaido.jp",
    "wakkanai.hokkaido.jp",
    "wassamu.hokkaido.jp",
    "yakumo.hokkaido.jp",
    "yoichi.hokkaido.jp",
    "aioi.hyogo.jp",
    "akashi.hyogo.jp",
    "ako.hyogo.jp",
    "amagasaki.hyogo.jp",
    "aogaki.hyogo.jp",
    "asago.hyogo.jp",
    "ashiya.hyogo.jp",
    "awaji.hyogo.jp",
    "fukusaki.hyogo.jp",
    "goshiki.hyogo.jp",
    "harima.hyogo.jp",
    "himeji.hyogo.jp",
    "ichikawa.hyogo.jp",
    "inagawa.hyogo.jp",
    "itami.hyogo.jp",
    "kakogawa.hyogo.jp",
    "kamigori.hyogo.jp",
    "kamikawa.hyogo.jp",
    "kasai.hyogo.jp",
    "kasuga.hyogo.jp",
    "kawanishi.hyogo.jp",
    "miki.hyogo.jp",
    "minamiawaji.hyogo.jp",
    "nishinomiya.hyogo.jp",
    "nishiwaki.hyogo.jp",
    "ono.hyogo.jp",
    "sanda.hyogo.jp",
    "sannan.hyogo.jp",
    "sasayama.hyogo.jp",
    "sayo.hyogo.jp",
    "shingu.hyogo.jp",
    "shinonsen.hyogo.jp",
    "shiso.hyogo.jp",
    "sumoto.hyogo.jp",
    "taishi.hyogo.jp",
    "taka.hyogo.jp",
    "takarazuka.hyogo.jp",
    "takasago.hyogo.jp",
    "takino.hyogo.jp",
    "tamba.hyogo.jp",
    "tatsuno.hyogo.jp",
    "toyooka.hyogo.jp",
    "yabu.hyogo.jp",
    "yashiro.hyogo.jp",
    "yoka.hyogo.jp",
    "yokawa.hyogo.jp",
    "ami.ibaraki.jp",
    "asahi.ibaraki.jp",
    "bando.ibaraki.jp",
    "chikusei.ibaraki.jp",
    "daigo.ibaraki.jp",
    "fujishiro.ibaraki.jp",
    "hitachi.ibaraki.jp",
    "hitachinaka.ibaraki.jp",
    "hitachiomiya.ibaraki.jp",
    "hitachiota.ibaraki.jp",
    "ibaraki.ibaraki.jp",
    "ina.ibaraki.jp",
    "inashiki.ibaraki.jp",
    "itako.ibaraki.jp",
    "iwama.ibaraki.jp",
    "joso.ibaraki.jp",
    "kamisu.ibaraki.jp",
    "kasama.ibaraki.jp",
    "kashima.ibaraki.jp",
    "kasumigaura.ibaraki.jp",
    "koga.ibaraki.jp",
    "miho.ibaraki.jp",
    "mito.ibaraki.jp",
    "moriya.ibaraki.jp",
    "naka.ibaraki.jp",
    "namegata.ibaraki.jp",
    "oarai.ibaraki.jp",
    "ogawa.ibaraki.jp",
    "omitama.ibaraki.jp",
    "ryugasaki.ibaraki.jp",
    "sakai.ibaraki.jp",
    "sakuragawa.ibaraki.jp",
    "shimodate.ibaraki.jp",
    "shimotsuma.ibaraki.jp",
    "shirosato.ibaraki.jp",
    "sowa.ibaraki.jp",
    "suifu.ibaraki.jp",
    "takahagi.ibaraki.jp",
    "tamatsukuri.ibaraki.jp",
    "tokai.ibaraki.jp",
    "tomobe.ibaraki.jp",
    "tone.ibaraki.jp",
    "toride.ibaraki.jp",
    "tsuchiura.ibaraki.jp",
    "tsukuba.ibaraki.jp",
    "uchihara.ibaraki.jp",
    "ushiku.ibaraki.jp",
    "yachiyo.ibaraki.jp",
    "yamagata.ibaraki.jp",
    "yawara.ibaraki.jp",
    "yuki.ibaraki.jp",
    "anamizu.ishikawa.jp",
    "hakui.ishikawa.jp",
    "hakusan.ishikawa.jp",
    "kaga.ishikawa.jp",
    "kahoku.ishikawa.jp",
    "kanazawa.ishikawa.jp",
    "kawakita.ishikawa.jp",
    "komatsu.ishikawa.jp",
    "nakanoto.ishikawa.jp",
    "nanao.ishikawa.jp",
    "nomi.ishikawa.jp",
    "nonoichi.ishikawa.jp",
    "noto.ishikawa.jp",
    "shika.ishikawa.jp",
    "suzu.ishikawa.jp",
    "tsubata.ishikawa.jp",
    "tsurugi.ishikawa.jp",
    "uchinada.ishikawa.jp",
    "wajima.ishikawa.jp",
    "fudai.iwate.jp",
    "fujisawa.iwate.jp",
    "hanamaki.iwate.jp",
    "hiraizumi.iwate.jp",
    "hirono.iwate.jp",
    "ichinohe.iwate.jp",
    "ichinoseki.iwate.jp",
    "iwaizumi.iwate.jp",
    "iwate.iwate.jp",
    "joboji.iwate.jp",
    "kamaishi.iwate.jp",
    "kanegasaki.iwate.jp",
    "karumai.iwate.jp",
    "kawai.iwate.jp",
    "kitakami.iwate.jp",
    "kuji.iwate.jp",
    "kunohe.iwate.jp",
    "kuzumaki.iwate.jp",
    "miyako.iwate.jp",
    "mizusawa.iwate.jp",
    "morioka.iwate.jp",
    "ninohe.iwate.jp",
    "noda.iwate.jp",
    "ofunato.iwate.jp",
    "oshu.iwate.jp",
    "otsuchi.iwate.jp",
    "rikuzentakata.iwate.jp",
    "shiwa.iwate.jp",
    "shizukuishi.iwate.jp",
    "sumita.iwate.jp",
    "tanohata.iwate.jp",
    "tono.iwate.jp",
    "yahaba.iwate.jp",
    "yamada.iwate.jp",
    "ayagawa.kagawa.jp",
    "higashikagawa.kagawa.jp",
    "kanonji.kagawa.jp",
    "kotohira.kagawa.jp",
    "manno.kagawa.jp",
    "marugame.kagawa.jp",
    "mitoyo.kagawa.jp",
    "naoshima.kagawa.jp",
    "sanuki.kagawa.jp",
    "tadotsu.kagawa.jp",
    "takamatsu.kagawa.jp",
    "tonosho.kagawa.jp",
    "uchinomi.kagawa.jp",
    "utazu.kagawa.jp",
    "zentsuji.kagawa.jp",
    "akune.kagoshima.jp",
    "amami.kagoshima.jp",
    "hioki.kagoshima.jp",
    "isa.kagoshima.jp",
    "isen.kagoshima.jp",
    "izumi.kagoshima.jp",
    "kagoshima.kagoshima.jp",
    "kanoya.kagoshima.jp",
    "kawanabe.kagoshima.jp",
    "kinko.kagoshima.jp",
    "kouyama.kagoshima.jp",
    "makurazaki.kagoshima.jp",
    "matsumoto.kagoshima.jp",
    "minamitane.kagoshima.jp",
    "nakatane.kagoshima.jp",
    "nishinoomote.kagoshima.jp",
    "satsumasendai.kagoshima.jp",
    "soo.kagoshima.jp",
    "tarumizu.kagoshima.jp",
    "yusui.kagoshima.jp",
    "aikawa.kanagawa.jp",
    "atsugi.kanagawa.jp",
    "ayase.kanagawa.jp",
    "chigasaki.kanagawa.jp",
    "ebina.kanagawa.jp",
    "fujisawa.kanagawa.jp",
    "hadano.kanagawa.jp",
    "hakone.kanagawa.jp",
    "hiratsuka.kanagawa.jp",
    "isehara.kanagawa.jp",
    "kaisei.kanagawa.jp",
    "kamakura.kanagawa.jp",
    "kiyokawa.kanagawa.jp",
    "matsuda.kanagawa.jp",
    "minamiashigara.kanagawa.jp",
    "miura.kanagawa.jp",
    "nakai.kanagawa.jp",
    "ninomiya.kanagawa.jp",
    "odawara.kanagawa.jp",
    "oi.kanagawa.jp",
    "oiso.kanagawa.jp",
    "sagamihara.kanagawa.jp",
    "samukawa.kanagawa.jp",
    "tsukui.kanagawa.jp",
    "yamakita.kanagawa.jp",
    "yamato.kanagawa.jp",
    "yokosuka.kanagawa.jp",
    "yugawara.kanagawa.jp",
    "zama.kanagawa.jp",
    "zushi.kanagawa.jp",
    "aki.kochi.jp",
    "geisei.kochi.jp",
    "hidaka.kochi.jp",
    "higashitsuno.kochi.jp",
    "ino.kochi.jp",
    "kagami.kochi.jp",
    "kami.kochi.jp",
    "kitagawa.kochi.jp",
    "kochi.kochi.jp",
    "mihara.kochi.jp",
    "motoyama.kochi.jp",
    "muroto.kochi.jp",
    "nahari.kochi.jp",
    "nakamura.kochi.jp",
    "nankoku.kochi.jp",
    "nishitosa.kochi.jp",
    "niyodogawa.kochi.jp",
    "ochi.kochi.jp",
    "okawa.kochi.jp",
    "otoyo.kochi.jp",
    "otsuki.kochi.jp",
    "sakawa.kochi.jp",
    "sukumo.kochi.jp",
    "susaki.kochi.jp",
    "tosa.kochi.jp",
    "tosashimizu.kochi.jp",
    "toyo.kochi.jp",
    "tsuno.kochi.jp",
    "umaji.kochi.jp",
    "yasuda.kochi.jp",
    "yusuhara.kochi.jp",
    "amakusa.kumamoto.jp",
    "arao.kumamoto.jp",
    "aso.kumamoto.jp",
    "choyo.kumamoto.jp",
    "gyokuto.kumamoto.jp",
    "kamiamakusa.kumamoto.jp",
    "kikuchi.kumamoto.jp",
    "kumamoto.kumamoto.jp",
    "mashiki.kumamoto.jp",
    "mifune.kumamoto.jp",
    "minamata.kumamoto.jp",
    "minamioguni.kumamoto.jp",
    "nagasu.kumamoto.jp",
    "nishihara.kumamoto.jp",
    "oguni.kumamoto.jp",
    "ozu.kumamoto.jp",
    "sumoto.kumamoto.jp",
    "takamori.kumamoto.jp",
    "uki.kumamoto.jp",
    "uto.kumamoto.jp",
    "yamaga.kumamoto.jp",
    "yamato.kumamoto.jp",
    "yatsushiro.kumamoto.jp",
    "ayabe.kyoto.jp",
    "fukuchiyama.kyoto.jp",
    "higashiyama.kyoto.jp",
    "ide.kyoto.jp",
    "ine.kyoto.jp",
    "joyo.kyoto.jp",
    "kameoka.kyoto.jp",
    "kamo.kyoto.jp",
    "kita.kyoto.jp",
    "kizu.kyoto.jp",
    "kumiyama.kyoto.jp",
    "kyotamba.kyoto.jp",
    "kyotanabe.kyoto.jp",
    "kyotango.kyoto.jp",
    "maizuru.kyoto.jp",
    "minami.kyoto.jp",
    "minamiyamashiro.kyoto.jp",
    "miyazu.kyoto.jp",
    "muko.kyoto.jp",
    "nagaokakyo.kyoto.jp",
    "nakagyo.kyoto.jp",
    "nantan.kyoto.jp",
    "oyamazaki.kyoto.jp",
    "sakyo.kyoto.jp",
    "seika.kyoto.jp",
    "tanabe.kyoto.jp",
    "uji.kyoto.jp",
    "ujitawara.kyoto.jp",
    "wazuka.kyoto.jp",
    "yamashina.kyoto.jp",
    "yawata.kyoto.jp",
    "asahi.mie.jp",
    "inabe.mie.jp",
    "ise.mie.jp",
    "kameyama.mie.jp",
    "kawagoe.mie.jp",
    "kiho.mie.jp",
    "kisosaki.mie.jp",
    "kiwa.mie.jp",
    "komono.mie.jp",
    "kumano.mie.jp",
    "kuwana.mie.jp",
    "matsusaka.mie.jp",
    "meiwa.mie.jp",
    "mihama.mie.jp",
    "minamiise.mie.jp",
    "misugi.mie.jp",
    "miyama.mie.jp",
    "nabari.mie.jp",
    "shima.mie.jp",
    "suzuka.mie.jp",
    "tado.mie.jp",
    "taiki.mie.jp",
    "taki.mie.jp",
    "tamaki.mie.jp",
    "toba.mie.jp",
    "tsu.mie.jp",
    "udono.mie.jp",
    "ureshino.mie.jp",
    "watarai.mie.jp",
    "yokkaichi.mie.jp",
    "furukawa.miyagi.jp",
    "higashimatsushima.miyagi.jp",
    "ishinomaki.miyagi.jp",
    "iwanuma.miyagi.jp",
    "kakuda.miyagi.jp",
    "kami.miyagi.jp",
    "kawasaki.miyagi.jp",
    "marumori.miyagi.jp",
    "matsushima.miyagi.jp",
    "minamisanriku.miyagi.jp",
    "misato.miyagi.jp",
    "murata.miyagi.jp",
    "natori.miyagi.jp",
    "ogawara.miyagi.jp",
    "ohira.miyagi.jp",
    "onagawa.miyagi.jp",
    "osaki.miyagi.jp",
    "rifu.miyagi.jp",
    "semine.miyagi.jp",
    "shibata.miyagi.jp",
    "shichikashuku.miyagi.jp",
    "shikama.miyagi.jp",
    "shiogama.miyagi.jp",
    "shiroishi.miyagi.jp",
    "tagajo.miyagi.jp",
    "taiwa.miyagi.jp",
    "tome.miyagi.jp",
    "tomiya.miyagi.jp",
    "wakuya.miyagi.jp",
    "watari.miyagi.jp",
    "yamamoto.miyagi.jp",
    "zao.miyagi.jp",
    "aya.miyazaki.jp",
    "ebino.miyazaki.jp",
    "gokase.miyazaki.jp",
    "hyuga.miyazaki.jp",
    "kadogawa.miyazaki.jp",
    "kawaminami.miyazaki.jp",
    "kijo.miyazaki.jp",
    "kitagawa.miyazaki.jp",
    "kitakata.miyazaki.jp",
    "kitaura.miyazaki.jp",
    "kobayashi.miyazaki.jp",
    "kunitomi.miyazaki.jp",
    "kushima.miyazaki.jp",
    "mimata.miyazaki.jp",
    "miyakonojo.miyazaki.jp",
    "miyazaki.miyazaki.jp",
    "morotsuka.miyazaki.jp",
    "nichinan.miyazaki.jp",
    "nishimera.miyazaki.jp",
    "nobeoka.miyazaki.jp",
    "saito.miyazaki.jp",
    "shiiba.miyazaki.jp",
    "shintomi.miyazaki.jp",
    "takaharu.miyazaki.jp",
    "takanabe.miyazaki.jp",
    "takazaki.miyazaki.jp",
    "tsuno.miyazaki.jp",
    "achi.nagano.jp",
    "agematsu.nagano.jp",
    "anan.nagano.jp",
    "aoki.nagano.jp",
    "asahi.nagano.jp",
    "azumino.nagano.jp",
    "chikuhoku.nagano.jp",
    "chikuma.nagano.jp",
    "chino.nagano.jp",
    "fujimi.nagano.jp",
    "hakuba.nagano.jp",
    "hara.nagano.jp",
    "hiraya.nagano.jp",
    "iida.nagano.jp",
    "iijima.nagano.jp",
    "iiyama.nagano.jp",
    "iizuna.nagano.jp",
    "ikeda.nagano.jp",
    "ikusaka.nagano.jp",
    "ina.nagano.jp",
    "karuizawa.nagano.jp",
    "kawakami.nagano.jp",
    "kiso.nagano.jp",
    "kisofukushima.nagano.jp",
    "kitaaiki.nagano.jp",
    "komagane.nagano.jp",
    "komoro.nagano.jp",
    "matsukawa.nagano.jp",
    "matsumoto.nagano.jp",
    "miasa.nagano.jp",
    "minamiaiki.nagano.jp",
    "minamimaki.nagano.jp",
    "minamiminowa.nagano.jp",
    "minowa.nagano.jp",
    "miyada.nagano.jp",
    "miyota.nagano.jp",
    "mochizuki.nagano.jp",
    "nagano.nagano.jp",
    "nagawa.nagano.jp",
    "nagiso.nagano.jp",
    "nakagawa.nagano.jp",
    "nakano.nagano.jp",
    "nozawaonsen.nagano.jp",
    "obuse.nagano.jp",
    "ogawa.nagano.jp",
    "okaya.nagano.jp",
    "omachi.nagano.jp",
    "omi.nagano.jp",
    "ookuwa.nagano.jp",
    "ooshika.nagano.jp",
    "otaki.nagano.jp",
    "otari.nagano.jp",
    "sakae.nagano.jp",
    "sakaki.nagano.jp",
    "saku.nagano.jp",
    "sakuho.nagano.jp",
    "shimosuwa.nagano.jp",
    "shinanomachi.nagano.jp",
    "shiojiri.nagano.jp",
    "suwa.nagano.jp",
    "suzaka.nagano.jp",
    "takagi.nagano.jp",
    "takamori.nagano.jp",
    "takayama.nagano.jp",
    "tateshina.nagano.jp",
    "tatsuno.nagano.jp",
    "togakushi.nagano.jp",
    "togura.nagano.jp",
    "tomi.nagano.jp",
    "ueda.nagano.jp",
    "wada.nagano.jp",
    "yamagata.nagano.jp",
    "yamanouchi.nagano.jp",
    "yasaka.nagano.jp",
    "yasuoka.nagano.jp",
    "chijiwa.nagasaki.jp",
    "futsu.nagasaki.jp",
    "goto.nagasaki.jp",
    "hasami.nagasaki.jp",
    "hirado.nagasaki.jp",
    "iki.nagasaki.jp",
    "isahaya.nagasaki.jp",
    "kawatana.nagasaki.jp",
    "kuchinotsu.nagasaki.jp",
    "matsuura.nagasaki.jp",
    "nagasaki.nagasaki.jp",
    "obama.nagasaki.jp",
    "omura.nagasaki.jp",
    "oseto.nagasaki.jp",
    "saikai.nagasaki.jp",
    "sasebo.nagasaki.jp",
    "seihi.nagasaki.jp",
    "shimabara.nagasaki.jp",
    "shinkamigoto.nagasaki.jp",
    "togitsu.nagasaki.jp",
    "tsushima.nagasaki.jp",
    "unzen.nagasaki.jp",
    "ando.nara.jp",
    "gose.nara.jp",
    "heguri.nara.jp",
    "higashiyoshino.nara.jp",
    "ikaruga.nara.jp",
    "ikoma.nara.jp",
    "kamikitayama.nara.jp",
    "kanmaki.nara.jp",
    "kashiba.nara.jp",
    "kashihara.nara.jp",
    "katsuragi.nara.jp",
    "kawai.nara.jp",
    "kawakami.nara.jp",
    "kawanishi.nara.jp",
    "koryo.nara.jp",
    "kurotaki.nara.jp",
    "mitsue.nara.jp",
    "miyake.nara.jp",
    "nara.nara.jp",
    "nosegawa.nara.jp",
    "oji.nara.jp",
    "ouda.nara.jp",
    "oyodo.nara.jp",
    "sakurai.nara.jp",
    "sango.nara.jp",
    "shimoichi.nara.jp",
    "shimokitayama.nara.jp",
    "shinjo.nara.jp",
    "soni.nara.jp",
    "takatori.nara.jp",
    "tawaramoto.nara.jp",
    "tenkawa.nara.jp",
    "tenri.nara.jp",
    "uda.nara.jp",
    "yamatokoriyama.nara.jp",
    "yamatotakada.nara.jp",
    "yamazoe.nara.jp",
    "yoshino.nara.jp",
    "aga.niigata.jp",
    "agano.niigata.jp",
    "gosen.niigata.jp",
    "itoigawa.niigata.jp",
    "izumozaki.niigata.jp",
    "joetsu.niigata.jp",
    "kamo.niigata.jp",
    "kariwa.niigata.jp",
    "kashiwazaki.niigata.jp",
    "minamiuonuma.niigata.jp",
    "mitsuke.niigata.jp",
    "muika.niigata.jp",
    "murakami.niigata.jp",
    "myoko.niigata.jp",
    "nagaoka.niigata.jp",
    "niigata.niigata.jp",
    "ojiya.niigata.jp",
    "omi.niigata.jp",
    "sado.niigata.jp",
    "sanjo.niigata.jp",
    "seiro.niigata.jp",
    "seirou.niigata.jp",
    "sekikawa.niigata.jp",
    "shibata.niigata.jp",
    "tagami.niigata.jp",
    "tainai.niigata.jp",
    "tochio.niigata.jp",
    "tokamachi.niigata.jp",
    "tsubame.niigata.jp",
    "tsunan.niigata.jp",
    "uonuma.niigata.jp",
    "yahiko.niigata.jp",
    "yoita.niigata.jp",
    "yuzawa.niigata.jp",
    "beppu.oita.jp",
    "bungoono.oita.jp",
    "bungotakada.oita.jp",
    "hasama.oita.jp",
    "hiji.oita.jp",
    "himeshima.oita.jp",
    "hita.oita.jp",
    "kamitsue.oita.jp",
    "kokonoe.oita.jp",
    "kuju.oita.jp",
    "kunisaki.oita.jp",
    "kusu.oita.jp",
    "oita.oita.jp",
    "saiki.oita.jp",
    "taketa.oita.jp",
    "tsukumi.oita.jp",
    "usa.oita.jp",
    "usuki.oita.jp",
    "yufu.oita.jp",
    "akaiwa.okayama.jp",
    "asakuchi.okayama.jp",
    "bizen.okayama.jp",
    "hayashima.okayama.jp",
    "ibara.okayama.jp",
    "kagamino.okayama.jp",
    "kasaoka.okayama.jp",
    "kibichuo.okayama.jp",
    "kumenan.okayama.jp",
    "kurashiki.okayama.jp",
    "maniwa.okayama.jp",
    "misaki.okayama.jp",
    "nagi.okayama.jp",
    "niimi.okayama.jp",
    "nishiawakura.okayama.jp",
    "okayama.okayama.jp",
    "satosho.okayama.jp",
    "setouchi.okayama.jp",
    "shinjo.okayama.jp",
    "shoo.okayama.jp",
    "soja.okayama.jp",
    "takahashi.okayama.jp",
    "tamano.okayama.jp",
    "tsuyama.okayama.jp",
    "wake.okayama.jp",
    "yakage.okayama.jp",
    "aguni.okinawa.jp",
    "ginowan.okinawa.jp",
    "ginoza.okinawa.jp",
    "gushikami.okinawa.jp",
    "haebaru.okinawa.jp",
    "higashi.okinawa.jp",
    "hirara.okinawa.jp",
    "iheya.okinawa.jp",
    "ishigaki.okinawa.jp",
    "ishikawa.okinawa.jp",
    "itoman.okinawa.jp",
    "izena.okinawa.jp",
    "kadena.okinawa.jp",
    "kin.okinawa.jp",
    "kitadaito.okinawa.jp",
    "kitanakagusuku.okinawa.jp",
    "kumejima.okinawa.jp",
    "kunigami.okinawa.jp",
    "minamidaito.okinawa.jp",
    "motobu.okinawa.jp",
    "nago.okinawa.jp",
    "naha.okinawa.jp",
    "nakagusuku.okinawa.jp",
    "nakijin.okinawa.jp",
    "nanjo.okinawa.jp",
    "nishihara.okinawa.jp",
    "ogimi.okinawa.jp",
    "okinawa.okinawa.jp",
    "onna.okinawa.jp",
    "shimoji.okinawa.jp",
    "taketomi.okinawa.jp",
    "tarama.okinawa.jp",
    "tokashiki.okinawa.jp",
    "tomigusuku.okinawa.jp",
    "tonaki.okinawa.jp",
    "urasoe.okinawa.jp",
    "uruma.okinawa.jp",
    "yaese.okinawa.jp",
    "yomitan.okinawa.jp",
    "yonabaru.okinawa.jp",
    "yonaguni.okinawa.jp",
    "zamami.okinawa.jp",
    "abeno.osaka.jp",
    "chihayaakasaka.osaka.jp",
    "chuo.osaka.jp",
    "daito.osaka.jp",
    "fujiidera.osaka.jp",
    "habikino.osaka.jp",
    "hannan.osaka.jp",
    "higashiosaka.osaka.jp",
    "higashisumiyoshi.osaka.jp",
    "higashiyodogawa.osaka.jp",
    "hirakata.osaka.jp",
    "ibaraki.osaka.jp",
    "ikeda.osaka.jp",
    "izumi.osaka.jp",
    "izumiotsu.osaka.jp",
    "izumisano.osaka.jp",
    "kadoma.osaka.jp",
    "kaizuka.osaka.jp",
    "kanan.osaka.jp",
    "kashiwara.osaka.jp",
    "katano.osaka.jp",
    "kawachinagano.osaka.jp",
    "kishiwada.osaka.jp",
    "kita.osaka.jp",
    "kumatori.osaka.jp",
    "matsubara.osaka.jp",
    "minato.osaka.jp",
    "minoh.osaka.jp",
    "misaki.osaka.jp",
    "moriguchi.osaka.jp",
    "neyagawa.osaka.jp",
    "nishi.osaka.jp",
    "nose.osaka.jp",
    "osakasayama.osaka.jp",
    "sakai.osaka.jp",
    "sayama.osaka.jp",
    "sennan.osaka.jp",
    "settsu.osaka.jp",
    "shijonawate.osaka.jp",
    "shimamoto.osaka.jp",
    "suita.osaka.jp",
    "tadaoka.osaka.jp",
    "taishi.osaka.jp",
    "tajiri.osaka.jp",
    "takaishi.osaka.jp",
    "takatsuki.osaka.jp",
    "tondabayashi.osaka.jp",
    "toyonaka.osaka.jp",
    "toyono.osaka.jp",
    "yao.osaka.jp",
    "ariake.saga.jp",
    "arita.saga.jp",
    "fukudomi.saga.jp",
    "genkai.saga.jp",
    "hamatama.saga.jp",
    "hizen.saga.jp",
    "imari.saga.jp",
    "kamimine.saga.jp",
    "kanzaki.saga.jp",
    "karatsu.saga.jp",
    "kashima.saga.jp",
    "kitagata.saga.jp",
    "kitahata.saga.jp",
    "kiyama.saga.jp",
    "kouhoku.saga.jp",
    "kyuragi.saga.jp",
    "nishiarita.saga.jp",
    "ogi.saga.jp",
    "omachi.saga.jp",
    "ouchi.saga.jp",
    "saga.saga.jp",
    "shiroishi.saga.jp",
    "taku.saga.jp",
    "tara.saga.jp",
    "tosu.saga.jp",
    "yoshinogari.saga.jp",
    "arakawa.saitama.jp",
    "asaka.saitama.jp",
    "chichibu.saitama.jp",
    "fujimi.saitama.jp",
    "fujimino.saitama.jp",
    "fukaya.saitama.jp",
    "hanno.saitama.jp",
    "hanyu.saitama.jp",
    "hasuda.saitama.jp",
    "hatogaya.saitama.jp",
    "hatoyama.saitama.jp",
    "hidaka.saitama.jp",
    "higashichichibu.saitama.jp",
    "higashimatsuyama.saitama.jp",
    "honjo.saitama.jp",
    "ina.saitama.jp",
    "iruma.saitama.jp",
    "iwatsuki.saitama.jp",
    "kamiizumi.saitama.jp",
    "kamikawa.saitama.jp",
    "kamisato.saitama.jp",
    "kasukabe.saitama.jp",
    "kawagoe.saitama.jp",
    "kawaguchi.saitama.jp",
    "kawajima.saitama.jp",
    "kazo.saitama.jp",
    "kitamoto.saitama.jp",
    "koshigaya.saitama.jp",
    "kounosu.saitama.jp",
    "kuki.saitama.jp",
    "kumagaya.saitama.jp",
    "matsubushi.saitama.jp",
    "minano.saitama.jp",
    "misato.saitama.jp",
    "miyashiro.saitama.jp",
    "miyoshi.saitama.jp",
    "moroyama.saitama.jp",
    "nagatoro.saitama.jp",
    "namegawa.saitama.jp",
    "niiza.saitama.jp",
    "ogano.saitama.jp",
    "ogawa.saitama.jp",
    "ogose.saitama.jp",
    "okegawa.saitama.jp",
    "omiya.saitama.jp",
    "otaki.saitama.jp",
    "ranzan.saitama.jp",
    "ryokami.saitama.jp",
    "saitama.saitama.jp",
    "sakado.saitama.jp",
    "satte.saitama.jp",
    "sayama.saitama.jp",
    "shiki.saitama.jp",
    "shiraoka.saitama.jp",
    "soka.saitama.jp",
    "sugito.saitama.jp",
    "toda.saitama.jp",
    "tokigawa.saitama.jp",
    "tokorozawa.saitama.jp",
    "tsurugashima.saitama.jp",
    "urawa.saitama.jp",
    "warabi.saitama.jp",
    "yashio.saitama.jp",
    "yokoze.saitama.jp",
    "yono.saitama.jp",
    "yorii.saitama.jp",
    "yoshida.saitama.jp",
    "yoshikawa.saitama.jp",
    "yoshimi.saitama.jp",
    "aisho.shiga.jp",
    "gamo.shiga.jp",
    "higashiomi.shiga.jp",
    "hikone.shiga.jp",
    "koka.shiga.jp",
    "konan.shiga.jp",
    "kosei.shiga.jp",
    "koto.shiga.jp",
    "kusatsu.shiga.jp",
    "maibara.shiga.jp",
    "moriyama.shiga.jp",
    "nagahama.shiga.jp",
    "nishiazai.shiga.jp",
    "notogawa.shiga.jp",
    "omihachiman.shiga.jp",
    "otsu.shiga.jp",
    "ritto.shiga.jp",
    "ryuoh.shiga.jp",
    "takashima.shiga.jp",
    "takatsuki.shiga.jp",
    "torahime.shiga.jp",
    "toyosato.shiga.jp",
    "yasu.shiga.jp",
    "akagi.shimane.jp",
    "ama.shimane.jp",
    "gotsu.shimane.jp",
    "hamada.shimane.jp",
    "higashiizumo.shimane.jp",
    "hikawa.shimane.jp",
    "hikimi.shimane.jp",
    "izumo.shimane.jp",
    "kakinoki.shimane.jp",
    "masuda.shimane.jp",
    "matsue.shimane.jp",
    "misato.shimane.jp",
    "nishinoshima.shimane.jp",
    "ohda.shimane.jp",
    "okinoshima.shimane.jp",
    "okuizumo.shimane.jp",
    "shimane.shimane.jp",
    "tamayu.shimane.jp",
    "tsuwano.shimane.jp",
    "unnan.shimane.jp",
    "yakumo.shimane.jp",
    "yasugi.shimane.jp",
    "yatsuka.shimane.jp",
    "arai.shizuoka.jp",
    "atami.shizuoka.jp",
    "fuji.shizuoka.jp",
    "fujieda.shizuoka.jp",
    "fujikawa.shizuoka.jp",
    "fujinomiya.shizuoka.jp",
    "fukuroi.shizuoka.jp",
    "gotemba.shizuoka.jp",
    "haibara.shizuoka.jp",
    "hamamatsu.shizuoka.jp",
    "higashiizu.shizuoka.jp",
    "ito.shizuoka.jp",
    "iwata.shizuoka.jp",
    "izu.shizuoka.jp",
    "izunokuni.shizuoka.jp",
    "kakegawa.shizuoka.jp",
    "kannami.shizuoka.jp",
    "kawanehon.shizuoka.jp",
    "kawazu.shizuoka.jp",
    "kikugawa.shizuoka.jp",
    "kosai.shizuoka.jp",
    "makinohara.shizuoka.jp",
    "matsuzaki.shizuoka.jp",
    "minamiizu.shizuoka.jp",
    "mishima.shizuoka.jp",
    "morimachi.shizuoka.jp",
    "nishiizu.shizuoka.jp",
    "numazu.shizuoka.jp",
    "omaezaki.shizuoka.jp",
    "shimada.shizuoka.jp",
    "shimizu.shizuoka.jp",
    "shimoda.shizuoka.jp",
    "shizuoka.shizuoka.jp",
    "susono.shizuoka.jp",
    "yaizu.shizuoka.jp",
    "yoshida.shizuoka.jp",
    "ashikaga.tochigi.jp",
    "bato.tochigi.jp",
    "haga.tochigi.jp",
    "ichikai.tochigi.jp",
    "iwafune.tochigi.jp",
    "kaminokawa.tochigi.jp",
    "kanuma.tochigi.jp",
    "karasuyama.tochigi.jp",
    "kuroiso.tochigi.jp",
    "mashiko.tochigi.jp",
    "mibu.tochigi.jp",
    "moka.tochigi.jp",
    "motegi.tochigi.jp",
    "nasu.tochigi.jp",
    "nasushiobara.tochigi.jp",
    "nikko.tochigi.jp",
    "nishikata.tochigi.jp",
    "nogi.tochigi.jp",
    "ohira.tochigi.jp",
    "ohtawara.tochigi.jp",
    "oyama.tochigi.jp",
    "sakura.tochigi.jp",
    "sano.tochigi.jp",
    "shimotsuke.tochigi.jp",
    "shioya.tochigi.jp",
    "takanezawa.tochigi.jp",
    "tochigi.tochigi.jp",
    "tsuga.tochigi.jp",
    "ujiie.tochigi.jp",
    "utsunomiya.tochigi.jp",
    "yaita.tochigi.jp",
    "aizumi.tokushima.jp",
    "anan.tokushima.jp",
    "ichiba.tokushima.jp",
    "itano.tokushima.jp",
    "kainan.tokushima.jp",
    "komatsushima.tokushima.jp",
    "matsushige.tokushima.jp",
    "mima.tokushima.jp",
    "minami.tokushima.jp",
    "miyoshi.tokushima.jp",
    "mugi.tokushima.jp",
    "nakagawa.tokushima.jp",
    "naruto.tokushima.jp",
    "sanagochi.tokushima.jp",
    "shishikui.tokushima.jp",
    "tokushima.tokushima.jp",
    "wajiki.tokushima.jp",
    "adachi.tokyo.jp",
    "akiruno.tokyo.jp",
    "akishima.tokyo.jp",
    "aogashima.tokyo.jp",
    "arakawa.tokyo.jp",
    "bunkyo.tokyo.jp",
    "chiyoda.tokyo.jp",
    "chofu.tokyo.jp",
    "chuo.tokyo.jp",
    "edogawa.tokyo.jp",
    "fuchu.tokyo.jp",
    "fussa.tokyo.jp",
    "hachijo.tokyo.jp",
    "hachioji.tokyo.jp",
    "hamura.tokyo.jp",
    "higashikurume.tokyo.jp",
    "higashimurayama.tokyo.jp",
    "higashiyamato.tokyo.jp",
    "hino.tokyo.jp",
    "hinode.tokyo.jp",
    "hinohara.tokyo.jp",
    "inagi.tokyo.jp",
    "itabashi.tokyo.jp",
    "katsushika.tokyo.jp",
    "kita.tokyo.jp",
    "kiyose.tokyo.jp",
    "kodaira.tokyo.jp",
    "koganei.tokyo.jp",
    "kokubunji.tokyo.jp",
    "komae.tokyo.jp",
    "koto.tokyo.jp",
    "kouzushima.tokyo.jp",
    "kunitachi.tokyo.jp",
    "machida.tokyo.jp",
    "meguro.tokyo.jp",
    "minato.tokyo.jp",
    "mitaka.tokyo.jp",
    "mizuho.tokyo.jp",
    "musashimurayama.tokyo.jp",
    "musashino.tokyo.jp",
    "nakano.tokyo.jp",
    "nerima.tokyo.jp",
    "ogasawara.tokyo.jp",
    "okutama.tokyo.jp",
    "ome.tokyo.jp",
    "oshima.tokyo.jp",
    "ota.tokyo.jp",
    "setagaya.tokyo.jp",
    "shibuya.tokyo.jp",
    "shinagawa.tokyo.jp",
    "shinjuku.tokyo.jp",
    "suginami.tokyo.jp",
    "sumida.tokyo.jp",
    "tachikawa.tokyo.jp",
    "taito.tokyo.jp",
    "tama.tokyo.jp",
    "toshima.tokyo.jp",
    "chizu.tottori.jp",
    "hino.tottori.jp",
    "kawahara.tottori.jp",
    "koge.tottori.jp",
    "kotoura.tottori.jp",
    "misasa.tottori.jp",
    "nanbu.tottori.jp",
    "nichinan.tottori.jp",
    "sakaiminato.tottori.jp",
    "tottori.tottori.jp",
    "wakasa.tottori.jp",
    "yazu.tottori.jp",
    "yonago.tottori.jp",
    "asahi.toyama.jp",
    "fuchu.toyama.jp",
    "fukumitsu.toyama.jp",
    "funahashi.toyama.jp",
    "himi.toyama.jp",
    "imizu.toyama.jp",
    "inami.toyama.jp",
    "johana.toyama.jp",
    "kamiichi.toyama.jp",
    "kurobe.toyama.jp",
    "nakaniikawa.toyama.jp",
    "namerikawa.toyama.jp",
    "nanto.toyama.jp",
    "nyuzen.toyama.jp",
    "oyabe.toyama.jp",
    "taira.toyama.jp",
    "takaoka.toyama.jp",
    "tateyama.toyama.jp",
    "toga.toyama.jp",
    "tonami.toyama.jp",
    "toyama.toyama.jp",
    "unazuki.toyama.jp",
    "uozu.toyama.jp",
    "yamada.toyama.jp",
    "arida.wakayama.jp",
    "aridagawa.wakayama.jp",
    "gobo.wakayama.jp",
    "hashimoto.wakayama.jp",
    "hidaka.wakayama.jp",
    "hirogawa.wakayama.jp",
    "inami.wakayama.jp",
    "iwade.wakayama.jp",
    "kainan.wakayama.jp",
    "kamitonda.wakayama.jp",
    "katsuragi.wakayama.jp",
    "kimino.wakayama.jp",
    "kinokawa.wakayama.jp",
    "kitayama.wakayama.jp",
    "koya.wakayama.jp",
    "koza.wakayama.jp",
    "kozagawa.wakayama.jp",
    "kudoyama.wakayama.jp",
    "kushimoto.wakayama.jp",
    "mihama.wakayama.jp",
    "misato.wakayama.jp",
    "nachikatsuura.wakayama.jp",
    "shingu.wakayama.jp",
    "shirahama.wakayama.jp",
    "taiji.wakayama.jp",
    "tanabe.wakayama.jp",
    "wakayama.wakayama.jp",
    "yuasa.wakayama.jp",
    "yura.wakayama.jp",
    "asahi.yamagata.jp",
    "funagata.yamagata.jp",
    "higashine.yamagata.jp",
    "iide.yamagata.jp",
    "kahoku.yamagata.jp",
    "kaminoyama.yamagata.jp",
    "kaneyama.yamagata.jp",
    "kawanishi.yamagata.jp",
    "mamurogawa.yamagata.jp",
    "mikawa.yamagata.jp",
    "murayama.yamagata.jp",
    "nagai.yamagata.jp",
    "nakayama.yamagata.jp",
    "nanyo.yamagata.jp",
    "nishikawa.yamagata.jp",
    "obanazawa.yamagata.jp",
    "oe.yamagata.jp",
    "oguni.yamagata.jp",
    "ohkura.yamagata.jp",
    "oishida.yamagata.jp",
    "sagae.yamagata.jp",
    "sakata.yamagata.jp",
    "sakegawa.yamagata.jp",
    "shinjo.yamagata.jp",
    "shirataka.yamagata.jp",
    "shonai.yamagata.jp",
    "takahata.yamagata.jp",
    "tendo.yamagata.jp",
    "tozawa.yamagata.jp",
    "tsuruoka.yamagata.jp",
    "yamagata.yamagata.jp",
    "yamanobe.yamagata.jp",
    "yonezawa.yamagata.jp",
    "yuza.yamagata.jp",
    "abu.yamaguchi.jp",
    "hagi.yamaguchi.jp",
    "hikari.yamaguchi.jp",
    "hofu.yamaguchi.jp",
    "iwakuni.yamaguchi.jp",
    "kudamatsu.yamaguchi.jp",
    "mitou.yamaguchi.jp",
    "nagato.yamaguchi.jp",
    "oshima.yamaguchi.jp",
    "shimonoseki.yamaguchi.jp",
    "shunan.yamaguchi.jp",
    "tabuse.yamaguchi.jp",
    "tokuyama.yamaguchi.jp",
    "toyota.yamaguchi.jp",
    "ube.yamaguchi.jp",
    "yuu.yamaguchi.jp",
    "chuo.yamanashi.jp",
    "doshi.yamanashi.jp",
    "fuefuki.yamanashi.jp",
    "fujikawa.yamanashi.jp",
    "fujikawaguchiko.yamanashi.jp",
    "fujiyoshida.yamanashi.jp",
    "hayakawa.yamanashi.jp",
    "hokuto.yamanashi.jp",
    "ichikawamisato.yamanashi.jp",
    "kai.yamanashi.jp",
    "kofu.yamanashi.jp",
    "koshu.yamanashi.jp",
    "kosuge.yamanashi.jp",
    "minami-alps.yamanashi.jp",
    "minobu.yamanashi.jp",
    "nakamichi.yamanashi.jp",
    "nanbu.yamanashi.jp",
    "narusawa.yamanashi.jp",
    "nirasaki.yamanashi.jp",
    "nishikatsura.yamanashi.jp",
    "oshino.yamanashi.jp",
    "otsuki.yamanashi.jp",
    "showa.yamanashi.jp",
    "tabayama.yamanashi.jp",
    "tsuru.yamanashi.jp",
    "uenohara.yamanashi.jp",
    "yamanakako.yamanashi.jp",
    "yamanashi.yamanashi.jp",
    "ke",
    "ac.ke",
    "co.ke",
    "go.ke",
    "info.ke",
    "me.ke",
    "mobi.ke",
    "ne.ke",
    "or.ke",
    "sc.ke",
    "kg",
    "org.kg",
    "net.kg",
    "com.kg",
    "edu.kg",
    "gov.kg",
    "mil.kg",
    "*.kh",
    "ki",
    "edu.ki",
    "biz.ki",
    "net.ki",
    "org.ki",
    "gov.ki",
    "info.ki",
    "com.ki",
    "km",
    "org.km",
    "nom.km",
    "gov.km",
    "prd.km",
    "tm.km",
    "edu.km",
    "mil.km",
    "ass.km",
    "com.km",
    "coop.km",
    "asso.km",
    "presse.km",
    "medecin.km",
    "notaires.km",
    "pharmaciens.km",
    "veterinaire.km",
    "gouv.km",
    "kn",
    "net.kn",
    "org.kn",
    "edu.kn",
    "gov.kn",
    "kp",
    "com.kp",
    "edu.kp",
    "gov.kp",
    "org.kp",
    "rep.kp",
    "tra.kp",
    "kr",
    "ac.kr",
    "co.kr",
    "es.kr",
    "go.kr",
    "hs.kr",
    "kg.kr",
    "mil.kr",
    "ms.kr",
    "ne.kr",
    "or.kr",
    "pe.kr",
    "re.kr",
    "sc.kr",
    "busan.kr",
    "chungbuk.kr",
    "chungnam.kr",
    "daegu.kr",
    "daejeon.kr",
    "gangwon.kr",
    "gwangju.kr",
    "gyeongbuk.kr",
    "gyeonggi.kr",
    "gyeongnam.kr",
    "incheon.kr",
    "jeju.kr",
    "jeonbuk.kr",
    "jeonnam.kr",
    "seoul.kr",
    "ulsan.kr",
    "kw",
    "com.kw",
    "edu.kw",
    "emb.kw",
    "gov.kw",
    "ind.kw",
    "net.kw",
    "org.kw",
    "ky",
    "edu.ky",
    "gov.ky",
    "com.ky",
    "org.ky",
    "net.ky",
    "kz",
    "org.kz",
    "edu.kz",
    "net.kz",
    "gov.kz",
    "mil.kz",
    "com.kz",
    "la",
    "int.la",
    "net.la",
    "info.la",
    "edu.la",
    "gov.la",
    "per.la",
    "com.la",
    "org.la",
    "lb",
    "com.lb",
    "edu.lb",
    "gov.lb",
    "net.lb",
    "org.lb",
    "lc",
    "com.lc",
    "net.lc",
    "co.lc",
    "org.lc",
    "edu.lc",
    "gov.lc",
    "li",
    "lk",
    "gov.lk",
    "sch.lk",
    "net.lk",
    "int.lk",
    "com.lk",
    "org.lk",
    "edu.lk",
    "ngo.lk",
    "soc.lk",
    "web.lk",
    "ltd.lk",
    "assn.lk",
    "grp.lk",
    "hotel.lk",
    "ac.lk",
    "lr",
    "com.lr",
    "edu.lr",
    "gov.lr",
    "org.lr",
    "net.lr",
    "ls",
    "ac.ls",
    "biz.ls",
    "co.ls",
    "edu.ls",
    "gov.ls",
    "info.ls",
    "net.ls",
    "org.ls",
    "sc.ls",
    "lt",
    "gov.lt",
    "lu",
    "lv",
    "com.lv",
    "edu.lv",
    "gov.lv",
    "org.lv",
    "mil.lv",
    "id.lv",
    "net.lv",
    "asn.lv",
    "conf.lv",
    "ly",
    "com.ly",
    "net.ly",
    "gov.ly",
    "plc.ly",
    "edu.ly",
    "sch.ly",
    "med.ly",
    "org.ly",
    "id.ly",
    "ma",
    "co.ma",
    "net.ma",
    "gov.ma",
    "org.ma",
    "ac.ma",
    "press.ma",
    "mc",
    "tm.mc",
    "asso.mc",
    "md",
    "me",
    "co.me",
    "net.me",
    "org.me",
    "edu.me",
    "ac.me",
    "gov.me",
    "its.me",
    "priv.me",
    "mg",
    "org.mg",
    "nom.mg",
    "gov.mg",
    "prd.mg",
    "tm.mg",
    "edu.mg",
    "mil.mg",
    "com.mg",
    "co.mg",
    "mh",
    "mil",
    "mk",
    "com.mk",
    "org.mk",
    "net.mk",
    "edu.mk",
    "gov.mk",
    "inf.mk",
    "name.mk",
    "ml",
    "com.ml",
    "edu.ml",
    "gouv.ml",
    "gov.ml",
    "net.ml",
    "org.ml",
    "presse.ml",
    "*.mm",
    "mn",
    "gov.mn",
    "edu.mn",
    "org.mn",
    "mo",
    "com.mo",
    "net.mo",
    "org.mo",
    "edu.mo",
    "gov.mo",
    "mobi",
    "mp",
    "mq",
    "mr",
    "gov.mr",
    "ms",
    "com.ms",
    "edu.ms",
    "gov.ms",
    "net.ms",
    "org.ms",
    "mt",
    "com.mt",
    "edu.mt",
    "net.mt",
    "org.mt",
    "mu",
    "com.mu",
    "net.mu",
    "org.mu",
    "gov.mu",
    "ac.mu",
    "co.mu",
    "or.mu",
    "museum",
    "academy.museum",
    "agriculture.museum",
    "air.museum",
    "airguard.museum",
    "alabama.museum",
    "alaska.museum",
    "amber.museum",
    "ambulance.museum",
    "american.museum",
    "americana.museum",
    "americanantiques.museum",
    "americanart.museum",
    "amsterdam.museum",
    "and.museum",
    "annefrank.museum",
    "anthro.museum",
    "anthropology.museum",
    "antiques.museum",
    "aquarium.museum",
    "arboretum.museum",
    "archaeological.museum",
    "archaeology.museum",
    "architecture.museum",
    "art.museum",
    "artanddesign.museum",
    "artcenter.museum",
    "artdeco.museum",
    "arteducation.museum",
    "artgallery.museum",
    "arts.museum",
    "artsandcrafts.museum",
    "asmatart.museum",
    "assassination.museum",
    "assisi.museum",
    "association.museum",
    "astronomy.museum",
    "atlanta.museum",
    "austin.museum",
    "australia.museum",
    "automotive.museum",
    "aviation.museum",
    "axis.museum",
    "badajoz.museum",
    "baghdad.museum",
    "bahn.museum",
    "bale.museum",
    "baltimore.museum",
    "barcelona.museum",
    "baseball.museum",
    "basel.museum",
    "baths.museum",
    "bauern.museum",
    "beauxarts.museum",
    "beeldengeluid.museum",
    "bellevue.museum",
    "bergbau.museum",
    "berkeley.museum",
    "berlin.museum",
    "bern.museum",
    "bible.museum",
    "bilbao.museum",
    "bill.museum",
    "birdart.museum",
    "birthplace.museum",
    "bonn.museum",
    "boston.museum",
    "botanical.museum",
    "botanicalgarden.museum",
    "botanicgarden.museum",
    "botany.museum",
    "brandywinevalley.museum",
    "brasil.museum",
    "bristol.museum",
    "british.museum",
    "britishcolumbia.museum",
    "broadcast.museum",
    "brunel.museum",
    "brussel.museum",
    "brussels.museum",
    "bruxelles.museum",
    "building.museum",
    "burghof.museum",
    "bus.museum",
    "bushey.museum",
    "cadaques.museum",
    "california.museum",
    "cambridge.museum",
    "can.museum",
    "canada.museum",
    "capebreton.museum",
    "carrier.museum",
    "cartoonart.museum",
    "casadelamoneda.museum",
    "castle.museum",
    "castres.museum",
    "celtic.museum",
    "center.museum",
    "chattanooga.museum",
    "cheltenham.museum",
    "chesapeakebay.museum",
    "chicago.museum",
    "children.museum",
    "childrens.museum",
    "childrensgarden.museum",
    "chiropractic.museum",
    "chocolate.museum",
    "christiansburg.museum",
    "cincinnati.museum",
    "cinema.museum",
    "circus.museum",
    "civilisation.museum",
    "civilization.museum",
    "civilwar.museum",
    "clinton.museum",
    "clock.museum",
    "coal.museum",
    "coastaldefence.museum",
    "cody.museum",
    "coldwar.museum",
    "collection.museum",
    "colonialwilliamsburg.museum",
    "coloradoplateau.museum",
    "columbia.museum",
    "columbus.museum",
    "communication.museum",
    "communications.museum",
    "community.museum",
    "computer.museum",
    "computerhistory.museum",
    "comunica\xE7\xF5es.museum",
    "contemporary.museum",
    "contemporaryart.museum",
    "convent.museum",
    "copenhagen.museum",
    "corporation.museum",
    "correios-e-telecomunica\xE7\xF5es.museum",
    "corvette.museum",
    "costume.museum",
    "countryestate.museum",
    "county.museum",
    "crafts.museum",
    "cranbrook.museum",
    "creation.museum",
    "cultural.museum",
    "culturalcenter.museum",
    "culture.museum",
    "cyber.museum",
    "cymru.museum",
    "dali.museum",
    "dallas.museum",
    "database.museum",
    "ddr.museum",
    "decorativearts.museum",
    "delaware.museum",
    "delmenhorst.museum",
    "denmark.museum",
    "depot.museum",
    "design.museum",
    "detroit.museum",
    "dinosaur.museum",
    "discovery.museum",
    "dolls.museum",
    "donostia.museum",
    "durham.museum",
    "eastafrica.museum",
    "eastcoast.museum",
    "education.museum",
    "educational.museum",
    "egyptian.museum",
    "eisenbahn.museum",
    "elburg.museum",
    "elvendrell.museum",
    "embroidery.museum",
    "encyclopedic.museum",
    "england.museum",
    "entomology.museum",
    "environment.museum",
    "environmentalconservation.museum",
    "epilepsy.museum",
    "essex.museum",
    "estate.museum",
    "ethnology.museum",
    "exeter.museum",
    "exhibition.museum",
    "family.museum",
    "farm.museum",
    "farmequipment.museum",
    "farmers.museum",
    "farmstead.museum",
    "field.museum",
    "figueres.museum",
    "filatelia.museum",
    "film.museum",
    "fineart.museum",
    "finearts.museum",
    "finland.museum",
    "flanders.museum",
    "florida.museum",
    "force.museum",
    "fortmissoula.museum",
    "fortworth.museum",
    "foundation.museum",
    "francaise.museum",
    "frankfurt.museum",
    "franziskaner.museum",
    "freemasonry.museum",
    "freiburg.museum",
    "fribourg.museum",
    "frog.museum",
    "fundacio.museum",
    "furniture.museum",
    "gallery.museum",
    "garden.museum",
    "gateway.museum",
    "geelvinck.museum",
    "gemological.museum",
    "geology.museum",
    "georgia.museum",
    "giessen.museum",
    "glas.museum",
    "glass.museum",
    "gorge.museum",
    "grandrapids.museum",
    "graz.museum",
    "guernsey.museum",
    "halloffame.museum",
    "hamburg.museum",
    "handson.museum",
    "harvestcelebration.museum",
    "hawaii.museum",
    "health.museum",
    "heimatunduhren.museum",
    "hellas.museum",
    "helsinki.museum",
    "hembygdsforbund.museum",
    "heritage.museum",
    "histoire.museum",
    "historical.museum",
    "historicalsociety.museum",
    "historichouses.museum",
    "historisch.museum",
    "historisches.museum",
    "history.museum",
    "historyofscience.museum",
    "horology.museum",
    "house.museum",
    "humanities.museum",
    "illustration.museum",
    "imageandsound.museum",
    "indian.museum",
    "indiana.museum",
    "indianapolis.museum",
    "indianmarket.museum",
    "intelligence.museum",
    "interactive.museum",
    "iraq.museum",
    "iron.museum",
    "isleofman.museum",
    "jamison.museum",
    "jefferson.museum",
    "jerusalem.museum",
    "jewelry.museum",
    "jewish.museum",
    "jewishart.museum",
    "jfk.museum",
    "journalism.museum",
    "judaica.museum",
    "judygarland.museum",
    "juedisches.museum",
    "juif.museum",
    "karate.museum",
    "karikatur.museum",
    "kids.museum",
    "koebenhavn.museum",
    "koeln.museum",
    "kunst.museum",
    "kunstsammlung.museum",
    "kunstunddesign.museum",
    "labor.museum",
    "labour.museum",
    "lajolla.museum",
    "lancashire.museum",
    "landes.museum",
    "lans.museum",
    "l\xE4ns.museum",
    "larsson.museum",
    "lewismiller.museum",
    "lincoln.museum",
    "linz.museum",
    "living.museum",
    "livinghistory.museum",
    "localhistory.museum",
    "london.museum",
    "losangeles.museum",
    "louvre.museum",
    "loyalist.museum",
    "lucerne.museum",
    "luxembourg.museum",
    "luzern.museum",
    "mad.museum",
    "madrid.museum",
    "mallorca.museum",
    "manchester.museum",
    "mansion.museum",
    "mansions.museum",
    "manx.museum",
    "marburg.museum",
    "maritime.museum",
    "maritimo.museum",
    "maryland.museum",
    "marylhurst.museum",
    "media.museum",
    "medical.museum",
    "medizinhistorisches.museum",
    "meeres.museum",
    "memorial.museum",
    "mesaverde.museum",
    "michigan.museum",
    "midatlantic.museum",
    "military.museum",
    "mill.museum",
    "miners.museum",
    "mining.museum",
    "minnesota.museum",
    "missile.museum",
    "missoula.museum",
    "modern.museum",
    "moma.museum",
    "money.museum",
    "monmouth.museum",
    "monticello.museum",
    "montreal.museum",
    "moscow.museum",
    "motorcycle.museum",
    "muenchen.museum",
    "muenster.museum",
    "mulhouse.museum",
    "muncie.museum",
    "museet.museum",
    "museumcenter.museum",
    "museumvereniging.museum",
    "music.museum",
    "national.museum",
    "nationalfirearms.museum",
    "nationalheritage.museum",
    "nativeamerican.museum",
    "naturalhistory.museum",
    "naturalhistorymuseum.museum",
    "naturalsciences.museum",
    "nature.museum",
    "naturhistorisches.museum",
    "natuurwetenschappen.museum",
    "naumburg.museum",
    "naval.museum",
    "nebraska.museum",
    "neues.museum",
    "newhampshire.museum",
    "newjersey.museum",
    "newmexico.museum",
    "newport.museum",
    "newspaper.museum",
    "newyork.museum",
    "niepce.museum",
    "norfolk.museum",
    "north.museum",
    "nrw.museum",
    "nyc.museum",
    "nyny.museum",
    "oceanographic.museum",
    "oceanographique.museum",
    "omaha.museum",
    "online.museum",
    "ontario.museum",
    "openair.museum",
    "oregon.museum",
    "oregontrail.museum",
    "otago.museum",
    "oxford.museum",
    "pacific.museum",
    "paderborn.museum",
    "palace.museum",
    "paleo.museum",
    "palmsprings.museum",
    "panama.museum",
    "paris.museum",
    "pasadena.museum",
    "pharmacy.museum",
    "philadelphia.museum",
    "philadelphiaarea.museum",
    "philately.museum",
    "phoenix.museum",
    "photography.museum",
    "pilots.museum",
    "pittsburgh.museum",
    "planetarium.museum",
    "plantation.museum",
    "plants.museum",
    "plaza.museum",
    "portal.museum",
    "portland.museum",
    "portlligat.museum",
    "posts-and-telecommunications.museum",
    "preservation.museum",
    "presidio.museum",
    "press.museum",
    "project.museum",
    "public.museum",
    "pubol.museum",
    "quebec.museum",
    "railroad.museum",
    "railway.museum",
    "research.museum",
    "resistance.museum",
    "riodejaneiro.museum",
    "rochester.museum",
    "rockart.museum",
    "roma.museum",
    "russia.museum",
    "saintlouis.museum",
    "salem.museum",
    "salvadordali.museum",
    "salzburg.museum",
    "sandiego.museum",
    "sanfrancisco.museum",
    "santabarbara.museum",
    "santacruz.museum",
    "santafe.museum",
    "saskatchewan.museum",
    "satx.museum",
    "savannahga.museum",
    "schlesisches.museum",
    "schoenbrunn.museum",
    "schokoladen.museum",
    "school.museum",
    "schweiz.museum",
    "science.museum",
    "scienceandhistory.museum",
    "scienceandindustry.museum",
    "sciencecenter.museum",
    "sciencecenters.museum",
    "science-fiction.museum",
    "sciencehistory.museum",
    "sciences.museum",
    "sciencesnaturelles.museum",
    "scotland.museum",
    "seaport.museum",
    "settlement.museum",
    "settlers.museum",
    "shell.museum",
    "sherbrooke.museum",
    "sibenik.museum",
    "silk.museum",
    "ski.museum",
    "skole.museum",
    "society.museum",
    "sologne.museum",
    "soundandvision.museum",
    "southcarolina.museum",
    "southwest.museum",
    "space.museum",
    "spy.museum",
    "square.museum",
    "stadt.museum",
    "stalbans.museum",
    "starnberg.museum",
    "state.museum",
    "stateofdelaware.museum",
    "station.museum",
    "steam.museum",
    "steiermark.museum",
    "stjohn.museum",
    "stockholm.museum",
    "stpetersburg.museum",
    "stuttgart.museum",
    "suisse.museum",
    "surgeonshall.museum",
    "surrey.museum",
    "svizzera.museum",
    "sweden.museum",
    "sydney.museum",
    "tank.museum",
    "tcm.museum",
    "technology.museum",
    "telekommunikation.museum",
    "television.museum",
    "texas.museum",
    "textile.museum",
    "theater.museum",
    "time.museum",
    "timekeeping.museum",
    "topology.museum",
    "torino.museum",
    "touch.museum",
    "town.museum",
    "transport.museum",
    "tree.museum",
    "trolley.museum",
    "trust.museum",
    "trustee.museum",
    "uhren.museum",
    "ulm.museum",
    "undersea.museum",
    "university.museum",
    "usa.museum",
    "usantiques.museum",
    "usarts.museum",
    "uscountryestate.museum",
    "usculture.museum",
    "usdecorativearts.museum",
    "usgarden.museum",
    "ushistory.museum",
    "ushuaia.museum",
    "uslivinghistory.museum",
    "utah.museum",
    "uvic.museum",
    "valley.museum",
    "vantaa.museum",
    "versailles.museum",
    "viking.museum",
    "village.museum",
    "virginia.museum",
    "virtual.museum",
    "virtuel.museum",
    "vlaanderen.museum",
    "volkenkunde.museum",
    "wales.museum",
    "wallonie.museum",
    "war.museum",
    "washingtondc.museum",
    "watchandclock.museum",
    "watch-and-clock.museum",
    "western.museum",
    "westfalen.museum",
    "whaling.museum",
    "wildlife.museum",
    "williamsburg.museum",
    "windmill.museum",
    "workshop.museum",
    "york.museum",
    "yorkshire.museum",
    "yosemite.museum",
    "youth.museum",
    "zoological.museum",
    "zoology.museum",
    "\u05D9\u05E8\u05D5\u05E9\u05DC\u05D9\u05DD.museum",
    "\u0438\u043A\u043E\u043C.museum",
    "mv",
    "aero.mv",
    "biz.mv",
    "com.mv",
    "coop.mv",
    "edu.mv",
    "gov.mv",
    "info.mv",
    "int.mv",
    "mil.mv",
    "museum.mv",
    "name.mv",
    "net.mv",
    "org.mv",
    "pro.mv",
    "mw",
    "ac.mw",
    "biz.mw",
    "co.mw",
    "com.mw",
    "coop.mw",
    "edu.mw",
    "gov.mw",
    "int.mw",
    "museum.mw",
    "net.mw",
    "org.mw",
    "mx",
    "com.mx",
    "org.mx",
    "gob.mx",
    "edu.mx",
    "net.mx",
    "my",
    "com.my",
    "net.my",
    "org.my",
    "gov.my",
    "edu.my",
    "mil.my",
    "name.my",
    "mz",
    "ac.mz",
    "adv.mz",
    "co.mz",
    "edu.mz",
    "gov.mz",
    "mil.mz",
    "net.mz",
    "org.mz",
    "na",
    "info.na",
    "pro.na",
    "name.na",
    "school.na",
    "or.na",
    "dr.na",
    "us.na",
    "mx.na",
    "ca.na",
    "in.na",
    "cc.na",
    "tv.na",
    "ws.na",
    "mobi.na",
    "co.na",
    "com.na",
    "org.na",
    "name",
    "nc",
    "asso.nc",
    "nom.nc",
    "ne",
    "net",
    "nf",
    "com.nf",
    "net.nf",
    "per.nf",
    "rec.nf",
    "web.nf",
    "arts.nf",
    "firm.nf",
    "info.nf",
    "other.nf",
    "store.nf",
    "ng",
    "com.ng",
    "edu.ng",
    "gov.ng",
    "i.ng",
    "mil.ng",
    "mobi.ng",
    "name.ng",
    "net.ng",
    "org.ng",
    "sch.ng",
    "ni",
    "ac.ni",
    "biz.ni",
    "co.ni",
    "com.ni",
    "edu.ni",
    "gob.ni",
    "in.ni",
    "info.ni",
    "int.ni",
    "mil.ni",
    "net.ni",
    "nom.ni",
    "org.ni",
    "web.ni",
    "nl",
    "no",
    "fhs.no",
    "vgs.no",
    "fylkesbibl.no",
    "folkebibl.no",
    "museum.no",
    "idrett.no",
    "priv.no",
    "mil.no",
    "stat.no",
    "dep.no",
    "kommune.no",
    "herad.no",
    "aa.no",
    "ah.no",
    "bu.no",
    "fm.no",
    "hl.no",
    "hm.no",
    "jan-mayen.no",
    "mr.no",
    "nl.no",
    "nt.no",
    "of.no",
    "ol.no",
    "oslo.no",
    "rl.no",
    "sf.no",
    "st.no",
    "svalbard.no",
    "tm.no",
    "tr.no",
    "va.no",
    "vf.no",
    "gs.aa.no",
    "gs.ah.no",
    "gs.bu.no",
    "gs.fm.no",
    "gs.hl.no",
    "gs.hm.no",
    "gs.jan-mayen.no",
    "gs.mr.no",
    "gs.nl.no",
    "gs.nt.no",
    "gs.of.no",
    "gs.ol.no",
    "gs.oslo.no",
    "gs.rl.no",
    "gs.sf.no",
    "gs.st.no",
    "gs.svalbard.no",
    "gs.tm.no",
    "gs.tr.no",
    "gs.va.no",
    "gs.vf.no",
    "akrehamn.no",
    "\xE5krehamn.no",
    "algard.no",
    "\xE5lg\xE5rd.no",
    "arna.no",
    "brumunddal.no",
    "bryne.no",
    "bronnoysund.no",
    "br\xF8nn\xF8ysund.no",
    "drobak.no",
    "dr\xF8bak.no",
    "egersund.no",
    "fetsund.no",
    "floro.no",
    "flor\xF8.no",
    "fredrikstad.no",
    "hokksund.no",
    "honefoss.no",
    "h\xF8nefoss.no",
    "jessheim.no",
    "jorpeland.no",
    "j\xF8rpeland.no",
    "kirkenes.no",
    "kopervik.no",
    "krokstadelva.no",
    "langevag.no",
    "langev\xE5g.no",
    "leirvik.no",
    "mjondalen.no",
    "mj\xF8ndalen.no",
    "mo-i-rana.no",
    "mosjoen.no",
    "mosj\xF8en.no",
    "nesoddtangen.no",
    "orkanger.no",
    "osoyro.no",
    "os\xF8yro.no",
    "raholt.no",
    "r\xE5holt.no",
    "sandnessjoen.no",
    "sandnessj\xF8en.no",
    "skedsmokorset.no",
    "slattum.no",
    "spjelkavik.no",
    "stathelle.no",
    "stavern.no",
    "stjordalshalsen.no",
    "stj\xF8rdalshalsen.no",
    "tananger.no",
    "tranby.no",
    "vossevangen.no",
    "afjord.no",
    "\xE5fjord.no",
    "agdenes.no",
    "al.no",
    "\xE5l.no",
    "alesund.no",
    "\xE5lesund.no",
    "alstahaug.no",
    "alta.no",
    "\xE1lt\xE1.no",
    "alaheadju.no",
    "\xE1laheadju.no",
    "alvdal.no",
    "amli.no",
    "\xE5mli.no",
    "amot.no",
    "\xE5mot.no",
    "andebu.no",
    "andoy.no",
    "and\xF8y.no",
    "andasuolo.no",
    "ardal.no",
    "\xE5rdal.no",
    "aremark.no",
    "arendal.no",
    "\xE5s.no",
    "aseral.no",
    "\xE5seral.no",
    "asker.no",
    "askim.no",
    "askvoll.no",
    "askoy.no",
    "ask\xF8y.no",
    "asnes.no",
    "\xE5snes.no",
    "audnedaln.no",
    "aukra.no",
    "aure.no",
    "aurland.no",
    "aurskog-holand.no",
    "aurskog-h\xF8land.no",
    "austevoll.no",
    "austrheim.no",
    "averoy.no",
    "aver\xF8y.no",
    "balestrand.no",
    "ballangen.no",
    "balat.no",
    "b\xE1l\xE1t.no",
    "balsfjord.no",
    "bahccavuotna.no",
    "b\xE1hccavuotna.no",
    "bamble.no",
    "bardu.no",
    "beardu.no",
    "beiarn.no",
    "bajddar.no",
    "b\xE1jddar.no",
    "baidar.no",
    "b\xE1id\xE1r.no",
    "berg.no",
    "bergen.no",
    "berlevag.no",
    "berlev\xE5g.no",
    "bearalvahki.no",
    "bearalv\xE1hki.no",
    "bindal.no",
    "birkenes.no",
    "bjarkoy.no",
    "bjark\xF8y.no",
    "bjerkreim.no",
    "bjugn.no",
    "bodo.no",
    "bod\xF8.no",
    "badaddja.no",
    "b\xE5d\xE5ddj\xE5.no",
    "budejju.no",
    "bokn.no",
    "bremanger.no",
    "bronnoy.no",
    "br\xF8nn\xF8y.no",
    "bygland.no",
    "bykle.no",
    "barum.no",
    "b\xE6rum.no",
    "bo.telemark.no",
    "b\xF8.telemark.no",
    "bo.nordland.no",
    "b\xF8.nordland.no",
    "bievat.no",
    "biev\xE1t.no",
    "bomlo.no",
    "b\xF8mlo.no",
    "batsfjord.no",
    "b\xE5tsfjord.no",
    "bahcavuotna.no",
    "b\xE1hcavuotna.no",
    "dovre.no",
    "drammen.no",
    "drangedal.no",
    "dyroy.no",
    "dyr\xF8y.no",
    "donna.no",
    "d\xF8nna.no",
    "eid.no",
    "eidfjord.no",
    "eidsberg.no",
    "eidskog.no",
    "eidsvoll.no",
    "eigersund.no",
    "elverum.no",
    "enebakk.no",
    "engerdal.no",
    "etne.no",
    "etnedal.no",
    "evenes.no",
    "evenassi.no",
    "even\xE1\u0161\u0161i.no",
    "evje-og-hornnes.no",
    "farsund.no",
    "fauske.no",
    "fuossko.no",
    "fuoisku.no",
    "fedje.no",
    "fet.no",
    "finnoy.no",
    "finn\xF8y.no",
    "fitjar.no",
    "fjaler.no",
    "fjell.no",
    "flakstad.no",
    "flatanger.no",
    "flekkefjord.no",
    "flesberg.no",
    "flora.no",
    "fla.no",
    "fl\xE5.no",
    "folldal.no",
    "forsand.no",
    "fosnes.no",
    "frei.no",
    "frogn.no",
    "froland.no",
    "frosta.no",
    "frana.no",
    "fr\xE6na.no",
    "froya.no",
    "fr\xF8ya.no",
    "fusa.no",
    "fyresdal.no",
    "forde.no",
    "f\xF8rde.no",
    "gamvik.no",
    "gangaviika.no",
    "g\xE1\u014Bgaviika.no",
    "gaular.no",
    "gausdal.no",
    "gildeskal.no",
    "gildesk\xE5l.no",
    "giske.no",
    "gjemnes.no",
    "gjerdrum.no",
    "gjerstad.no",
    "gjesdal.no",
    "gjovik.no",
    "gj\xF8vik.no",
    "gloppen.no",
    "gol.no",
    "gran.no",
    "grane.no",
    "granvin.no",
    "gratangen.no",
    "grimstad.no",
    "grong.no",
    "kraanghke.no",
    "kr\xE5anghke.no",
    "grue.no",
    "gulen.no",
    "hadsel.no",
    "halden.no",
    "halsa.no",
    "hamar.no",
    "hamaroy.no",
    "habmer.no",
    "h\xE1bmer.no",
    "hapmir.no",
    "h\xE1pmir.no",
    "hammerfest.no",
    "hammarfeasta.no",
    "h\xE1mm\xE1rfeasta.no",
    "haram.no",
    "hareid.no",
    "harstad.no",
    "hasvik.no",
    "aknoluokta.no",
    "\xE1k\u014Boluokta.no",
    "hattfjelldal.no",
    "aarborte.no",
    "haugesund.no",
    "hemne.no",
    "hemnes.no",
    "hemsedal.no",
    "heroy.more-og-romsdal.no",
    "her\xF8y.m\xF8re-og-romsdal.no",
    "heroy.nordland.no",
    "her\xF8y.nordland.no",
    "hitra.no",
    "hjartdal.no",
    "hjelmeland.no",
    "hobol.no",
    "hob\xF8l.no",
    "hof.no",
    "hol.no",
    "hole.no",
    "holmestrand.no",
    "holtalen.no",
    "holt\xE5len.no",
    "hornindal.no",
    "horten.no",
    "hurdal.no",
    "hurum.no",
    "hvaler.no",
    "hyllestad.no",
    "hagebostad.no",
    "h\xE6gebostad.no",
    "hoyanger.no",
    "h\xF8yanger.no",
    "hoylandet.no",
    "h\xF8ylandet.no",
    "ha.no",
    "h\xE5.no",
    "ibestad.no",
    "inderoy.no",
    "inder\xF8y.no",
    "iveland.no",
    "jevnaker.no",
    "jondal.no",
    "jolster.no",
    "j\xF8lster.no",
    "karasjok.no",
    "karasjohka.no",
    "k\xE1r\xE1\u0161johka.no",
    "karlsoy.no",
    "galsa.no",
    "g\xE1ls\xE1.no",
    "karmoy.no",
    "karm\xF8y.no",
    "kautokeino.no",
    "guovdageaidnu.no",
    "klepp.no",
    "klabu.no",
    "kl\xE6bu.no",
    "kongsberg.no",
    "kongsvinger.no",
    "kragero.no",
    "krager\xF8.no",
    "kristiansand.no",
    "kristiansund.no",
    "krodsherad.no",
    "kr\xF8dsherad.no",
    "kvalsund.no",
    "rahkkeravju.no",
    "r\xE1hkker\xE1vju.no",
    "kvam.no",
    "kvinesdal.no",
    "kvinnherad.no",
    "kviteseid.no",
    "kvitsoy.no",
    "kvits\xF8y.no",
    "kvafjord.no",
    "kv\xE6fjord.no",
    "giehtavuoatna.no",
    "kvanangen.no",
    "kv\xE6nangen.no",
    "navuotna.no",
    "n\xE1vuotna.no",
    "kafjord.no",
    "k\xE5fjord.no",
    "gaivuotna.no",
    "g\xE1ivuotna.no",
    "larvik.no",
    "lavangen.no",
    "lavagis.no",
    "loabat.no",
    "loab\xE1t.no",
    "lebesby.no",
    "davvesiida.no",
    "leikanger.no",
    "leirfjord.no",
    "leka.no",
    "leksvik.no",
    "lenvik.no",
    "leangaviika.no",
    "lea\u014Bgaviika.no",
    "lesja.no",
    "levanger.no",
    "lier.no",
    "lierne.no",
    "lillehammer.no",
    "lillesand.no",
    "lindesnes.no",
    "lindas.no",
    "lind\xE5s.no",
    "lom.no",
    "loppa.no",
    "lahppi.no",
    "l\xE1hppi.no",
    "lund.no",
    "lunner.no",
    "luroy.no",
    "lur\xF8y.no",
    "luster.no",
    "lyngdal.no",
    "lyngen.no",
    "ivgu.no",
    "lardal.no",
    "lerdal.no",
    "l\xE6rdal.no",
    "lodingen.no",
    "l\xF8dingen.no",
    "lorenskog.no",
    "l\xF8renskog.no",
    "loten.no",
    "l\xF8ten.no",
    "malvik.no",
    "masoy.no",
    "m\xE5s\xF8y.no",
    "muosat.no",
    "muos\xE1t.no",
    "mandal.no",
    "marker.no",
    "marnardal.no",
    "masfjorden.no",
    "meland.no",
    "meldal.no",
    "melhus.no",
    "meloy.no",
    "mel\xF8y.no",
    "meraker.no",
    "mer\xE5ker.no",
    "moareke.no",
    "mo\xE5reke.no",
    "midsund.no",
    "midtre-gauldal.no",
    "modalen.no",
    "modum.no",
    "molde.no",
    "moskenes.no",
    "moss.no",
    "mosvik.no",
    "malselv.no",
    "m\xE5lselv.no",
    "malatvuopmi.no",
    "m\xE1latvuopmi.no",
    "namdalseid.no",
    "aejrie.no",
    "namsos.no",
    "namsskogan.no",
    "naamesjevuemie.no",
    "n\xE5\xE5mesjevuemie.no",
    "laakesvuemie.no",
    "nannestad.no",
    "narvik.no",
    "narviika.no",
    "naustdal.no",
    "nedre-eiker.no",
    "nes.akershus.no",
    "nes.buskerud.no",
    "nesna.no",
    "nesodden.no",
    "nesseby.no",
    "unjarga.no",
    "unj\xE1rga.no",
    "nesset.no",
    "nissedal.no",
    "nittedal.no",
    "nord-aurdal.no",
    "nord-fron.no",
    "nord-odal.no",
    "norddal.no",
    "nordkapp.no",
    "davvenjarga.no",
    "davvenj\xE1rga.no",
    "nordre-land.no",
    "nordreisa.no",
    "raisa.no",
    "r\xE1isa.no",
    "nore-og-uvdal.no",
    "notodden.no",
    "naroy.no",
    "n\xE6r\xF8y.no",
    "notteroy.no",
    "n\xF8tter\xF8y.no",
    "odda.no",
    "oksnes.no",
    "\xF8ksnes.no",
    "oppdal.no",
    "oppegard.no",
    "oppeg\xE5rd.no",
    "orkdal.no",
    "orland.no",
    "\xF8rland.no",
    "orskog.no",
    "\xF8rskog.no",
    "orsta.no",
    "\xF8rsta.no",
    "os.hedmark.no",
    "os.hordaland.no",
    "osen.no",
    "osteroy.no",
    "oster\xF8y.no",
    "ostre-toten.no",
    "\xF8stre-toten.no",
    "overhalla.no",
    "ovre-eiker.no",
    "\xF8vre-eiker.no",
    "oyer.no",
    "\xF8yer.no",
    "oygarden.no",
    "\xF8ygarden.no",
    "oystre-slidre.no",
    "\xF8ystre-slidre.no",
    "porsanger.no",
    "porsangu.no",
    "pors\xE1\u014Bgu.no",
    "porsgrunn.no",
    "radoy.no",
    "rad\xF8y.no",
    "rakkestad.no",
    "rana.no",
    "ruovat.no",
    "randaberg.no",
    "rauma.no",
    "rendalen.no",
    "rennebu.no",
    "rennesoy.no",
    "rennes\xF8y.no",
    "rindal.no",
    "ringebu.no",
    "ringerike.no",
    "ringsaker.no",
    "rissa.no",
    "risor.no",
    "ris\xF8r.no",
    "roan.no",
    "rollag.no",
    "rygge.no",
    "ralingen.no",
    "r\xE6lingen.no",
    "rodoy.no",
    "r\xF8d\xF8y.no",
    "romskog.no",
    "r\xF8mskog.no",
    "roros.no",
    "r\xF8ros.no",
    "rost.no",
    "r\xF8st.no",
    "royken.no",
    "r\xF8yken.no",
    "royrvik.no",
    "r\xF8yrvik.no",
    "rade.no",
    "r\xE5de.no",
    "salangen.no",
    "siellak.no",
    "saltdal.no",
    "salat.no",
    "s\xE1l\xE1t.no",
    "s\xE1lat.no",
    "samnanger.no",
    "sande.more-og-romsdal.no",
    "sande.m\xF8re-og-romsdal.no",
    "sande.vestfold.no",
    "sandefjord.no",
    "sandnes.no",
    "sandoy.no",
    "sand\xF8y.no",
    "sarpsborg.no",
    "sauda.no",
    "sauherad.no",
    "sel.no",
    "selbu.no",
    "selje.no",
    "seljord.no",
    "sigdal.no",
    "siljan.no",
    "sirdal.no",
    "skaun.no",
    "skedsmo.no",
    "ski.no",
    "skien.no",
    "skiptvet.no",
    "skjervoy.no",
    "skjerv\xF8y.no",
    "skierva.no",
    "skierv\xE1.no",
    "skjak.no",
    "skj\xE5k.no",
    "skodje.no",
    "skanland.no",
    "sk\xE5nland.no",
    "skanit.no",
    "sk\xE1nit.no",
    "smola.no",
    "sm\xF8la.no",
    "snillfjord.no",
    "snasa.no",
    "sn\xE5sa.no",
    "snoasa.no",
    "snaase.no",
    "sn\xE5ase.no",
    "sogndal.no",
    "sokndal.no",
    "sola.no",
    "solund.no",
    "songdalen.no",
    "sortland.no",
    "spydeberg.no",
    "stange.no",
    "stavanger.no",
    "steigen.no",
    "steinkjer.no",
    "stjordal.no",
    "stj\xF8rdal.no",
    "stokke.no",
    "stor-elvdal.no",
    "stord.no",
    "stordal.no",
    "storfjord.no",
    "omasvuotna.no",
    "strand.no",
    "stranda.no",
    "stryn.no",
    "sula.no",
    "suldal.no",
    "sund.no",
    "sunndal.no",
    "surnadal.no",
    "sveio.no",
    "svelvik.no",
    "sykkylven.no",
    "sogne.no",
    "s\xF8gne.no",
    "somna.no",
    "s\xF8mna.no",
    "sondre-land.no",
    "s\xF8ndre-land.no",
    "sor-aurdal.no",
    "s\xF8r-aurdal.no",
    "sor-fron.no",
    "s\xF8r-fron.no",
    "sor-odal.no",
    "s\xF8r-odal.no",
    "sor-varanger.no",
    "s\xF8r-varanger.no",
    "matta-varjjat.no",
    "m\xE1tta-v\xE1rjjat.no",
    "sorfold.no",
    "s\xF8rfold.no",
    "sorreisa.no",
    "s\xF8rreisa.no",
    "sorum.no",
    "s\xF8rum.no",
    "tana.no",
    "deatnu.no",
    "time.no",
    "tingvoll.no",
    "tinn.no",
    "tjeldsund.no",
    "dielddanuorri.no",
    "tjome.no",
    "tj\xF8me.no",
    "tokke.no",
    "tolga.no",
    "torsken.no",
    "tranoy.no",
    "tran\xF8y.no",
    "tromso.no",
    "troms\xF8.no",
    "tromsa.no",
    "romsa.no",
    "trondheim.no",
    "troandin.no",
    "trysil.no",
    "trana.no",
    "tr\xE6na.no",
    "trogstad.no",
    "tr\xF8gstad.no",
    "tvedestrand.no",
    "tydal.no",
    "tynset.no",
    "tysfjord.no",
    "divtasvuodna.no",
    "divttasvuotna.no",
    "tysnes.no",
    "tysvar.no",
    "tysv\xE6r.no",
    "tonsberg.no",
    "t\xF8nsberg.no",
    "ullensaker.no",
    "ullensvang.no",
    "ulvik.no",
    "utsira.no",
    "vadso.no",
    "vads\xF8.no",
    "cahcesuolo.no",
    "\u010D\xE1hcesuolo.no",
    "vaksdal.no",
    "valle.no",
    "vang.no",
    "vanylven.no",
    "vardo.no",
    "vard\xF8.no",
    "varggat.no",
    "v\xE1rgg\xE1t.no",
    "vefsn.no",
    "vaapste.no",
    "vega.no",
    "vegarshei.no",
    "veg\xE5rshei.no",
    "vennesla.no",
    "verdal.no",
    "verran.no",
    "vestby.no",
    "vestnes.no",
    "vestre-slidre.no",
    "vestre-toten.no",
    "vestvagoy.no",
    "vestv\xE5g\xF8y.no",
    "vevelstad.no",
    "vik.no",
    "vikna.no",
    "vindafjord.no",
    "volda.no",
    "voss.no",
    "varoy.no",
    "v\xE6r\xF8y.no",
    "vagan.no",
    "v\xE5gan.no",
    "voagat.no",
    "vagsoy.no",
    "v\xE5gs\xF8y.no",
    "vaga.no",
    "v\xE5g\xE5.no",
    "valer.ostfold.no",
    "v\xE5ler.\xF8stfold.no",
    "valer.hedmark.no",
    "v\xE5ler.hedmark.no",
    "*.np",
    "nr",
    "biz.nr",
    "info.nr",
    "gov.nr",
    "edu.nr",
    "org.nr",
    "net.nr",
    "com.nr",
    "nu",
    "nz",
    "ac.nz",
    "co.nz",
    "cri.nz",
    "geek.nz",
    "gen.nz",
    "govt.nz",
    "health.nz",
    "iwi.nz",
    "kiwi.nz",
    "maori.nz",
    "mil.nz",
    "m\u0101ori.nz",
    "net.nz",
    "org.nz",
    "parliament.nz",
    "school.nz",
    "om",
    "co.om",
    "com.om",
    "edu.om",
    "gov.om",
    "med.om",
    "museum.om",
    "net.om",
    "org.om",
    "pro.om",
    "onion",
    "org",
    "pa",
    "ac.pa",
    "gob.pa",
    "com.pa",
    "org.pa",
    "sld.pa",
    "edu.pa",
    "net.pa",
    "ing.pa",
    "abo.pa",
    "med.pa",
    "nom.pa",
    "pe",
    "edu.pe",
    "gob.pe",
    "nom.pe",
    "mil.pe",
    "org.pe",
    "com.pe",
    "net.pe",
    "pf",
    "com.pf",
    "org.pf",
    "edu.pf",
    "*.pg",
    "ph",
    "com.ph",
    "net.ph",
    "org.ph",
    "gov.ph",
    "edu.ph",
    "ngo.ph",
    "mil.ph",
    "i.ph",
    "pk",
    "com.pk",
    "net.pk",
    "edu.pk",
    "org.pk",
    "fam.pk",
    "biz.pk",
    "web.pk",
    "gov.pk",
    "gob.pk",
    "gok.pk",
    "gon.pk",
    "gop.pk",
    "gos.pk",
    "info.pk",
    "pl",
    "com.pl",
    "net.pl",
    "org.pl",
    "aid.pl",
    "agro.pl",
    "atm.pl",
    "auto.pl",
    "biz.pl",
    "edu.pl",
    "gmina.pl",
    "gsm.pl",
    "info.pl",
    "mail.pl",
    "miasta.pl",
    "media.pl",
    "mil.pl",
    "nieruchomosci.pl",
    "nom.pl",
    "pc.pl",
    "powiat.pl",
    "priv.pl",
    "realestate.pl",
    "rel.pl",
    "sex.pl",
    "shop.pl",
    "sklep.pl",
    "sos.pl",
    "szkola.pl",
    "targi.pl",
    "tm.pl",
    "tourism.pl",
    "travel.pl",
    "turystyka.pl",
    "gov.pl",
    "ap.gov.pl",
    "ic.gov.pl",
    "is.gov.pl",
    "us.gov.pl",
    "kmpsp.gov.pl",
    "kppsp.gov.pl",
    "kwpsp.gov.pl",
    "psp.gov.pl",
    "wskr.gov.pl",
    "kwp.gov.pl",
    "mw.gov.pl",
    "ug.gov.pl",
    "um.gov.pl",
    "umig.gov.pl",
    "ugim.gov.pl",
    "upow.gov.pl",
    "uw.gov.pl",
    "starostwo.gov.pl",
    "pa.gov.pl",
    "po.gov.pl",
    "psse.gov.pl",
    "pup.gov.pl",
    "rzgw.gov.pl",
    "sa.gov.pl",
    "so.gov.pl",
    "sr.gov.pl",
    "wsa.gov.pl",
    "sko.gov.pl",
    "uzs.gov.pl",
    "wiih.gov.pl",
    "winb.gov.pl",
    "pinb.gov.pl",
    "wios.gov.pl",
    "witd.gov.pl",
    "wzmiuw.gov.pl",
    "piw.gov.pl",
    "wiw.gov.pl",
    "griw.gov.pl",
    "wif.gov.pl",
    "oum.gov.pl",
    "sdn.gov.pl",
    "zp.gov.pl",
    "uppo.gov.pl",
    "mup.gov.pl",
    "wuoz.gov.pl",
    "konsulat.gov.pl",
    "oirm.gov.pl",
    "augustow.pl",
    "babia-gora.pl",
    "bedzin.pl",
    "beskidy.pl",
    "bialowieza.pl",
    "bialystok.pl",
    "bielawa.pl",
    "bieszczady.pl",
    "boleslawiec.pl",
    "bydgoszcz.pl",
    "bytom.pl",
    "cieszyn.pl",
    "czeladz.pl",
    "czest.pl",
    "dlugoleka.pl",
    "elblag.pl",
    "elk.pl",
    "glogow.pl",
    "gniezno.pl",
    "gorlice.pl",
    "grajewo.pl",
    "ilawa.pl",
    "jaworzno.pl",
    "jelenia-gora.pl",
    "jgora.pl",
    "kalisz.pl",
    "kazimierz-dolny.pl",
    "karpacz.pl",
    "kartuzy.pl",
    "kaszuby.pl",
    "katowice.pl",
    "kepno.pl",
    "ketrzyn.pl",
    "klodzko.pl",
    "kobierzyce.pl",
    "kolobrzeg.pl",
    "konin.pl",
    "konskowola.pl",
    "kutno.pl",
    "lapy.pl",
    "lebork.pl",
    "legnica.pl",
    "lezajsk.pl",
    "limanowa.pl",
    "lomza.pl",
    "lowicz.pl",
    "lubin.pl",
    "lukow.pl",
    "malbork.pl",
    "malopolska.pl",
    "mazowsze.pl",
    "mazury.pl",
    "mielec.pl",
    "mielno.pl",
    "mragowo.pl",
    "naklo.pl",
    "nowaruda.pl",
    "nysa.pl",
    "olawa.pl",
    "olecko.pl",
    "olkusz.pl",
    "olsztyn.pl",
    "opoczno.pl",
    "opole.pl",
    "ostroda.pl",
    "ostroleka.pl",
    "ostrowiec.pl",
    "ostrowwlkp.pl",
    "pila.pl",
    "pisz.pl",
    "podhale.pl",
    "podlasie.pl",
    "polkowice.pl",
    "pomorze.pl",
    "pomorskie.pl",
    "prochowice.pl",
    "pruszkow.pl",
    "przeworsk.pl",
    "pulawy.pl",
    "radom.pl",
    "rawa-maz.pl",
    "rybnik.pl",
    "rzeszow.pl",
    "sanok.pl",
    "sejny.pl",
    "slask.pl",
    "slupsk.pl",
    "sosnowiec.pl",
    "stalowa-wola.pl",
    "skoczow.pl",
    "starachowice.pl",
    "stargard.pl",
    "suwalki.pl",
    "swidnica.pl",
    "swiebodzin.pl",
    "swinoujscie.pl",
    "szczecin.pl",
    "szczytno.pl",
    "tarnobrzeg.pl",
    "tgory.pl",
    "turek.pl",
    "tychy.pl",
    "ustka.pl",
    "walbrzych.pl",
    "warmia.pl",
    "warszawa.pl",
    "waw.pl",
    "wegrow.pl",
    "wielun.pl",
    "wlocl.pl",
    "wloclawek.pl",
    "wodzislaw.pl",
    "wolomin.pl",
    "wroclaw.pl",
    "zachpomor.pl",
    "zagan.pl",
    "zarow.pl",
    "zgora.pl",
    "zgorzelec.pl",
    "pm",
    "pn",
    "gov.pn",
    "co.pn",
    "org.pn",
    "edu.pn",
    "net.pn",
    "post",
    "pr",
    "com.pr",
    "net.pr",
    "org.pr",
    "gov.pr",
    "edu.pr",
    "isla.pr",
    "pro.pr",
    "biz.pr",
    "info.pr",
    "name.pr",
    "est.pr",
    "prof.pr",
    "ac.pr",
    "pro",
    "aaa.pro",
    "aca.pro",
    "acct.pro",
    "avocat.pro",
    "bar.pro",
    "cpa.pro",
    "eng.pro",
    "jur.pro",
    "law.pro",
    "med.pro",
    "recht.pro",
    "ps",
    "edu.ps",
    "gov.ps",
    "sec.ps",
    "plo.ps",
    "com.ps",
    "org.ps",
    "net.ps",
    "pt",
    "net.pt",
    "gov.pt",
    "org.pt",
    "edu.pt",
    "int.pt",
    "publ.pt",
    "com.pt",
    "nome.pt",
    "pw",
    "co.pw",
    "ne.pw",
    "or.pw",
    "ed.pw",
    "go.pw",
    "belau.pw",
    "py",
    "com.py",
    "coop.py",
    "edu.py",
    "gov.py",
    "mil.py",
    "net.py",
    "org.py",
    "qa",
    "com.qa",
    "edu.qa",
    "gov.qa",
    "mil.qa",
    "name.qa",
    "net.qa",
    "org.qa",
    "sch.qa",
    "re",
    "asso.re",
    "com.re",
    "nom.re",
    "ro",
    "arts.ro",
    "com.ro",
    "firm.ro",
    "info.ro",
    "nom.ro",
    "nt.ro",
    "org.ro",
    "rec.ro",
    "store.ro",
    "tm.ro",
    "www.ro",
    "rs",
    "ac.rs",
    "co.rs",
    "edu.rs",
    "gov.rs",
    "in.rs",
    "org.rs",
    "ru",
    "rw",
    "ac.rw",
    "co.rw",
    "coop.rw",
    "gov.rw",
    "mil.rw",
    "net.rw",
    "org.rw",
    "sa",
    "com.sa",
    "net.sa",
    "org.sa",
    "gov.sa",
    "med.sa",
    "pub.sa",
    "edu.sa",
    "sch.sa",
    "sb",
    "com.sb",
    "edu.sb",
    "gov.sb",
    "net.sb",
    "org.sb",
    "sc",
    "com.sc",
    "gov.sc",
    "net.sc",
    "org.sc",
    "edu.sc",
    "sd",
    "com.sd",
    "net.sd",
    "org.sd",
    "edu.sd",
    "med.sd",
    "tv.sd",
    "gov.sd",
    "info.sd",
    "se",
    "a.se",
    "ac.se",
    "b.se",
    "bd.se",
    "brand.se",
    "c.se",
    "d.se",
    "e.se",
    "f.se",
    "fh.se",
    "fhsk.se",
    "fhv.se",
    "g.se",
    "h.se",
    "i.se",
    "k.se",
    "komforb.se",
    "kommunalforbund.se",
    "komvux.se",
    "l.se",
    "lanbib.se",
    "m.se",
    "n.se",
    "naturbruksgymn.se",
    "o.se",
    "org.se",
    "p.se",
    "parti.se",
    "pp.se",
    "press.se",
    "r.se",
    "s.se",
    "t.se",
    "tm.se",
    "u.se",
    "w.se",
    "x.se",
    "y.se",
    "z.se",
    "sg",
    "com.sg",
    "net.sg",
    "org.sg",
    "gov.sg",
    "edu.sg",
    "per.sg",
    "sh",
    "com.sh",
    "net.sh",
    "gov.sh",
    "org.sh",
    "mil.sh",
    "si",
    "sj",
    "sk",
    "sl",
    "com.sl",
    "net.sl",
    "edu.sl",
    "gov.sl",
    "org.sl",
    "sm",
    "sn",
    "art.sn",
    "com.sn",
    "edu.sn",
    "gouv.sn",
    "org.sn",
    "perso.sn",
    "univ.sn",
    "so",
    "com.so",
    "edu.so",
    "gov.so",
    "me.so",
    "net.so",
    "org.so",
    "sr",
    "ss",
    "biz.ss",
    "com.ss",
    "edu.ss",
    "gov.ss",
    "net.ss",
    "org.ss",
    "st",
    "co.st",
    "com.st",
    "consulado.st",
    "edu.st",
    "embaixada.st",
    "gov.st",
    "mil.st",
    "net.st",
    "org.st",
    "principe.st",
    "saotome.st",
    "store.st",
    "su",
    "sv",
    "com.sv",
    "edu.sv",
    "gob.sv",
    "org.sv",
    "red.sv",
    "sx",
    "gov.sx",
    "sy",
    "edu.sy",
    "gov.sy",
    "net.sy",
    "mil.sy",
    "com.sy",
    "org.sy",
    "sz",
    "co.sz",
    "ac.sz",
    "org.sz",
    "tc",
    "td",
    "tel",
    "tf",
    "tg",
    "th",
    "ac.th",
    "co.th",
    "go.th",
    "in.th",
    "mi.th",
    "net.th",
    "or.th",
    "tj",
    "ac.tj",
    "biz.tj",
    "co.tj",
    "com.tj",
    "edu.tj",
    "go.tj",
    "gov.tj",
    "int.tj",
    "mil.tj",
    "name.tj",
    "net.tj",
    "nic.tj",
    "org.tj",
    "test.tj",
    "web.tj",
    "tk",
    "tl",
    "gov.tl",
    "tm",
    "com.tm",
    "co.tm",
    "org.tm",
    "net.tm",
    "nom.tm",
    "gov.tm",
    "mil.tm",
    "edu.tm",
    "tn",
    "com.tn",
    "ens.tn",
    "fin.tn",
    "gov.tn",
    "ind.tn",
    "intl.tn",
    "nat.tn",
    "net.tn",
    "org.tn",
    "info.tn",
    "perso.tn",
    "tourism.tn",
    "edunet.tn",
    "rnrt.tn",
    "rns.tn",
    "rnu.tn",
    "mincom.tn",
    "agrinet.tn",
    "defense.tn",
    "turen.tn",
    "to",
    "com.to",
    "gov.to",
    "net.to",
    "org.to",
    "edu.to",
    "mil.to",
    "tr",
    "av.tr",
    "bbs.tr",
    "bel.tr",
    "biz.tr",
    "com.tr",
    "dr.tr",
    "edu.tr",
    "gen.tr",
    "gov.tr",
    "info.tr",
    "mil.tr",
    "k12.tr",
    "kep.tr",
    "name.tr",
    "net.tr",
    "org.tr",
    "pol.tr",
    "tel.tr",
    "tsk.tr",
    "tv.tr",
    "web.tr",
    "nc.tr",
    "gov.nc.tr",
    "tt",
    "co.tt",
    "com.tt",
    "org.tt",
    "net.tt",
    "biz.tt",
    "info.tt",
    "pro.tt",
    "int.tt",
    "coop.tt",
    "jobs.tt",
    "mobi.tt",
    "travel.tt",
    "museum.tt",
    "aero.tt",
    "name.tt",
    "gov.tt",
    "edu.tt",
    "tv",
    "tw",
    "edu.tw",
    "gov.tw",
    "mil.tw",
    "com.tw",
    "net.tw",
    "org.tw",
    "idv.tw",
    "game.tw",
    "ebiz.tw",
    "club.tw",
    "\u7DB2\u8DEF.tw",
    "\u7D44\u7E54.tw",
    "\u5546\u696D.tw",
    "tz",
    "ac.tz",
    "co.tz",
    "go.tz",
    "hotel.tz",
    "info.tz",
    "me.tz",
    "mil.tz",
    "mobi.tz",
    "ne.tz",
    "or.tz",
    "sc.tz",
    "tv.tz",
    "ua",
    "com.ua",
    "edu.ua",
    "gov.ua",
    "in.ua",
    "net.ua",
    "org.ua",
    "cherkassy.ua",
    "cherkasy.ua",
    "chernigov.ua",
    "chernihiv.ua",
    "chernivtsi.ua",
    "chernovtsy.ua",
    "ck.ua",
    "cn.ua",
    "cr.ua",
    "crimea.ua",
    "cv.ua",
    "dn.ua",
    "dnepropetrovsk.ua",
    "dnipropetrovsk.ua",
    "dominic.ua",
    "donetsk.ua",
    "dp.ua",
    "if.ua",
    "ivano-frankivsk.ua",
    "kh.ua",
    "kharkiv.ua",
    "kharkov.ua",
    "kherson.ua",
    "khmelnitskiy.ua",
    "khmelnytskyi.ua",
    "kiev.ua",
    "kirovograd.ua",
    "km.ua",
    "kr.ua",
    "krym.ua",
    "ks.ua",
    "kv.ua",
    "kyiv.ua",
    "lg.ua",
    "lt.ua",
    "lugansk.ua",
    "lutsk.ua",
    "lv.ua",
    "lviv.ua",
    "mk.ua",
    "mykolaiv.ua",
    "nikolaev.ua",
    "od.ua",
    "odesa.ua",
    "odessa.ua",
    "pl.ua",
    "poltava.ua",
    "rivne.ua",
    "rovno.ua",
    "rv.ua",
    "sb.ua",
    "sebastopol.ua",
    "sevastopol.ua",
    "sm.ua",
    "sumy.ua",
    "te.ua",
    "ternopil.ua",
    "uz.ua",
    "uzhgorod.ua",
    "vinnica.ua",
    "vinnytsia.ua",
    "vn.ua",
    "volyn.ua",
    "yalta.ua",
    "zaporizhzhe.ua",
    "zaporizhzhia.ua",
    "zhitomir.ua",
    "zhytomyr.ua",
    "zp.ua",
    "zt.ua",
    "ug",
    "co.ug",
    "or.ug",
    "ac.ug",
    "sc.ug",
    "go.ug",
    "ne.ug",
    "com.ug",
    "org.ug",
    "uk",
    "ac.uk",
    "co.uk",
    "gov.uk",
    "ltd.uk",
    "me.uk",
    "net.uk",
    "nhs.uk",
    "org.uk",
    "plc.uk",
    "police.uk",
    "*.sch.uk",
    "us",
    "dni.us",
    "fed.us",
    "isa.us",
    "kids.us",
    "nsn.us",
    "ak.us",
    "al.us",
    "ar.us",
    "as.us",
    "az.us",
    "ca.us",
    "co.us",
    "ct.us",
    "dc.us",
    "de.us",
    "fl.us",
    "ga.us",
    "gu.us",
    "hi.us",
    "ia.us",
    "id.us",
    "il.us",
    "in.us",
    "ks.us",
    "ky.us",
    "la.us",
    "ma.us",
    "md.us",
    "me.us",
    "mi.us",
    "mn.us",
    "mo.us",
    "ms.us",
    "mt.us",
    "nc.us",
    "nd.us",
    "ne.us",
    "nh.us",
    "nj.us",
    "nm.us",
    "nv.us",
    "ny.us",
    "oh.us",
    "ok.us",
    "or.us",
    "pa.us",
    "pr.us",
    "ri.us",
    "sc.us",
    "sd.us",
    "tn.us",
    "tx.us",
    "ut.us",
    "vi.us",
    "vt.us",
    "va.us",
    "wa.us",
    "wi.us",
    "wv.us",
    "wy.us",
    "k12.ak.us",
    "k12.al.us",
    "k12.ar.us",
    "k12.as.us",
    "k12.az.us",
    "k12.ca.us",
    "k12.co.us",
    "k12.ct.us",
    "k12.dc.us",
    "k12.de.us",
    "k12.fl.us",
    "k12.ga.us",
    "k12.gu.us",
    "k12.ia.us",
    "k12.id.us",
    "k12.il.us",
    "k12.in.us",
    "k12.ks.us",
    "k12.ky.us",
    "k12.la.us",
    "k12.ma.us",
    "k12.md.us",
    "k12.me.us",
    "k12.mi.us",
    "k12.mn.us",
    "k12.mo.us",
    "k12.ms.us",
    "k12.mt.us",
    "k12.nc.us",
    "k12.ne.us",
    "k12.nh.us",
    "k12.nj.us",
    "k12.nm.us",
    "k12.nv.us",
    "k12.ny.us",
    "k12.oh.us",
    "k12.ok.us",
    "k12.or.us",
    "k12.pa.us",
    "k12.pr.us",
    "k12.ri.us",
    "k12.sc.us",
    "k12.tn.us",
    "k12.tx.us",
    "k12.ut.us",
    "k12.vi.us",
    "k12.vt.us",
    "k12.va.us",
    "k12.wa.us",
    "k12.wi.us",
    "k12.wy.us",
    "cc.ak.us",
    "cc.al.us",
    "cc.ar.us",
    "cc.as.us",
    "cc.az.us",
    "cc.ca.us",
    "cc.co.us",
    "cc.ct.us",
    "cc.dc.us",
    "cc.de.us",
    "cc.fl.us",
    "cc.ga.us",
    "cc.gu.us",
    "cc.hi.us",
    "cc.ia.us",
    "cc.id.us",
    "cc.il.us",
    "cc.in.us",
    "cc.ks.us",
    "cc.ky.us",
    "cc.la.us",
    "cc.ma.us",
    "cc.md.us",
    "cc.me.us",
    "cc.mi.us",
    "cc.mn.us",
    "cc.mo.us",
    "cc.ms.us",
    "cc.mt.us",
    "cc.nc.us",
    "cc.nd.us",
    "cc.ne.us",
    "cc.nh.us",
    "cc.nj.us",
    "cc.nm.us",
    "cc.nv.us",
    "cc.ny.us",
    "cc.oh.us",
    "cc.ok.us",
    "cc.or.us",
    "cc.pa.us",
    "cc.pr.us",
    "cc.ri.us",
    "cc.sc.us",
    "cc.sd.us",
    "cc.tn.us",
    "cc.tx.us",
    "cc.ut.us",
    "cc.vi.us",
    "cc.vt.us",
    "cc.va.us",
    "cc.wa.us",
    "cc.wi.us",
    "cc.wv.us",
    "cc.wy.us",
    "lib.ak.us",
    "lib.al.us",
    "lib.ar.us",
    "lib.as.us",
    "lib.az.us",
    "lib.ca.us",
    "lib.co.us",
    "lib.ct.us",
    "lib.dc.us",
    "lib.fl.us",
    "lib.ga.us",
    "lib.gu.us",
    "lib.hi.us",
    "lib.ia.us",
    "lib.id.us",
    "lib.il.us",
    "lib.in.us",
    "lib.ks.us",
    "lib.ky.us",
    "lib.la.us",
    "lib.ma.us",
    "lib.md.us",
    "lib.me.us",
    "lib.mi.us",
    "lib.mn.us",
    "lib.mo.us",
    "lib.ms.us",
    "lib.mt.us",
    "lib.nc.us",
    "lib.nd.us",
    "lib.ne.us",
    "lib.nh.us",
    "lib.nj.us",
    "lib.nm.us",
    "lib.nv.us",
    "lib.ny.us",
    "lib.oh.us",
    "lib.ok.us",
    "lib.or.us",
    "lib.pa.us",
    "lib.pr.us",
    "lib.ri.us",
    "lib.sc.us",
    "lib.sd.us",
    "lib.tn.us",
    "lib.tx.us",
    "lib.ut.us",
    "lib.vi.us",
    "lib.vt.us",
    "lib.va.us",
    "lib.wa.us",
    "lib.wi.us",
    "lib.wy.us",
    "pvt.k12.ma.us",
    "chtr.k12.ma.us",
    "paroch.k12.ma.us",
    "ann-arbor.mi.us",
    "cog.mi.us",
    "dst.mi.us",
    "eaton.mi.us",
    "gen.mi.us",
    "mus.mi.us",
    "tec.mi.us",
    "washtenaw.mi.us",
    "uy",
    "com.uy",
    "edu.uy",
    "gub.uy",
    "mil.uy",
    "net.uy",
    "org.uy",
    "uz",
    "co.uz",
    "com.uz",
    "net.uz",
    "org.uz",
    "va",
    "vc",
    "com.vc",
    "net.vc",
    "org.vc",
    "gov.vc",
    "mil.vc",
    "edu.vc",
    "ve",
    "arts.ve",
    "co.ve",
    "com.ve",
    "e12.ve",
    "edu.ve",
    "firm.ve",
    "gob.ve",
    "gov.ve",
    "info.ve",
    "int.ve",
    "mil.ve",
    "net.ve",
    "org.ve",
    "rec.ve",
    "store.ve",
    "tec.ve",
    "web.ve",
    "vg",
    "vi",
    "co.vi",
    "com.vi",
    "k12.vi",
    "net.vi",
    "org.vi",
    "vn",
    "com.vn",
    "net.vn",
    "org.vn",
    "edu.vn",
    "gov.vn",
    "int.vn",
    "ac.vn",
    "biz.vn",
    "info.vn",
    "name.vn",
    "pro.vn",
    "health.vn",
    "vu",
    "com.vu",
    "edu.vu",
    "net.vu",
    "org.vu",
    "wf",
    "ws",
    "com.ws",
    "net.ws",
    "org.ws",
    "gov.ws",
    "edu.ws",
    "yt",
    "\u0627\u0645\u0627\u0631\u0627\u062A",
    "\u0570\u0561\u0575",
    "\u09AC\u09BE\u0982\u09B2\u09BE",
    "\u0431\u0433",
    "\u0431\u0435\u043B",
    "\u4E2D\u56FD",
    "\u4E2D\u570B",
    "\u0627\u0644\u062C\u0632\u0627\u0626\u0631",
    "\u0645\u0635\u0631",
    "\u0435\u044E",
    "\u03B5\u03C5",
    "\u0645\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u0627",
    "\u10D2\u10D4",
    "\u03B5\u03BB",
    "\u9999\u6E2F",
    "\u516C\u53F8.\u9999\u6E2F",
    "\u6559\u80B2.\u9999\u6E2F",
    "\u653F\u5E9C.\u9999\u6E2F",
    "\u500B\u4EBA.\u9999\u6E2F",
    "\u7DB2\u7D61.\u9999\u6E2F",
    "\u7D44\u7E54.\u9999\u6E2F",
    "\u0CAD\u0CBE\u0CB0\u0CA4",
    "\u0B2D\u0B3E\u0B30\u0B24",
    "\u09AD\u09BE\u09F0\u09A4",
    "\u092D\u093E\u0930\u0924\u092E\u094D",
    "\u092D\u093E\u0930\u094B\u0924",
    "\u0680\u0627\u0631\u062A",
    "\u0D2D\u0D3E\u0D30\u0D24\u0D02",
    "\u092D\u093E\u0930\u0924",
    "\u0628\u0627\u0631\u062A",
    "\u0628\u06BE\u0627\u0631\u062A",
    "\u0C2D\u0C3E\u0C30\u0C24\u0C4D",
    "\u0AAD\u0ABE\u0AB0\u0AA4",
    "\u0A2D\u0A3E\u0A30\u0A24",
    "\u09AD\u09BE\u09B0\u09A4",
    "\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE",
    "\u0627\u06CC\u0631\u0627\u0646",
    "\u0627\u064A\u0631\u0627\u0646",
    "\u0639\u0631\u0627\u0642",
    "\u0627\u0644\u0627\u0631\u062F\u0646",
    "\uD55C\uAD6D",
    "\u049B\u0430\u0437",
    "\u0DBD\u0D82\u0D9A\u0DCF",
    "\u0B87\u0BB2\u0B99\u0BCD\u0B95\u0BC8",
    "\u0627\u0644\u0645\u063A\u0631\u0628",
    "\u043C\u043A\u0434",
    "\u043C\u043E\u043D",
    "\u6FB3\u9580",
    "\u6FB3\u95E8",
    "\u0645\u0644\u064A\u0633\u064A\u0627",
    "\u0639\u0645\u0627\u0646",
    "\u067E\u0627\u06A9\u0633\u062A\u0627\u0646",
    "\u067E\u0627\u0643\u0633\u062A\u0627\u0646",
    "\u0641\u0644\u0633\u0637\u064A\u0646",
    "\u0441\u0440\u0431",
    "\u043F\u0440.\u0441\u0440\u0431",
    "\u043E\u0440\u0433.\u0441\u0440\u0431",
    "\u043E\u0431\u0440.\u0441\u0440\u0431",
    "\u043E\u0434.\u0441\u0440\u0431",
    "\u0443\u043F\u0440.\u0441\u0440\u0431",
    "\u0430\u043A.\u0441\u0440\u0431",
    "\u0440\u0444",
    "\u0642\u0637\u0631",
    "\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629",
    "\u0627\u0644\u0633\u0639\u0648\u062F\u06CC\u0629",
    "\u0627\u0644\u0633\u0639\u0648\u062F\u06CC\u06C3",
    "\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0647",
    "\u0633\u0648\u062F\u0627\u0646",
    "\u65B0\u52A0\u5761",
    "\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD",
    "\u0633\u0648\u0631\u064A\u0629",
    "\u0633\u0648\u0631\u064A\u0627",
    "\u0E44\u0E17\u0E22",
    "\u0E28\u0E36\u0E01\u0E29\u0E32.\u0E44\u0E17\u0E22",
    "\u0E18\u0E38\u0E23\u0E01\u0E34\u0E08.\u0E44\u0E17\u0E22",
    "\u0E23\u0E31\u0E10\u0E1A\u0E32\u0E25.\u0E44\u0E17\u0E22",
    "\u0E17\u0E2B\u0E32\u0E23.\u0E44\u0E17\u0E22",
    "\u0E40\u0E19\u0E47\u0E15.\u0E44\u0E17\u0E22",
    "\u0E2D\u0E07\u0E04\u0E4C\u0E01\u0E23.\u0E44\u0E17\u0E22",
    "\u062A\u0648\u0646\u0633",
    "\u53F0\u7063",
    "\u53F0\u6E7E",
    "\u81FA\u7063",
    "\u0443\u043A\u0440",
    "\u0627\u0644\u064A\u0645\u0646",
    "xxx",
    "*.ye",
    "ac.za",
    "agric.za",
    "alt.za",
    "co.za",
    "edu.za",
    "gov.za",
    "grondar.za",
    "law.za",
    "mil.za",
    "net.za",
    "ngo.za",
    "nic.za",
    "nis.za",
    "nom.za",
    "org.za",
    "school.za",
    "tm.za",
    "web.za",
    "zm",
    "ac.zm",
    "biz.zm",
    "co.zm",
    "com.zm",
    "edu.zm",
    "gov.zm",
    "info.zm",
    "mil.zm",
    "net.zm",
    "org.zm",
    "sch.zm",
    "zw",
    "ac.zw",
    "co.zw",
    "gov.zw",
    "mil.zw",
    "org.zw",
    "aaa",
    "aarp",
    "abarth",
    "abb",
    "abbott",
    "abbvie",
    "abc",
    "able",
    "abogado",
    "abudhabi",
    "academy",
    "accenture",
    "accountant",
    "accountants",
    "aco",
    "actor",
    "adac",
    "ads",
    "adult",
    "aeg",
    "aetna",
    "afamilycompany",
    "afl",
    "africa",
    "agakhan",
    "agency",
    "aig",
    "aigo",
    "airbus",
    "airforce",
    "airtel",
    "akdn",
    "alfaromeo",
    "alibaba",
    "alipay",
    "allfinanz",
    "allstate",
    "ally",
    "alsace",
    "alstom",
    "amazon",
    "americanexpress",
    "americanfamily",
    "amex",
    "amfam",
    "amica",
    "amsterdam",
    "analytics",
    "android",
    "anquan",
    "anz",
    "aol",
    "apartments",
    "app",
    "apple",
    "aquarelle",
    "arab",
    "aramco",
    "archi",
    "army",
    "art",
    "arte",
    "asda",
    "associates",
    "athleta",
    "attorney",
    "auction",
    "audi",
    "audible",
    "audio",
    "auspost",
    "author",
    "auto",
    "autos",
    "avianca",
    "aws",
    "axa",
    "azure",
    "baby",
    "baidu",
    "banamex",
    "bananarepublic",
    "band",
    "bank",
    "bar",
    "barcelona",
    "barclaycard",
    "barclays",
    "barefoot",
    "bargains",
    "baseball",
    "basketball",
    "bauhaus",
    "bayern",
    "bbc",
    "bbt",
    "bbva",
    "bcg",
    "bcn",
    "beats",
    "beauty",
    "beer",
    "bentley",
    "berlin",
    "best",
    "bestbuy",
    "bet",
    "bharti",
    "bible",
    "bid",
    "bike",
    "bing",
    "bingo",
    "bio",
    "black",
    "blackfriday",
    "blockbuster",
    "blog",
    "bloomberg",
    "blue",
    "bms",
    "bmw",
    "bnpparibas",
    "boats",
    "boehringer",
    "bofa",
    "bom",
    "bond",
    "boo",
    "book",
    "booking",
    "bosch",
    "bostik",
    "boston",
    "bot",
    "boutique",
    "box",
    "bradesco",
    "bridgestone",
    "broadway",
    "broker",
    "brother",
    "brussels",
    "budapest",
    "bugatti",
    "build",
    "builders",
    "business",
    "buy",
    "buzz",
    "bzh",
    "cab",
    "cafe",
    "cal",
    "call",
    "calvinklein",
    "cam",
    "camera",
    "camp",
    "cancerresearch",
    "canon",
    "capetown",
    "capital",
    "capitalone",
    "car",
    "caravan",
    "cards",
    "care",
    "career",
    "careers",
    "cars",
    "casa",
    "case",
    "caseih",
    "cash",
    "casino",
    "catering",
    "catholic",
    "cba",
    "cbn",
    "cbre",
    "cbs",
    "ceb",
    "center",
    "ceo",
    "cern",
    "cfa",
    "cfd",
    "chanel",
    "channel",
    "charity",
    "chase",
    "chat",
    "cheap",
    "chintai",
    "christmas",
    "chrome",
    "church",
    "cipriani",
    "circle",
    "cisco",
    "citadel",
    "citi",
    "citic",
    "city",
    "cityeats",
    "claims",
    "cleaning",
    "click",
    "clinic",
    "clinique",
    "clothing",
    "cloud",
    "club",
    "clubmed",
    "coach",
    "codes",
    "coffee",
    "college",
    "cologne",
    "comcast",
    "commbank",
    "community",
    "company",
    "compare",
    "computer",
    "comsec",
    "condos",
    "construction",
    "consulting",
    "contact",
    "contractors",
    "cooking",
    "cookingchannel",
    "cool",
    "corsica",
    "country",
    "coupon",
    "coupons",
    "courses",
    "cpa",
    "credit",
    "creditcard",
    "creditunion",
    "cricket",
    "crown",
    "crs",
    "cruise",
    "cruises",
    "csc",
    "cuisinella",
    "cymru",
    "cyou",
    "dabur",
    "dad",
    "dance",
    "data",
    "date",
    "dating",
    "datsun",
    "day",
    "dclk",
    "dds",
    "deal",
    "dealer",
    "deals",
    "degree",
    "delivery",
    "dell",
    "deloitte",
    "delta",
    "democrat",
    "dental",
    "dentist",
    "desi",
    "design",
    "dev",
    "dhl",
    "diamonds",
    "diet",
    "digital",
    "direct",
    "directory",
    "discount",
    "discover",
    "dish",
    "diy",
    "dnp",
    "docs",
    "doctor",
    "dog",
    "domains",
    "dot",
    "download",
    "drive",
    "dtv",
    "dubai",
    "duck",
    "dunlop",
    "dupont",
    "durban",
    "dvag",
    "dvr",
    "earth",
    "eat",
    "eco",
    "edeka",
    "education",
    "email",
    "emerck",
    "energy",
    "engineer",
    "engineering",
    "enterprises",
    "epson",
    "equipment",
    "ericsson",
    "erni",
    "esq",
    "estate",
    "esurance",
    "etisalat",
    "eurovision",
    "eus",
    "events",
    "exchange",
    "expert",
    "exposed",
    "express",
    "extraspace",
    "fage",
    "fail",
    "fairwinds",
    "faith",
    "family",
    "fan",
    "fans",
    "farm",
    "farmers",
    "fashion",
    "fast",
    "fedex",
    "feedback",
    "ferrari",
    "ferrero",
    "fiat",
    "fidelity",
    "fido",
    "film",
    "final",
    "finance",
    "financial",
    "fire",
    "firestone",
    "firmdale",
    "fish",
    "fishing",
    "fit",
    "fitness",
    "flickr",
    "flights",
    "flir",
    "florist",
    "flowers",
    "fly",
    "foo",
    "food",
    "foodnetwork",
    "football",
    "ford",
    "forex",
    "forsale",
    "forum",
    "foundation",
    "fox",
    "free",
    "fresenius",
    "frl",
    "frogans",
    "frontdoor",
    "frontier",
    "ftr",
    "fujitsu",
    "fujixerox",
    "fun",
    "fund",
    "furniture",
    "futbol",
    "fyi",
    "gal",
    "gallery",
    "gallo",
    "gallup",
    "game",
    "games",
    "gap",
    "garden",
    "gay",
    "gbiz",
    "gdn",
    "gea",
    "gent",
    "genting",
    "george",
    "ggee",
    "gift",
    "gifts",
    "gives",
    "giving",
    "glade",
    "glass",
    "gle",
    "global",
    "globo",
    "gmail",
    "gmbh",
    "gmo",
    "gmx",
    "godaddy",
    "gold",
    "goldpoint",
    "golf",
    "goo",
    "goodyear",
    "goog",
    "google",
    "gop",
    "got",
    "grainger",
    "graphics",
    "gratis",
    "green",
    "gripe",
    "grocery",
    "group",
    "guardian",
    "gucci",
    "guge",
    "guide",
    "guitars",
    "guru",
    "hair",
    "hamburg",
    "hangout",
    "haus",
    "hbo",
    "hdfc",
    "hdfcbank",
    "health",
    "healthcare",
    "help",
    "helsinki",
    "here",
    "hermes",
    "hgtv",
    "hiphop",
    "hisamitsu",
    "hitachi",
    "hiv",
    "hkt",
    "hockey",
    "holdings",
    "holiday",
    "homedepot",
    "homegoods",
    "homes",
    "homesense",
    "honda",
    "horse",
    "hospital",
    "host",
    "hosting",
    "hot",
    "hoteles",
    "hotels",
    "hotmail",
    "house",
    "how",
    "hsbc",
    "hughes",
    "hyatt",
    "hyundai",
    "ibm",
    "icbc",
    "ice",
    "icu",
    "ieee",
    "ifm",
    "ikano",
    "imamat",
    "imdb",
    "immo",
    "immobilien",
    "inc",
    "industries",
    "infiniti",
    "ing",
    "ink",
    "institute",
    "insurance",
    "insure",
    "intel",
    "international",
    "intuit",
    "investments",
    "ipiranga",
    "irish",
    "ismaili",
    "ist",
    "istanbul",
    "itau",
    "itv",
    "iveco",
    "jaguar",
    "java",
    "jcb",
    "jcp",
    "jeep",
    "jetzt",
    "jewelry",
    "jio",
    "jll",
    "jmp",
    "jnj",
    "joburg",
    "jot",
    "joy",
    "jpmorgan",
    "jprs",
    "juegos",
    "juniper",
    "kaufen",
    "kddi",
    "kerryhotels",
    "kerrylogistics",
    "kerryproperties",
    "kfh",
    "kia",
    "kim",
    "kinder",
    "kindle",
    "kitchen",
    "kiwi",
    "koeln",
    "komatsu",
    "kosher",
    "kpmg",
    "kpn",
    "krd",
    "kred",
    "kuokgroup",
    "kyoto",
    "lacaixa",
    "lamborghini",
    "lamer",
    "lancaster",
    "lancia",
    "land",
    "landrover",
    "lanxess",
    "lasalle",
    "lat",
    "latino",
    "latrobe",
    "law",
    "lawyer",
    "lds",
    "lease",
    "leclerc",
    "lefrak",
    "legal",
    "lego",
    "lexus",
    "lgbt",
    "lidl",
    "life",
    "lifeinsurance",
    "lifestyle",
    "lighting",
    "like",
    "lilly",
    "limited",
    "limo",
    "lincoln",
    "linde",
    "link",
    "lipsy",
    "live",
    "living",
    "lixil",
    "llc",
    "llp",
    "loan",
    "loans",
    "locker",
    "locus",
    "loft",
    "lol",
    "london",
    "lotte",
    "lotto",
    "love",
    "lpl",
    "lplfinancial",
    "ltd",
    "ltda",
    "lundbeck",
    "lupin",
    "luxe",
    "luxury",
    "macys",
    "madrid",
    "maif",
    "maison",
    "makeup",
    "man",
    "management",
    "mango",
    "map",
    "market",
    "marketing",
    "markets",
    "marriott",
    "marshalls",
    "maserati",
    "mattel",
    "mba",
    "mckinsey",
    "med",
    "media",
    "meet",
    "melbourne",
    "meme",
    "memorial",
    "men",
    "menu",
    "merckmsd",
    "metlife",
    "miami",
    "microsoft",
    "mini",
    "mint",
    "mit",
    "mitsubishi",
    "mlb",
    "mls",
    "mma",
    "mobile",
    "moda",
    "moe",
    "moi",
    "mom",
    "monash",
    "money",
    "monster",
    "mormon",
    "mortgage",
    "moscow",
    "moto",
    "motorcycles",
    "mov",
    "movie",
    "msd",
    "mtn",
    "mtr",
    "mutual",
    "nab",
    "nadex",
    "nagoya",
    "nationwide",
    "natura",
    "navy",
    "nba",
    "nec",
    "netbank",
    "netflix",
    "network",
    "neustar",
    "new",
    "newholland",
    "news",
    "next",
    "nextdirect",
    "nexus",
    "nfl",
    "ngo",
    "nhk",
    "nico",
    "nike",
    "nikon",
    "ninja",
    "nissan",
    "nissay",
    "nokia",
    "northwesternmutual",
    "norton",
    "now",
    "nowruz",
    "nowtv",
    "nra",
    "nrw",
    "ntt",
    "nyc",
    "obi",
    "observer",
    "off",
    "office",
    "okinawa",
    "olayan",
    "olayangroup",
    "oldnavy",
    "ollo",
    "omega",
    "one",
    "ong",
    "onl",
    "online",
    "onyourside",
    "ooo",
    "open",
    "oracle",
    "orange",
    "organic",
    "origins",
    "osaka",
    "otsuka",
    "ott",
    "ovh",
    "page",
    "panasonic",
    "paris",
    "pars",
    "partners",
    "parts",
    "party",
    "passagens",
    "pay",
    "pccw",
    "pet",
    "pfizer",
    "pharmacy",
    "phd",
    "philips",
    "phone",
    "photo",
    "photography",
    "photos",
    "physio",
    "pics",
    "pictet",
    "pictures",
    "pid",
    "pin",
    "ping",
    "pink",
    "pioneer",
    "pizza",
    "place",
    "play",
    "playstation",
    "plumbing",
    "plus",
    "pnc",
    "pohl",
    "poker",
    "politie",
    "porn",
    "pramerica",
    "praxi",
    "press",
    "prime",
    "prod",
    "productions",
    "prof",
    "progressive",
    "promo",
    "properties",
    "property",
    "protection",
    "pru",
    "prudential",
    "pub",
    "pwc",
    "qpon",
    "quebec",
    "quest",
    "qvc",
    "racing",
    "radio",
    "raid",
    "read",
    "realestate",
    "realtor",
    "realty",
    "recipes",
    "red",
    "redstone",
    "redumbrella",
    "rehab",
    "reise",
    "reisen",
    "reit",
    "reliance",
    "ren",
    "rent",
    "rentals",
    "repair",
    "report",
    "republican",
    "rest",
    "restaurant",
    "review",
    "reviews",
    "rexroth",
    "rich",
    "richardli",
    "ricoh",
    "rightathome",
    "ril",
    "rio",
    "rip",
    "rmit",
    "rocher",
    "rocks",
    "rodeo",
    "rogers",
    "room",
    "rsvp",
    "rugby",
    "ruhr",
    "run",
    "rwe",
    "ryukyu",
    "saarland",
    "safe",
    "safety",
    "sakura",
    "sale",
    "salon",
    "samsclub",
    "samsung",
    "sandvik",
    "sandvikcoromant",
    "sanofi",
    "sap",
    "sarl",
    "sas",
    "save",
    "saxo",
    "sbi",
    "sbs",
    "sca",
    "scb",
    "schaeffler",
    "schmidt",
    "scholarships",
    "school",
    "schule",
    "schwarz",
    "science",
    "scjohnson",
    "scor",
    "scot",
    "search",
    "seat",
    "secure",
    "security",
    "seek",
    "select",
    "sener",
    "services",
    "ses",
    "seven",
    "sew",
    "sex",
    "sexy",
    "sfr",
    "shangrila",
    "sharp",
    "shaw",
    "shell",
    "shia",
    "shiksha",
    "shoes",
    "shop",
    "shopping",
    "shouji",
    "show",
    "showtime",
    "shriram",
    "silk",
    "sina",
    "singles",
    "site",
    "ski",
    "skin",
    "sky",
    "skype",
    "sling",
    "smart",
    "smile",
    "sncf",
    "soccer",
    "social",
    "softbank",
    "software",
    "sohu",
    "solar",
    "solutions",
    "song",
    "sony",
    "soy",
    "spa",
    "space",
    "sport",
    "spot",
    "spreadbetting",
    "srl",
    "stada",
    "staples",
    "star",
    "statebank",
    "statefarm",
    "stc",
    "stcgroup",
    "stockholm",
    "storage",
    "store",
    "stream",
    "studio",
    "study",
    "style",
    "sucks",
    "supplies",
    "supply",
    "support",
    "surf",
    "surgery",
    "suzuki",
    "swatch",
    "swiftcover",
    "swiss",
    "sydney",
    "symantec",
    "systems",
    "tab",
    "taipei",
    "talk",
    "taobao",
    "target",
    "tatamotors",
    "tatar",
    "tattoo",
    "tax",
    "taxi",
    "tci",
    "tdk",
    "team",
    "tech",
    "technology",
    "temasek",
    "tennis",
    "teva",
    "thd",
    "theater",
    "theatre",
    "tiaa",
    "tickets",
    "tienda",
    "tiffany",
    "tips",
    "tires",
    "tirol",
    "tjmaxx",
    "tjx",
    "tkmaxx",
    "tmall",
    "today",
    "tokyo",
    "tools",
    "top",
    "toray",
    "toshiba",
    "total",
    "tours",
    "town",
    "toyota",
    "toys",
    "trade",
    "trading",
    "training",
    "travel",
    "travelchannel",
    "travelers",
    "travelersinsurance",
    "trust",
    "trv",
    "tube",
    "tui",
    "tunes",
    "tushu",
    "tvs",
    "ubank",
    "ubs",
    "unicom",
    "university",
    "uno",
    "uol",
    "ups",
    "vacations",
    "vana",
    "vanguard",
    "vegas",
    "ventures",
    "verisign",
    "versicherung",
    "vet",
    "viajes",
    "video",
    "vig",
    "viking",
    "villas",
    "vin",
    "vip",
    "virgin",
    "visa",
    "vision",
    "viva",
    "vivo",
    "vlaanderen",
    "vodka",
    "volkswagen",
    "volvo",
    "vote",
    "voting",
    "voto",
    "voyage",
    "vuelos",
    "wales",
    "walmart",
    "walter",
    "wang",
    "wanggou",
    "watch",
    "watches",
    "weather",
    "weatherchannel",
    "webcam",
    "weber",
    "website",
    "wed",
    "wedding",
    "weibo",
    "weir",
    "whoswho",
    "wien",
    "wiki",
    "williamhill",
    "win",
    "windows",
    "wine",
    "winners",
    "wme",
    "wolterskluwer",
    "woodside",
    "work",
    "works",
    "world",
    "wow",
    "wtc",
    "wtf",
    "xbox",
    "xerox",
    "xfinity",
    "xihuan",
    "xin",
    "\u0915\u0949\u092E",
    "\u30BB\u30FC\u30EB",
    "\u4F5B\u5C71",
    "\u6148\u5584",
    "\u96C6\u56E2",
    "\u5728\u7EBF",
    "\u5927\u4F17\u6C7D\u8F66",
    "\u70B9\u770B",
    "\u0E04\u0E2D\u0E21",
    "\u516B\u5366",
    "\u0645\u0648\u0642\u0639",
    "\u516C\u76CA",
    "\u516C\u53F8",
    "\u9999\u683C\u91CC\u62C9",
    "\u7F51\u7AD9",
    "\u79FB\u52A8",
    "\u6211\u7231\u4F60",
    "\u043C\u043E\u0441\u043A\u0432\u0430",
    "\u043A\u0430\u0442\u043E\u043B\u0438\u043A",
    "\u043E\u043D\u043B\u0430\u0439\u043D",
    "\u0441\u0430\u0439\u0442",
    "\u8054\u901A",
    "\u05E7\u05D5\u05DD",
    "\u65F6\u5C1A",
    "\u5FAE\u535A",
    "\u6DE1\u9A6C\u9521",
    "\u30D5\u30A1\u30C3\u30B7\u30E7\u30F3",
    "\u043E\u0440\u0433",
    "\u0928\u0947\u091F",
    "\u30B9\u30C8\u30A2",
    "\u30A2\u30DE\u30BE\u30F3",
    "\uC0BC\uC131",
    "\u5546\u6807",
    "\u5546\u5E97",
    "\u5546\u57CE",
    "\u0434\u0435\u0442\u0438",
    "\u30DD\u30A4\u30F3\u30C8",
    "\u65B0\u95FB",
    "\u5DE5\u884C",
    "\u5BB6\u96FB",
    "\u0643\u0648\u0645",
    "\u4E2D\u6587\u7F51",
    "\u4E2D\u4FE1",
    "\u5A31\u4E50",
    "\u8C37\u6B4C",
    "\u96FB\u8A0A\u76C8\u79D1",
    "\u8D2D\u7269",
    "\u30AF\u30E9\u30A6\u30C9",
    "\u901A\u8CA9",
    "\u7F51\u5E97",
    "\u0938\u0902\u0917\u0920\u0928",
    "\u9910\u5385",
    "\u7F51\u7EDC",
    "\u043A\u043E\u043C",
    "\u4E9A\u9A6C\u900A",
    "\u8BFA\u57FA\u4E9A",
    "\u98DF\u54C1",
    "\u98DE\u5229\u6D66",
    "\u624B\u8868",
    "\u624B\u673A",
    "\u0627\u0631\u0627\u0645\u0643\u0648",
    "\u0627\u0644\u0639\u0644\u064A\u0627\u0646",
    "\u0627\u062A\u0635\u0627\u0644\u0627\u062A",
    "\u0628\u0627\u0632\u0627\u0631",
    "\u0627\u0628\u0648\u0638\u0628\u064A",
    "\u0643\u0627\u062B\u0648\u0644\u064A\u0643",
    "\u0647\u0645\u0631\u0627\u0647",
    "\uB2F7\uCEF4",
    "\u653F\u5E9C",
    "\u0634\u0628\u0643\u0629",
    "\u0628\u064A\u062A\u0643",
    "\u0639\u0631\u0628",
    "\u673A\u6784",
    "\u7EC4\u7EC7\u673A\u6784",
    "\u5065\u5EB7",
    "\u62DB\u8058",
    "\u0440\u0443\u0441",
    "\u73E0\u5B9D",
    "\u5927\u62FF",
    "\u307F\u3093\u306A",
    "\u30B0\u30FC\u30B0\u30EB",
    "\u4E16\u754C",
    "\u66F8\u7C4D",
    "\u7F51\u5740",
    "\uB2F7\uB137",
    "\u30B3\u30E0",
    "\u5929\u4E3B\u6559",
    "\u6E38\u620F",
    "verm\xF6gensberater",
    "verm\xF6gensberatung",
    "\u4F01\u4E1A",
    "\u4FE1\u606F",
    "\u5609\u91CC\u5927\u9152\u5E97",
    "\u5609\u91CC",
    "\u5E7F\u4E1C",
    "\u653F\u52A1",
    "xyz",
    "yachts",
    "yahoo",
    "yamaxun",
    "yandex",
    "yodobashi",
    "yoga",
    "yokohama",
    "you",
    "youtube",
    "yun",
    "zappos",
    "zara",
    "zero",
    "zip",
    "zone",
    "zuerich",
    "cc.ua",
    "inf.ua",
    "ltd.ua",
    "adobeaemcloud.com",
    "adobeaemcloud.net",
    "*.dev.adobeaemcloud.com",
    "beep.pl",
    "barsy.ca",
    "*.compute.estate",
    "*.alces.network",
    "altervista.org",
    "alwaysdata.net",
    "cloudfront.net",
    "*.compute.amazonaws.com",
    "*.compute-1.amazonaws.com",
    "*.compute.amazonaws.com.cn",
    "us-east-1.amazonaws.com",
    "cn-north-1.eb.amazonaws.com.cn",
    "cn-northwest-1.eb.amazonaws.com.cn",
    "elasticbeanstalk.com",
    "ap-northeast-1.elasticbeanstalk.com",
    "ap-northeast-2.elasticbeanstalk.com",
    "ap-northeast-3.elasticbeanstalk.com",
    "ap-south-1.elasticbeanstalk.com",
    "ap-southeast-1.elasticbeanstalk.com",
    "ap-southeast-2.elasticbeanstalk.com",
    "ca-central-1.elasticbeanstalk.com",
    "eu-central-1.elasticbeanstalk.com",
    "eu-west-1.elasticbeanstalk.com",
    "eu-west-2.elasticbeanstalk.com",
    "eu-west-3.elasticbeanstalk.com",
    "sa-east-1.elasticbeanstalk.com",
    "us-east-1.elasticbeanstalk.com",
    "us-east-2.elasticbeanstalk.com",
    "us-gov-west-1.elasticbeanstalk.com",
    "us-west-1.elasticbeanstalk.com",
    "us-west-2.elasticbeanstalk.com",
    "*.elb.amazonaws.com",
    "*.elb.amazonaws.com.cn",
    "s3.amazonaws.com",
    "s3-ap-northeast-1.amazonaws.com",
    "s3-ap-northeast-2.amazonaws.com",
    "s3-ap-south-1.amazonaws.com",
    "s3-ap-southeast-1.amazonaws.com",
    "s3-ap-southeast-2.amazonaws.com",
    "s3-ca-central-1.amazonaws.com",
    "s3-eu-central-1.amazonaws.com",
    "s3-eu-west-1.amazonaws.com",
    "s3-eu-west-2.amazonaws.com",
    "s3-eu-west-3.amazonaws.com",
    "s3-external-1.amazonaws.com",
    "s3-fips-us-gov-west-1.amazonaws.com",
    "s3-sa-east-1.amazonaws.com",
    "s3-us-gov-west-1.amazonaws.com",
    "s3-us-east-2.amazonaws.com",
    "s3-us-west-1.amazonaws.com",
    "s3-us-west-2.amazonaws.com",
    "s3.ap-northeast-2.amazonaws.com",
    "s3.ap-south-1.amazonaws.com",
    "s3.cn-north-1.amazonaws.com.cn",
    "s3.ca-central-1.amazonaws.com",
    "s3.eu-central-1.amazonaws.com",
    "s3.eu-west-2.amazonaws.com",
    "s3.eu-west-3.amazonaws.com",
    "s3.us-east-2.amazonaws.com",
    "s3.dualstack.ap-northeast-1.amazonaws.com",
    "s3.dualstack.ap-northeast-2.amazonaws.com",
    "s3.dualstack.ap-south-1.amazonaws.com",
    "s3.dualstack.ap-southeast-1.amazonaws.com",
    "s3.dualstack.ap-southeast-2.amazonaws.com",
    "s3.dualstack.ca-central-1.amazonaws.com",
    "s3.dualstack.eu-central-1.amazonaws.com",
    "s3.dualstack.eu-west-1.amazonaws.com",
    "s3.dualstack.eu-west-2.amazonaws.com",
    "s3.dualstack.eu-west-3.amazonaws.com",
    "s3.dualstack.sa-east-1.amazonaws.com",
    "s3.dualstack.us-east-1.amazonaws.com",
    "s3.dualstack.us-east-2.amazonaws.com",
    "s3-website-us-east-1.amazonaws.com",
    "s3-website-us-west-1.amazonaws.com",
    "s3-website-us-west-2.amazonaws.com",
    "s3-website-ap-northeast-1.amazonaws.com",
    "s3-website-ap-southeast-1.amazonaws.com",
    "s3-website-ap-southeast-2.amazonaws.com",
    "s3-website-eu-west-1.amazonaws.com",
    "s3-website-sa-east-1.amazonaws.com",
    "s3-website.ap-northeast-2.amazonaws.com",
    "s3-website.ap-south-1.amazonaws.com",
    "s3-website.ca-central-1.amazonaws.com",
    "s3-website.eu-central-1.amazonaws.com",
    "s3-website.eu-west-2.amazonaws.com",
    "s3-website.eu-west-3.amazonaws.com",
    "s3-website.us-east-2.amazonaws.com",
    "amsw.nl",
    "t3l3p0rt.net",
    "tele.amune.org",
    "apigee.io",
    "on-aptible.com",
    "user.aseinet.ne.jp",
    "gv.vc",
    "d.gv.vc",
    "user.party.eus",
    "pimienta.org",
    "poivron.org",
    "potager.org",
    "sweetpepper.org",
    "myasustor.com",
    "myfritz.net",
    "*.awdev.ca",
    "*.advisor.ws",
    "b-data.io",
    "backplaneapp.io",
    "balena-devices.com",
    "app.banzaicloud.io",
    "betainabox.com",
    "bnr.la",
    "blackbaudcdn.net",
    "boomla.net",
    "boxfuse.io",
    "square7.ch",
    "bplaced.com",
    "bplaced.de",
    "square7.de",
    "bplaced.net",
    "square7.net",
    "browsersafetymark.io",
    "uk0.bigv.io",
    "dh.bytemark.co.uk",
    "vm.bytemark.co.uk",
    "mycd.eu",
    "carrd.co",
    "crd.co",
    "uwu.ai",
    "ae.org",
    "ar.com",
    "br.com",
    "cn.com",
    "com.de",
    "com.se",
    "de.com",
    "eu.com",
    "gb.com",
    "gb.net",
    "hu.com",
    "hu.net",
    "jp.net",
    "jpn.com",
    "kr.com",
    "mex.com",
    "no.com",
    "qc.com",
    "ru.com",
    "sa.com",
    "se.net",
    "uk.com",
    "uk.net",
    "us.com",
    "uy.com",
    "za.bz",
    "za.com",
    "africa.com",
    "gr.com",
    "in.net",
    "us.org",
    "co.com",
    "c.la",
    "certmgr.org",
    "xenapponazure.com",
    "discourse.group",
    "discourse.team",
    "virtueeldomein.nl",
    "cleverapps.io",
    "*.lcl.dev",
    "*.stg.dev",
    "c66.me",
    "cloud66.ws",
    "cloud66.zone",
    "jdevcloud.com",
    "wpdevcloud.com",
    "cloudaccess.host",
    "freesite.host",
    "cloudaccess.net",
    "cloudcontrolled.com",
    "cloudcontrolapp.com",
    "cloudera.site",
    "trycloudflare.com",
    "workers.dev",
    "wnext.app",
    "co.ca",
    "*.otap.co",
    "co.cz",
    "c.cdn77.org",
    "cdn77-ssl.net",
    "r.cdn77.net",
    "rsc.cdn77.org",
    "ssl.origin.cdn77-secure.org",
    "cloudns.asia",
    "cloudns.biz",
    "cloudns.club",
    "cloudns.cc",
    "cloudns.eu",
    "cloudns.in",
    "cloudns.info",
    "cloudns.org",
    "cloudns.pro",
    "cloudns.pw",
    "cloudns.us",
    "cloudeity.net",
    "cnpy.gdn",
    "co.nl",
    "co.no",
    "webhosting.be",
    "hosting-cluster.nl",
    "ac.ru",
    "edu.ru",
    "gov.ru",
    "int.ru",
    "mil.ru",
    "test.ru",
    "dyn.cosidns.de",
    "dynamisches-dns.de",
    "dnsupdater.de",
    "internet-dns.de",
    "l-o-g-i-n.de",
    "dynamic-dns.info",
    "feste-ip.net",
    "knx-server.net",
    "static-access.net",
    "realm.cz",
    "*.cryptonomic.net",
    "cupcake.is",
    "*.customer-oci.com",
    "*.oci.customer-oci.com",
    "*.ocp.customer-oci.com",
    "*.ocs.customer-oci.com",
    "cyon.link",
    "cyon.site",
    "daplie.me",
    "localhost.daplie.me",
    "dattolocal.com",
    "dattorelay.com",
    "dattoweb.com",
    "mydatto.com",
    "dattolocal.net",
    "mydatto.net",
    "biz.dk",
    "co.dk",
    "firm.dk",
    "reg.dk",
    "store.dk",
    "*.dapps.earth",
    "*.bzz.dapps.earth",
    "builtwithdark.com",
    "edgestack.me",
    "debian.net",
    "dedyn.io",
    "dnshome.de",
    "online.th",
    "shop.th",
    "drayddns.com",
    "dreamhosters.com",
    "mydrobo.com",
    "drud.io",
    "drud.us",
    "duckdns.org",
    "dy.fi",
    "tunk.org",
    "dyndns-at-home.com",
    "dyndns-at-work.com",
    "dyndns-blog.com",
    "dyndns-free.com",
    "dyndns-home.com",
    "dyndns-ip.com",
    "dyndns-mail.com",
    "dyndns-office.com",
    "dyndns-pics.com",
    "dyndns-remote.com",
    "dyndns-server.com",
    "dyndns-web.com",
    "dyndns-wiki.com",
    "dyndns-work.com",
    "dyndns.biz",
    "dyndns.info",
    "dyndns.org",
    "dyndns.tv",
    "at-band-camp.net",
    "ath.cx",
    "barrel-of-knowledge.info",
    "barrell-of-knowledge.info",
    "better-than.tv",
    "blogdns.com",
    "blogdns.net",
    "blogdns.org",
    "blogsite.org",
    "boldlygoingnowhere.org",
    "broke-it.net",
    "buyshouses.net",
    "cechire.com",
    "dnsalias.com",
    "dnsalias.net",
    "dnsalias.org",
    "dnsdojo.com",
    "dnsdojo.net",
    "dnsdojo.org",
    "does-it.net",
    "doesntexist.com",
    "doesntexist.org",
    "dontexist.com",
    "dontexist.net",
    "dontexist.org",
    "doomdns.com",
    "doomdns.org",
    "dvrdns.org",
    "dyn-o-saur.com",
    "dynalias.com",
    "dynalias.net",
    "dynalias.org",
    "dynathome.net",
    "dyndns.ws",
    "endofinternet.net",
    "endofinternet.org",
    "endoftheinternet.org",
    "est-a-la-maison.com",
    "est-a-la-masion.com",
    "est-le-patron.com",
    "est-mon-blogueur.com",
    "for-better.biz",
    "for-more.biz",
    "for-our.info",
    "for-some.biz",
    "for-the.biz",
    "forgot.her.name",
    "forgot.his.name",
    "from-ak.com",
    "from-al.com",
    "from-ar.com",
    "from-az.net",
    "from-ca.com",
    "from-co.net",
    "from-ct.com",
    "from-dc.com",
    "from-de.com",
    "from-fl.com",
    "from-ga.com",
    "from-hi.com",
    "from-ia.com",
    "from-id.com",
    "from-il.com",
    "from-in.com",
    "from-ks.com",
    "from-ky.com",
    "from-la.net",
    "from-ma.com",
    "from-md.com",
    "from-me.org",
    "from-mi.com",
    "from-mn.com",
    "from-mo.com",
    "from-ms.com",
    "from-mt.com",
    "from-nc.com",
    "from-nd.com",
    "from-ne.com",
    "from-nh.com",
    "from-nj.com",
    "from-nm.com",
    "from-nv.com",
    "from-ny.net",
    "from-oh.com",
    "from-ok.com",
    "from-or.com",
    "from-pa.com",
    "from-pr.com",
    "from-ri.com",
    "from-sc.com",
    "from-sd.com",
    "from-tn.com",
    "from-tx.com",
    "from-ut.com",
    "from-va.com",
    "from-vt.com",
    "from-wa.com",
    "from-wi.com",
    "from-wv.com",
    "from-wy.com",
    "ftpaccess.cc",
    "fuettertdasnetz.de",
    "game-host.org",
    "game-server.cc",
    "getmyip.com",
    "gets-it.net",
    "go.dyndns.org",
    "gotdns.com",
    "gotdns.org",
    "groks-the.info",
    "groks-this.info",
    "ham-radio-op.net",
    "here-for-more.info",
    "hobby-site.com",
    "hobby-site.org",
    "home.dyndns.org",
    "homedns.org",
    "homeftp.net",
    "homeftp.org",
    "homeip.net",
    "homelinux.com",
    "homelinux.net",
    "homelinux.org",
    "homeunix.com",
    "homeunix.net",
    "homeunix.org",
    "iamallama.com",
    "in-the-band.net",
    "is-a-anarchist.com",
    "is-a-blogger.com",
    "is-a-bookkeeper.com",
    "is-a-bruinsfan.org",
    "is-a-bulls-fan.com",
    "is-a-candidate.org",
    "is-a-caterer.com",
    "is-a-celticsfan.org",
    "is-a-chef.com",
    "is-a-chef.net",
    "is-a-chef.org",
    "is-a-conservative.com",
    "is-a-cpa.com",
    "is-a-cubicle-slave.com",
    "is-a-democrat.com",
    "is-a-designer.com",
    "is-a-doctor.com",
    "is-a-financialadvisor.com",
    "is-a-geek.com",
    "is-a-geek.net",
    "is-a-geek.org",
    "is-a-green.com",
    "is-a-guru.com",
    "is-a-hard-worker.com",
    "is-a-hunter.com",
    "is-a-knight.org",
    "is-a-landscaper.com",
    "is-a-lawyer.com",
    "is-a-liberal.com",
    "is-a-libertarian.com",
    "is-a-linux-user.org",
    "is-a-llama.com",
    "is-a-musician.com",
    "is-a-nascarfan.com",
    "is-a-nurse.com",
    "is-a-painter.com",
    "is-a-patsfan.org",
    "is-a-personaltrainer.com",
    "is-a-photographer.com",
    "is-a-player.com",
    "is-a-republican.com",
    "is-a-rockstar.com",
    "is-a-socialist.com",
    "is-a-soxfan.org",
    "is-a-student.com",
    "is-a-teacher.com",
    "is-a-techie.com",
    "is-a-therapist.com",
    "is-an-accountant.com",
    "is-an-actor.com",
    "is-an-actress.com",
    "is-an-anarchist.com",
    "is-an-artist.com",
    "is-an-engineer.com",
    "is-an-entertainer.com",
    "is-by.us",
    "is-certified.com",
    "is-found.org",
    "is-gone.com",
    "is-into-anime.com",
    "is-into-cars.com",
    "is-into-cartoons.com",
    "is-into-games.com",
    "is-leet.com",
    "is-lost.org",
    "is-not-certified.com",
    "is-saved.org",
    "is-slick.com",
    "is-uberleet.com",
    "is-very-bad.org",
    "is-very-evil.org",
    "is-very-good.org",
    "is-very-nice.org",
    "is-very-sweet.org",
    "is-with-theband.com",
    "isa-geek.com",
    "isa-geek.net",
    "isa-geek.org",
    "isa-hockeynut.com",
    "issmarterthanyou.com",
    "isteingeek.de",
    "istmein.de",
    "kicks-ass.net",
    "kicks-ass.org",
    "knowsitall.info",
    "land-4-sale.us",
    "lebtimnetz.de",
    "leitungsen.de",
    "likes-pie.com",
    "likescandy.com",
    "merseine.nu",
    "mine.nu",
    "misconfused.org",
    "mypets.ws",
    "myphotos.cc",
    "neat-url.com",
    "office-on-the.net",
    "on-the-web.tv",
    "podzone.net",
    "podzone.org",
    "readmyblog.org",
    "saves-the-whales.com",
    "scrapper-site.net",
    "scrapping.cc",
    "selfip.biz",
    "selfip.com",
    "selfip.info",
    "selfip.net",
    "selfip.org",
    "sells-for-less.com",
    "sells-for-u.com",
    "sells-it.net",
    "sellsyourhome.org",
    "servebbs.com",
    "servebbs.net",
    "servebbs.org",
    "serveftp.net",
    "serveftp.org",
    "servegame.org",
    "shacknet.nu",
    "simple-url.com",
    "space-to-rent.com",
    "stuff-4-sale.org",
    "stuff-4-sale.us",
    "teaches-yoga.com",
    "thruhere.net",
    "traeumtgerade.de",
    "webhop.biz",
    "webhop.info",
    "webhop.net",
    "webhop.org",
    "worse-than.tv",
    "writesthisblog.com",
    "ddnss.de",
    "dyn.ddnss.de",
    "dyndns.ddnss.de",
    "dyndns1.de",
    "dyn-ip24.de",
    "home-webserver.de",
    "dyn.home-webserver.de",
    "myhome-server.de",
    "ddnss.org",
    "definima.net",
    "definima.io",
    "bci.dnstrace.pro",
    "ddnsfree.com",
    "ddnsgeek.com",
    "giize.com",
    "gleeze.com",
    "kozow.com",
    "loseyourip.com",
    "ooguy.com",
    "theworkpc.com",
    "casacam.net",
    "dynu.net",
    "accesscam.org",
    "camdvr.org",
    "freeddns.org",
    "mywire.org",
    "webredirect.org",
    "myddns.rocks",
    "blogsite.xyz",
    "dynv6.net",
    "e4.cz",
    "en-root.fr",
    "mytuleap.com",
    "onred.one",
    "staging.onred.one",
    "enonic.io",
    "customer.enonic.io",
    "eu.org",
    "al.eu.org",
    "asso.eu.org",
    "at.eu.org",
    "au.eu.org",
    "be.eu.org",
    "bg.eu.org",
    "ca.eu.org",
    "cd.eu.org",
    "ch.eu.org",
    "cn.eu.org",
    "cy.eu.org",
    "cz.eu.org",
    "de.eu.org",
    "dk.eu.org",
    "edu.eu.org",
    "ee.eu.org",
    "es.eu.org",
    "fi.eu.org",
    "fr.eu.org",
    "gr.eu.org",
    "hr.eu.org",
    "hu.eu.org",
    "ie.eu.org",
    "il.eu.org",
    "in.eu.org",
    "int.eu.org",
    "is.eu.org",
    "it.eu.org",
    "jp.eu.org",
    "kr.eu.org",
    "lt.eu.org",
    "lu.eu.org",
    "lv.eu.org",
    "mc.eu.org",
    "me.eu.org",
    "mk.eu.org",
    "mt.eu.org",
    "my.eu.org",
    "net.eu.org",
    "ng.eu.org",
    "nl.eu.org",
    "no.eu.org",
    "nz.eu.org",
    "paris.eu.org",
    "pl.eu.org",
    "pt.eu.org",
    "q-a.eu.org",
    "ro.eu.org",
    "ru.eu.org",
    "se.eu.org",
    "si.eu.org",
    "sk.eu.org",
    "tr.eu.org",
    "uk.eu.org",
    "us.eu.org",
    "eu-1.evennode.com",
    "eu-2.evennode.com",
    "eu-3.evennode.com",
    "eu-4.evennode.com",
    "us-1.evennode.com",
    "us-2.evennode.com",
    "us-3.evennode.com",
    "us-4.evennode.com",
    "twmail.cc",
    "twmail.net",
    "twmail.org",
    "mymailer.com.tw",
    "url.tw",
    "apps.fbsbx.com",
    "ru.net",
    "adygeya.ru",
    "bashkiria.ru",
    "bir.ru",
    "cbg.ru",
    "com.ru",
    "dagestan.ru",
    "grozny.ru",
    "kalmykia.ru",
    "kustanai.ru",
    "marine.ru",
    "mordovia.ru",
    "msk.ru",
    "mytis.ru",
    "nalchik.ru",
    "nov.ru",
    "pyatigorsk.ru",
    "spb.ru",
    "vladikavkaz.ru",
    "vladimir.ru",
    "abkhazia.su",
    "adygeya.su",
    "aktyubinsk.su",
    "arkhangelsk.su",
    "armenia.su",
    "ashgabad.su",
    "azerbaijan.su",
    "balashov.su",
    "bashkiria.su",
    "bryansk.su",
    "bukhara.su",
    "chimkent.su",
    "dagestan.su",
    "east-kazakhstan.su",
    "exnet.su",
    "georgia.su",
    "grozny.su",
    "ivanovo.su",
    "jambyl.su",
    "kalmykia.su",
    "kaluga.su",
    "karacol.su",
    "karaganda.su",
    "karelia.su",
    "khakassia.su",
    "krasnodar.su",
    "kurgan.su",
    "kustanai.su",
    "lenug.su",
    "mangyshlak.su",
    "mordovia.su",
    "msk.su",
    "murmansk.su",
    "nalchik.su",
    "navoi.su",
    "north-kazakhstan.su",
    "nov.su",
    "obninsk.su",
    "penza.su",
    "pokrovsk.su",
    "sochi.su",
    "spb.su",
    "tashkent.su",
    "termez.su",
    "togliatti.su",
    "troitsk.su",
    "tselinograd.su",
    "tula.su",
    "tuva.su",
    "vladikavkaz.su",
    "vladimir.su",
    "vologda.su",
    "channelsdvr.net",
    "u.channelsdvr.net",
    "fastly-terrarium.com",
    "fastlylb.net",
    "map.fastlylb.net",
    "freetls.fastly.net",
    "map.fastly.net",
    "a.prod.fastly.net",
    "global.prod.fastly.net",
    "a.ssl.fastly.net",
    "b.ssl.fastly.net",
    "global.ssl.fastly.net",
    "fastpanel.direct",
    "fastvps-server.com",
    "fhapp.xyz",
    "fedorainfracloud.org",
    "fedorapeople.org",
    "cloud.fedoraproject.org",
    "app.os.fedoraproject.org",
    "app.os.stg.fedoraproject.org",
    "mydobiss.com",
    "filegear.me",
    "filegear-au.me",
    "filegear-de.me",
    "filegear-gb.me",
    "filegear-ie.me",
    "filegear-jp.me",
    "filegear-sg.me",
    "firebaseapp.com",
    "flynnhub.com",
    "flynnhosting.net",
    "0e.vc",
    "freebox-os.com",
    "freeboxos.com",
    "fbx-os.fr",
    "fbxos.fr",
    "freebox-os.fr",
    "freeboxos.fr",
    "freedesktop.org",
    "*.futurecms.at",
    "*.ex.futurecms.at",
    "*.in.futurecms.at",
    "futurehosting.at",
    "futuremailing.at",
    "*.ex.ortsinfo.at",
    "*.kunden.ortsinfo.at",
    "*.statics.cloud",
    "service.gov.uk",
    "gehirn.ne.jp",
    "usercontent.jp",
    "gentapps.com",
    "lab.ms",
    "github.io",
    "githubusercontent.com",
    "gitlab.io",
    "glitch.me",
    "lolipop.io",
    "cloudapps.digital",
    "london.cloudapps.digital",
    "homeoffice.gov.uk",
    "ro.im",
    "shop.ro",
    "goip.de",
    "run.app",
    "a.run.app",
    "web.app",
    "*.0emm.com",
    "appspot.com",
    "*.r.appspot.com",
    "blogspot.ae",
    "blogspot.al",
    "blogspot.am",
    "blogspot.ba",
    "blogspot.be",
    "blogspot.bg",
    "blogspot.bj",
    "blogspot.ca",
    "blogspot.cf",
    "blogspot.ch",
    "blogspot.cl",
    "blogspot.co.at",
    "blogspot.co.id",
    "blogspot.co.il",
    "blogspot.co.ke",
    "blogspot.co.nz",
    "blogspot.co.uk",
    "blogspot.co.za",
    "blogspot.com",
    "blogspot.com.ar",
    "blogspot.com.au",
    "blogspot.com.br",
    "blogspot.com.by",
    "blogspot.com.co",
    "blogspot.com.cy",
    "blogspot.com.ee",
    "blogspot.com.eg",
    "blogspot.com.es",
    "blogspot.com.mt",
    "blogspot.com.ng",
    "blogspot.com.tr",
    "blogspot.com.uy",
    "blogspot.cv",
    "blogspot.cz",
    "blogspot.de",
    "blogspot.dk",
    "blogspot.fi",
    "blogspot.fr",
    "blogspot.gr",
    "blogspot.hk",
    "blogspot.hr",
    "blogspot.hu",
    "blogspot.ie",
    "blogspot.in",
    "blogspot.is",
    "blogspot.it",
    "blogspot.jp",
    "blogspot.kr",
    "blogspot.li",
    "blogspot.lt",
    "blogspot.lu",
    "blogspot.md",
    "blogspot.mk",
    "blogspot.mr",
    "blogspot.mx",
    "blogspot.my",
    "blogspot.nl",
    "blogspot.no",
    "blogspot.pe",
    "blogspot.pt",
    "blogspot.qa",
    "blogspot.re",
    "blogspot.ro",
    "blogspot.rs",
    "blogspot.ru",
    "blogspot.se",
    "blogspot.sg",
    "blogspot.si",
    "blogspot.sk",
    "blogspot.sn",
    "blogspot.td",
    "blogspot.tw",
    "blogspot.ug",
    "blogspot.vn",
    "cloudfunctions.net",
    "cloud.goog",
    "codespot.com",
    "googleapis.com",
    "googlecode.com",
    "pagespeedmobilizer.com",
    "publishproxy.com",
    "withgoogle.com",
    "withyoutube.com",
    "awsmppl.com",
    "fin.ci",
    "free.hr",
    "caa.li",
    "ua.rs",
    "conf.se",
    "hs.zone",
    "hs.run",
    "hashbang.sh",
    "hasura.app",
    "hasura-app.io",
    "hepforge.org",
    "herokuapp.com",
    "herokussl.com",
    "myravendb.com",
    "ravendb.community",
    "ravendb.me",
    "development.run",
    "ravendb.run",
    "bpl.biz",
    "orx.biz",
    "ng.city",
    "biz.gl",
    "ng.ink",
    "col.ng",
    "firm.ng",
    "gen.ng",
    "ltd.ng",
    "ngo.ng",
    "ng.school",
    "sch.so",
    "h\xE4kkinen.fi",
    "*.moonscale.io",
    "moonscale.net",
    "iki.fi",
    "dyn-berlin.de",
    "in-berlin.de",
    "in-brb.de",
    "in-butter.de",
    "in-dsl.de",
    "in-dsl.net",
    "in-dsl.org",
    "in-vpn.de",
    "in-vpn.net",
    "in-vpn.org",
    "biz.at",
    "info.at",
    "info.cx",
    "ac.leg.br",
    "al.leg.br",
    "am.leg.br",
    "ap.leg.br",
    "ba.leg.br",
    "ce.leg.br",
    "df.leg.br",
    "es.leg.br",
    "go.leg.br",
    "ma.leg.br",
    "mg.leg.br",
    "ms.leg.br",
    "mt.leg.br",
    "pa.leg.br",
    "pb.leg.br",
    "pe.leg.br",
    "pi.leg.br",
    "pr.leg.br",
    "rj.leg.br",
    "rn.leg.br",
    "ro.leg.br",
    "rr.leg.br",
    "rs.leg.br",
    "sc.leg.br",
    "se.leg.br",
    "sp.leg.br",
    "to.leg.br",
    "pixolino.com",
    "ipifony.net",
    "mein-iserv.de",
    "test-iserv.de",
    "iserv.dev",
    "iobb.net",
    "myjino.ru",
    "*.hosting.myjino.ru",
    "*.landing.myjino.ru",
    "*.spectrum.myjino.ru",
    "*.vps.myjino.ru",
    "*.triton.zone",
    "*.cns.joyent.com",
    "js.org",
    "kaas.gg",
    "khplay.nl",
    "keymachine.de",
    "kinghost.net",
    "uni5.net",
    "knightpoint.systems",
    "oya.to",
    "co.krd",
    "edu.krd",
    "git-repos.de",
    "lcube-server.de",
    "svn-repos.de",
    "leadpages.co",
    "lpages.co",
    "lpusercontent.com",
    "lelux.site",
    "co.business",
    "co.education",
    "co.events",
    "co.financial",
    "co.network",
    "co.place",
    "co.technology",
    "app.lmpm.com",
    "linkitools.space",
    "linkyard.cloud",
    "linkyard-cloud.ch",
    "members.linode.com",
    "nodebalancer.linode.com",
    "we.bs",
    "loginline.app",
    "loginline.dev",
    "loginline.io",
    "loginline.services",
    "loginline.site",
    "krasnik.pl",
    "leczna.pl",
    "lubartow.pl",
    "lublin.pl",
    "poniatowa.pl",
    "swidnik.pl",
    "uklugs.org",
    "glug.org.uk",
    "lug.org.uk",
    "lugs.org.uk",
    "barsy.bg",
    "barsy.co.uk",
    "barsyonline.co.uk",
    "barsycenter.com",
    "barsyonline.com",
    "barsy.club",
    "barsy.de",
    "barsy.eu",
    "barsy.in",
    "barsy.info",
    "barsy.io",
    "barsy.me",
    "barsy.menu",
    "barsy.mobi",
    "barsy.net",
    "barsy.online",
    "barsy.org",
    "barsy.pro",
    "barsy.pub",
    "barsy.shop",
    "barsy.site",
    "barsy.support",
    "barsy.uk",
    "*.magentosite.cloud",
    "mayfirst.info",
    "mayfirst.org",
    "hb.cldmail.ru",
    "miniserver.com",
    "memset.net",
    "cloud.metacentrum.cz",
    "custom.metacentrum.cz",
    "flt.cloud.muni.cz",
    "usr.cloud.muni.cz",
    "meteorapp.com",
    "eu.meteorapp.com",
    "co.pl",
    "azurecontainer.io",
    "azurewebsites.net",
    "azure-mobile.net",
    "cloudapp.net",
    "mozilla-iot.org",
    "bmoattachments.org",
    "net.ru",
    "org.ru",
    "pp.ru",
    "ui.nabu.casa",
    "pony.club",
    "of.fashion",
    "on.fashion",
    "of.football",
    "in.london",
    "of.london",
    "for.men",
    "and.mom",
    "for.mom",
    "for.one",
    "for.sale",
    "of.work",
    "to.work",
    "nctu.me",
    "bitballoon.com",
    "netlify.com",
    "4u.com",
    "ngrok.io",
    "nh-serv.co.uk",
    "nfshost.com",
    "dnsking.ch",
    "mypi.co",
    "n4t.co",
    "001www.com",
    "ddnslive.com",
    "myiphost.com",
    "forumz.info",
    "16-b.it",
    "32-b.it",
    "64-b.it",
    "soundcast.me",
    "tcp4.me",
    "dnsup.net",
    "hicam.net",
    "now-dns.net",
    "ownip.net",
    "vpndns.net",
    "dynserv.org",
    "now-dns.org",
    "x443.pw",
    "now-dns.top",
    "ntdll.top",
    "freeddns.us",
    "crafting.xyz",
    "zapto.xyz",
    "nsupdate.info",
    "nerdpol.ovh",
    "blogsyte.com",
    "brasilia.me",
    "cable-modem.org",
    "ciscofreak.com",
    "collegefan.org",
    "couchpotatofries.org",
    "damnserver.com",
    "ddns.me",
    "ditchyourip.com",
    "dnsfor.me",
    "dnsiskinky.com",
    "dvrcam.info",
    "dynns.com",
    "eating-organic.net",
    "fantasyleague.cc",
    "geekgalaxy.com",
    "golffan.us",
    "health-carereform.com",
    "homesecuritymac.com",
    "homesecuritypc.com",
    "hopto.me",
    "ilovecollege.info",
    "loginto.me",
    "mlbfan.org",
    "mmafan.biz",
    "myactivedirectory.com",
    "mydissent.net",
    "myeffect.net",
    "mymediapc.net",
    "mypsx.net",
    "mysecuritycamera.com",
    "mysecuritycamera.net",
    "mysecuritycamera.org",
    "net-freaks.com",
    "nflfan.org",
    "nhlfan.net",
    "no-ip.ca",
    "no-ip.co.uk",
    "no-ip.net",
    "noip.us",
    "onthewifi.com",
    "pgafan.net",
    "point2this.com",
    "pointto.us",
    "privatizehealthinsurance.net",
    "quicksytes.com",
    "read-books.org",
    "securitytactics.com",
    "serveexchange.com",
    "servehumour.com",
    "servep2p.com",
    "servesarcasm.com",
    "stufftoread.com",
    "ufcfan.org",
    "unusualperson.com",
    "workisboring.com",
    "3utilities.com",
    "bounceme.net",
    "ddns.net",
    "ddnsking.com",
    "gotdns.ch",
    "hopto.org",
    "myftp.biz",
    "myftp.org",
    "myvnc.com",
    "no-ip.biz",
    "no-ip.info",
    "no-ip.org",
    "noip.me",
    "redirectme.net",
    "servebeer.com",
    "serveblog.net",
    "servecounterstrike.com",
    "serveftp.com",
    "servegame.com",
    "servehalflife.com",
    "servehttp.com",
    "serveirc.com",
    "serveminecraft.net",
    "servemp3.com",
    "servepics.com",
    "servequake.com",
    "sytes.net",
    "webhop.me",
    "zapto.org",
    "stage.nodeart.io",
    "nodum.co",
    "nodum.io",
    "pcloud.host",
    "nyc.mn",
    "nom.ae",
    "nom.af",
    "nom.ai",
    "nom.al",
    "nym.by",
    "nom.bz",
    "nym.bz",
    "nom.cl",
    "nym.ec",
    "nom.gd",
    "nom.ge",
    "nom.gl",
    "nym.gr",
    "nom.gt",
    "nym.gy",
    "nym.hk",
    "nom.hn",
    "nym.ie",
    "nom.im",
    "nom.ke",
    "nym.kz",
    "nym.la",
    "nym.lc",
    "nom.li",
    "nym.li",
    "nym.lt",
    "nym.lu",
    "nom.lv",
    "nym.me",
    "nom.mk",
    "nym.mn",
    "nym.mx",
    "nom.nu",
    "nym.nz",
    "nym.pe",
    "nym.pt",
    "nom.pw",
    "nom.qa",
    "nym.ro",
    "nom.rs",
    "nom.si",
    "nym.sk",
    "nom.st",
    "nym.su",
    "nym.sx",
    "nom.tj",
    "nym.tw",
    "nom.ug",
    "nom.uy",
    "nom.vc",
    "nom.vg",
    "static.observableusercontent.com",
    "cya.gg",
    "cloudycluster.net",
    "nid.io",
    "opencraft.hosting",
    "operaunite.com",
    "skygearapp.com",
    "outsystemscloud.com",
    "ownprovider.com",
    "own.pm",
    "ox.rs",
    "oy.lc",
    "pgfog.com",
    "pagefrontapp.com",
    "art.pl",
    "gliwice.pl",
    "krakow.pl",
    "poznan.pl",
    "wroc.pl",
    "zakopane.pl",
    "pantheonsite.io",
    "gotpantheon.com",
    "mypep.link",
    "perspecta.cloud",
    "on-web.fr",
    "*.platform.sh",
    "*.platformsh.site",
    "dyn53.io",
    "co.bn",
    "xen.prgmr.com",
    "priv.at",
    "prvcy.page",
    "*.dweb.link",
    "protonet.io",
    "chirurgiens-dentistes-en-france.fr",
    "byen.site",
    "pubtls.org",
    "qualifioapp.com",
    "qbuser.com",
    "instantcloud.cn",
    "ras.ru",
    "qa2.com",
    "qcx.io",
    "*.sys.qcx.io",
    "dev-myqnapcloud.com",
    "alpha-myqnapcloud.com",
    "myqnapcloud.com",
    "*.quipelements.com",
    "vapor.cloud",
    "vaporcloud.io",
    "rackmaze.com",
    "rackmaze.net",
    "*.on-k3s.io",
    "*.on-rancher.cloud",
    "*.on-rio.io",
    "readthedocs.io",
    "rhcloud.com",
    "app.render.com",
    "onrender.com",
    "repl.co",
    "repl.run",
    "resindevice.io",
    "devices.resinstaging.io",
    "hzc.io",
    "wellbeingzone.eu",
    "ptplus.fit",
    "wellbeingzone.co.uk",
    "git-pages.rit.edu",
    "sandcats.io",
    "logoip.de",
    "logoip.com",
    "schokokeks.net",
    "gov.scot",
    "scrysec.com",
    "firewall-gateway.com",
    "firewall-gateway.de",
    "my-gateway.de",
    "my-router.de",
    "spdns.de",
    "spdns.eu",
    "firewall-gateway.net",
    "my-firewall.org",
    "myfirewall.org",
    "spdns.org",
    "senseering.net",
    "biz.ua",
    "co.ua",
    "pp.ua",
    "shiftedit.io",
    "myshopblocks.com",
    "shopitsite.com",
    "mo-siemens.io",
    "1kapp.com",
    "appchizi.com",
    "applinzi.com",
    "sinaapp.com",
    "vipsinaapp.com",
    "siteleaf.net",
    "bounty-full.com",
    "alpha.bounty-full.com",
    "beta.bounty-full.com",
    "stackhero-network.com",
    "static.land",
    "dev.static.land",
    "sites.static.land",
    "apps.lair.io",
    "*.stolos.io",
    "spacekit.io",
    "customer.speedpartner.de",
    "api.stdlib.com",
    "storj.farm",
    "utwente.io",
    "soc.srcf.net",
    "user.srcf.net",
    "temp-dns.com",
    "applicationcloud.io",
    "scapp.io",
    "*.s5y.io",
    "*.sensiosite.cloud",
    "syncloud.it",
    "diskstation.me",
    "dscloud.biz",
    "dscloud.me",
    "dscloud.mobi",
    "dsmynas.com",
    "dsmynas.net",
    "dsmynas.org",
    "familyds.com",
    "familyds.net",
    "familyds.org",
    "i234.me",
    "myds.me",
    "synology.me",
    "vpnplus.to",
    "direct.quickconnect.to",
    "taifun-dns.de",
    "gda.pl",
    "gdansk.pl",
    "gdynia.pl",
    "med.pl",
    "sopot.pl",
    "edugit.org",
    "telebit.app",
    "telebit.io",
    "*.telebit.xyz",
    "gwiddle.co.uk",
    "thingdustdata.com",
    "cust.dev.thingdust.io",
    "cust.disrec.thingdust.io",
    "cust.prod.thingdust.io",
    "cust.testing.thingdust.io",
    "arvo.network",
    "azimuth.network",
    "bloxcms.com",
    "townnews-staging.com",
    "12hp.at",
    "2ix.at",
    "4lima.at",
    "lima-city.at",
    "12hp.ch",
    "2ix.ch",
    "4lima.ch",
    "lima-city.ch",
    "trafficplex.cloud",
    "de.cool",
    "12hp.de",
    "2ix.de",
    "4lima.de",
    "lima-city.de",
    "1337.pictures",
    "clan.rip",
    "lima-city.rocks",
    "webspace.rocks",
    "lima.zone",
    "*.transurl.be",
    "*.transurl.eu",
    "*.transurl.nl",
    "tuxfamily.org",
    "dd-dns.de",
    "diskstation.eu",
    "diskstation.org",
    "dray-dns.de",
    "draydns.de",
    "dyn-vpn.de",
    "dynvpn.de",
    "mein-vigor.de",
    "my-vigor.de",
    "my-wan.de",
    "syno-ds.de",
    "synology-diskstation.de",
    "synology-ds.de",
    "uber.space",
    "*.uberspace.de",
    "hk.com",
    "hk.org",
    "ltd.hk",
    "inc.hk",
    "virtualuser.de",
    "virtual-user.de",
    "urown.cloud",
    "dnsupdate.info",
    "lib.de.us",
    "2038.io",
    "router.management",
    "v-info.info",
    "voorloper.cloud",
    "v.ua",
    "wafflecell.com",
    "*.webhare.dev",
    "wedeploy.io",
    "wedeploy.me",
    "wedeploy.sh",
    "remotewd.com",
    "wmflabs.org",
    "myforum.community",
    "community-pro.de",
    "diskussionsbereich.de",
    "community-pro.net",
    "meinforum.net",
    "half.host",
    "xnbay.com",
    "u2.xnbay.com",
    "u2-local.xnbay.com",
    "cistron.nl",
    "demon.nl",
    "xs4all.space",
    "yandexcloud.net",
    "storage.yandexcloud.net",
    "website.yandexcloud.net",
    "official.academy",
    "yolasite.com",
    "ybo.faith",
    "yombo.me",
    "homelink.one",
    "ybo.party",
    "ybo.review",
    "ybo.science",
    "ybo.trade",
    "nohost.me",
    "noho.st",
    "za.net",
    "za.org",
    "now.sh",
    "bss.design",
    "basicserver.io",
    "virtualserver.io",
    "enterprisecloud.nu"
  ];
});

// ../node_modules/psl/index.js
var require_psl = __commonJS((exports2) => {
  "use strict";
  var Punycode = require("punycode"), internals = {};
  internals.rules = require_rules().map(function(rule) {
    return {
      rule,
      suffix: rule.replace(/^(\*\.|\!)/, ""),
      punySuffix: -1,
      wildcard: rule.charAt(0) === "*",
      exception: rule.charAt(0) === "!"
    };
  });
  internals.endsWith = function(str, suffix) {
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
  };
  internals.findRule = function(domain) {
    var punyDomain = Punycode.toASCII(domain);
    return internals.rules.reduce(function(memo, rule) {
      return rule.punySuffix === -1 && (rule.punySuffix = Punycode.toASCII(rule.suffix)), !internals.endsWith(punyDomain, "." + rule.punySuffix) && punyDomain !== rule.punySuffix ? memo : rule;
    }, null);
  };
  exports2.errorCodes = {
    DOMAIN_TOO_SHORT: "Domain name too short.",
    DOMAIN_TOO_LONG: "Domain name too long. It should be no more than 255 chars.",
    LABEL_STARTS_WITH_DASH: "Domain name label can not start with a dash.",
    LABEL_ENDS_WITH_DASH: "Domain name label can not end with a dash.",
    LABEL_TOO_LONG: "Domain name label should be at most 63 chars long.",
    LABEL_TOO_SHORT: "Domain name label should be at least 1 character long.",
    LABEL_INVALID_CHARS: "Domain name label can only contain alphanumeric characters or dashes."
  };
  internals.validate = function(input) {
    var ascii = Punycode.toASCII(input);
    if (ascii.length < 1)
      return "DOMAIN_TOO_SHORT";
    if (ascii.length > 255)
      return "DOMAIN_TOO_LONG";
    for (var labels = ascii.split("."), label, i = 0; i < labels.length; ++i) {
      if (label = labels[i], !label.length)
        return "LABEL_TOO_SHORT";
      if (label.length > 63)
        return "LABEL_TOO_LONG";
      if (label.charAt(0) === "-")
        return "LABEL_STARTS_WITH_DASH";
      if (label.charAt(label.length - 1) === "-")
        return "LABEL_ENDS_WITH_DASH";
      if (!/^[a-z0-9\-]+$/.test(label))
        return "LABEL_INVALID_CHARS";
    }
  };
  exports2.parse = function(input) {
    if (typeof input != "string")
      throw new TypeError("Domain name must be a string.");
    var domain = input.slice(0).toLowerCase();
    domain.charAt(domain.length - 1) === "." && (domain = domain.slice(0, domain.length - 1));
    var error = internals.validate(domain);
    if (error)
      return {
        input,
        error: {
          message: exports2.errorCodes[error],
          code: error
        }
      };
    var parsed = {
      input,
      tld: null,
      sld: null,
      domain: null,
      subdomain: null,
      listed: !1
    }, domainParts = domain.split(".");
    if (domainParts[domainParts.length - 1] === "local")
      return parsed;
    var handlePunycode = /* @__PURE__ */ __name(function() {
      return /xn--/.test(domain) && (parsed.domain && (parsed.domain = Punycode.toASCII(parsed.domain)), parsed.subdomain && (parsed.subdomain = Punycode.toASCII(parsed.subdomain))), parsed;
    }, "handlePunycode"), rule = internals.findRule(domain);
    if (!rule)
      return domainParts.length < 2 ? parsed : (parsed.tld = domainParts.pop(), parsed.sld = domainParts.pop(), parsed.domain = [parsed.sld, parsed.tld].join("."), domainParts.length && (parsed.subdomain = domainParts.pop()), handlePunycode());
    parsed.listed = !0;
    var tldParts = rule.suffix.split("."), privateParts = domainParts.slice(0, domainParts.length - tldParts.length);
    return rule.exception && privateParts.push(tldParts.shift()), parsed.tld = tldParts.join("."), !privateParts.length || (rule.wildcard && (tldParts.unshift(privateParts.pop()), parsed.tld = tldParts.join(".")), !privateParts.length) || (parsed.sld = privateParts.pop(), parsed.domain = [parsed.sld, parsed.tld].join("."), privateParts.length && (parsed.subdomain = privateParts.join("."))), handlePunycode();
  };
  exports2.get = function(domain) {
    return domain && exports2.parse(domain).domain || null;
  };
  exports2.isValid = function(domain) {
    var parsed = exports2.parse(domain);
    return Boolean(parsed.domain && parsed.listed);
  };
});

// ../node_modules/@azure/core-http/node_modules/tough-cookie/lib/pubsuffix-psl.js
var require_pubsuffix_psl = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2018, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  "use strict";
  var psl = require_psl();
  function getPublicSuffix(domain) {
    return psl.get(domain);
  }
  __name(getPublicSuffix, "getPublicSuffix");
  exports2.getPublicSuffix = getPublicSuffix;
});

// ../node_modules/@azure/core-http/node_modules/tough-cookie/lib/store.js
var require_store = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  "use strict";
  var Store = class {
    constructor() {
      this.synchronous = !1;
    }
    findCookie(domain, path3, key, cb) {
      throw new Error("findCookie is not implemented");
    }
    findCookies(domain, path3, allowSpecialUseDomain, cb) {
      throw new Error("findCookies is not implemented");
    }
    putCookie(cookie, cb) {
      throw new Error("putCookie is not implemented");
    }
    updateCookie(oldCookie, newCookie, cb) {
      throw new Error("updateCookie is not implemented");
    }
    removeCookie(domain, path3, key, cb) {
      throw new Error("removeCookie is not implemented");
    }
    removeCookies(domain, path3, cb) {
      throw new Error("removeCookies is not implemented");
    }
    removeAllCookies(cb) {
      throw new Error("removeAllCookies is not implemented");
    }
    getAllCookies(cb) {
      throw new Error("getAllCookies is not implemented (therefore jar cannot be serialized)");
    }
  };
  __name(Store, "Store");
  exports2.Store = Store;
});

// ../node_modules/universalify/index.js
var require_universalify = __commonJS((exports2) => {
  "use strict";
  exports2.fromCallback = function(fn) {
    return Object.defineProperty(function() {
      if (typeof arguments[arguments.length - 1] == "function")
        fn.apply(this, arguments);
      else
        return new Promise((resolve, reject) => {
          arguments[arguments.length] = (err, res) => {
            if (err)
              return reject(err);
            resolve(res);
          }, arguments.length++, fn.apply(this, arguments);
        });
    }, "name", {value: fn.name});
  };
  exports2.fromPromise = function(fn) {
    return Object.defineProperty(function() {
      let cb = arguments[arguments.length - 1];
      if (typeof cb != "function")
        return fn.apply(this, arguments);
      fn.apply(this, arguments).then((r) => cb(null, r), cb);
    }, "name", {value: fn.name});
  };
});

// ../node_modules/@azure/core-http/node_modules/tough-cookie/lib/permuteDomain.js
var require_permuteDomain = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  "use strict";
  var pubsuffix = require_pubsuffix_psl(), SPECIAL_USE_DOMAINS = ["local"];
  function permuteDomain(domain, allowSpecialUseDomain) {
    let pubSuf = null;
    if (allowSpecialUseDomain) {
      let domainParts = domain.split(".");
      SPECIAL_USE_DOMAINS.includes(domainParts[domainParts.length - 1]) ? pubSuf = `${domainParts[domainParts.length - 2]}.${domainParts[domainParts.length - 1]}` : pubSuf = pubsuffix.getPublicSuffix(domain);
    } else
      pubSuf = pubsuffix.getPublicSuffix(domain);
    if (!pubSuf)
      return null;
    if (pubSuf == domain)
      return [domain];
    let parts = domain.slice(0, -(pubSuf.length + 1)).split(".").reverse(), cur = pubSuf, permutations = [cur];
    for (; parts.length; )
      cur = `${parts.shift()}.${cur}`, permutations.push(cur);
    return permutations;
  }
  __name(permuteDomain, "permuteDomain");
  exports2.permuteDomain = permuteDomain;
});

// ../node_modules/@azure/core-http/node_modules/tough-cookie/lib/pathMatch.js
var require_pathMatch = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  "use strict";
  function pathMatch(reqPath, cookiePath) {
    return cookiePath === reqPath || reqPath.indexOf(cookiePath) === 0 && (cookiePath.substr(-1) === "/" || reqPath.substr(cookiePath.length, 1) === "/");
  }
  __name(pathMatch, "pathMatch");
  exports2.pathMatch = pathMatch;
});

// ../node_modules/@azure/core-http/node_modules/tough-cookie/lib/memstore.js
var require_memstore = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  "use strict";
  var {fromCallback} = require_universalify(), Store = require_store().Store, permuteDomain = require_permuteDomain().permuteDomain, pathMatch = require_pathMatch().pathMatch, util3 = require("util"), MemoryCookieStore = class extends Store {
    constructor() {
      super();
      this.synchronous = !0, this.idx = {}, util3.inspect.custom && (this[util3.inspect.custom] = this.inspect);
    }
    inspect() {
      return `{ idx: ${util3.inspect(this.idx, !1, 2)} }`;
    }
    findCookie(domain, path3, key, cb) {
      return !this.idx[domain] || !this.idx[domain][path3] ? cb(null, void 0) : cb(null, this.idx[domain][path3][key] || null);
    }
    findCookies(domain, path3, allowSpecialUseDomain, cb) {
      let results = [];
      if (typeof allowSpecialUseDomain == "function" && (cb = allowSpecialUseDomain, allowSpecialUseDomain = !1), !domain)
        return cb(null, []);
      let pathMatcher;
      path3 ? pathMatcher = /* @__PURE__ */ __name(function(domainIndex) {
        Object.keys(domainIndex).forEach((cookiePath) => {
          if (pathMatch(path3, cookiePath)) {
            let pathIndex = domainIndex[cookiePath];
            for (let key in pathIndex)
              results.push(pathIndex[key]);
          }
        });
      }, "matchRFC") : pathMatcher = /* @__PURE__ */ __name(function(domainIndex) {
        for (let curPath in domainIndex) {
          let pathIndex = domainIndex[curPath];
          for (let key in pathIndex)
            results.push(pathIndex[key]);
        }
      }, "matchAll");
      let domains = permuteDomain(domain, allowSpecialUseDomain) || [domain], idx = this.idx;
      domains.forEach((curDomain) => {
        let domainIndex = idx[curDomain];
        !domainIndex || pathMatcher(domainIndex);
      }), cb(null, results);
    }
    putCookie(cookie, cb) {
      this.idx[cookie.domain] || (this.idx[cookie.domain] = {}), this.idx[cookie.domain][cookie.path] || (this.idx[cookie.domain][cookie.path] = {}), this.idx[cookie.domain][cookie.path][cookie.key] = cookie, cb(null);
    }
    updateCookie(oldCookie, newCookie, cb) {
      this.putCookie(newCookie, cb);
    }
    removeCookie(domain, path3, key, cb) {
      this.idx[domain] && this.idx[domain][path3] && this.idx[domain][path3][key] && delete this.idx[domain][path3][key], cb(null);
    }
    removeCookies(domain, path3, cb) {
      return this.idx[domain] && (path3 ? delete this.idx[domain][path3] : delete this.idx[domain]), cb(null);
    }
    removeAllCookies(cb) {
      return this.idx = {}, cb(null);
    }
    getAllCookies(cb) {
      let cookies = [], idx = this.idx;
      Object.keys(idx).forEach((domain) => {
        Object.keys(idx[domain]).forEach((path3) => {
          Object.keys(idx[domain][path3]).forEach((key) => {
            key !== null && cookies.push(idx[domain][path3][key]);
          });
        });
      }), cookies.sort((a, b) => (a.creationIndex || 0) - (b.creationIndex || 0)), cb(null, cookies);
    }
  };
  __name(MemoryCookieStore, "MemoryCookieStore");
  [
    "findCookie",
    "findCookies",
    "putCookie",
    "updateCookie",
    "removeCookie",
    "removeCookies",
    "removeAllCookies",
    "getAllCookies"
  ].forEach((name) => {
    MemoryCookieStore[name] = fromCallback(MemoryCookieStore.prototype[name]);
  });
  exports2.MemoryCookieStore = MemoryCookieStore;
});

// ../node_modules/@azure/core-http/node_modules/tough-cookie/lib/version.js
var require_version = __commonJS((exports2, module2) => {
  module2.exports = "4.0.0";
});

// ../node_modules/@azure/core-http/node_modules/tough-cookie/lib/cookie.js
var require_cookie = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  "use strict";
  var punycode = require("punycode"), urlParse = require("url").parse, util3 = require("util"), pubsuffix = require_pubsuffix_psl(), Store = require_store().Store, MemoryCookieStore = require_memstore().MemoryCookieStore, pathMatch = require_pathMatch().pathMatch, VERSION2 = require_version(), {fromCallback} = require_universalify(), COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/, CONTROL_CHARS = /[\x00-\x1F]/, TERMINATORS = [`
`, "\r", "\0"], PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/, DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/, MONTH_TO_NUM = {
    jan: 0,
    feb: 1,
    mar: 2,
    apr: 3,
    may: 4,
    jun: 5,
    jul: 6,
    aug: 7,
    sep: 8,
    oct: 9,
    nov: 10,
    dec: 11
  }, MAX_TIME = 2147483647e3, MIN_TIME = 0, SAME_SITE_CONTEXT_VAL_ERR = 'Invalid sameSiteContext option for getCookies(); expected one of "strict", "lax", or "none"';
  function checkSameSiteContext(value) {
    let context = String(value).toLowerCase();
    return context === "none" || context === "lax" || context === "strict" ? context : null;
  }
  __name(checkSameSiteContext, "checkSameSiteContext");
  var PrefixSecurityEnum = Object.freeze({
    SILENT: "silent",
    STRICT: "strict",
    DISABLED: "unsafe-disabled"
  }), IP_REGEX_LOWERCASE = /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-f\d]{1,4}:){7}(?:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,2}|:)|(?:[a-f\d]{1,4}:){4}(?:(?::[a-f\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,3}|:)|(?:[a-f\d]{1,4}:){3}(?:(?::[a-f\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,4}|:)|(?:[a-f\d]{1,4}:){2}(?:(?::[a-f\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,5}|:)|(?:[a-f\d]{1,4}:){1}(?:(?::[a-f\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,6}|:)|(?::(?:(?::[a-f\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,7}|:)))$)/;
  function parseDigits(token, minDigits, maxDigits, trailingOK) {
    let count = 0;
    for (; count < token.length; ) {
      let c = token.charCodeAt(count);
      if (c <= 47 || c >= 58)
        break;
      count++;
    }
    return count < minDigits || count > maxDigits || !trailingOK && count != token.length ? null : parseInt(token.substr(0, count), 10);
  }
  __name(parseDigits, "parseDigits");
  function parseTime(token) {
    let parts = token.split(":"), result = [0, 0, 0];
    if (parts.length !== 3)
      return null;
    for (let i = 0; i < 3; i++) {
      let trailingOK = i == 2, num = parseDigits(parts[i], 1, 2, trailingOK);
      if (num === null)
        return null;
      result[i] = num;
    }
    return result;
  }
  __name(parseTime, "parseTime");
  function parseMonth(token) {
    token = String(token).substr(0, 3).toLowerCase();
    let num = MONTH_TO_NUM[token];
    return num >= 0 ? num : null;
  }
  __name(parseMonth, "parseMonth");
  function parseDate(str) {
    if (!str)
      return;
    let tokens = str.split(DATE_DELIM);
    if (!tokens)
      return;
    let hour = null, minute = null, second = null, dayOfMonth = null, month = null, year = null;
    for (let i = 0; i < tokens.length; i++) {
      let token = tokens[i].trim();
      if (!token.length)
        continue;
      let result;
      if (second === null && (result = parseTime(token), result)) {
        hour = result[0], minute = result[1], second = result[2];
        continue;
      }
      if (dayOfMonth === null && (result = parseDigits(token, 1, 2, !0), result !== null)) {
        dayOfMonth = result;
        continue;
      }
      if (month === null && (result = parseMonth(token), result !== null)) {
        month = result;
        continue;
      }
      year === null && (result = parseDigits(token, 2, 4, !0), result !== null && (year = result, year >= 70 && year <= 99 ? year += 1900 : year >= 0 && year <= 69 && (year += 2e3)));
    }
    if (!(dayOfMonth === null || month === null || year === null || second === null || dayOfMonth < 1 || dayOfMonth > 31 || year < 1601 || hour > 23 || minute > 59 || second > 59))
      return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
  }
  __name(parseDate, "parseDate");
  function formatDate(date) {
    return date.toUTCString();
  }
  __name(formatDate, "formatDate");
  function canonicalDomain(str) {
    return str == null ? null : (str = str.trim().replace(/^\./, ""), punycode && /[^\u0001-\u007f]/.test(str) && (str = punycode.toASCII(str)), str.toLowerCase());
  }
  __name(canonicalDomain, "canonicalDomain");
  function domainMatch(str, domStr, canonicalize) {
    if (str == null || domStr == null)
      return null;
    if (canonicalize !== !1 && (str = canonicalDomain(str), domStr = canonicalDomain(domStr)), str == domStr)
      return !0;
    let idx = str.indexOf(domStr);
    return !(idx <= 0 || str.length !== domStr.length + idx || str.substr(idx - 1, 1) !== "." || IP_REGEX_LOWERCASE.test(str));
  }
  __name(domainMatch, "domainMatch");
  function defaultPath(path3) {
    if (!path3 || path3.substr(0, 1) !== "/")
      return "/";
    if (path3 === "/")
      return path3;
    let rightSlash = path3.lastIndexOf("/");
    return rightSlash === 0 ? "/" : path3.slice(0, rightSlash);
  }
  __name(defaultPath, "defaultPath");
  function trimTerminator(str) {
    for (let t = 0; t < TERMINATORS.length; t++) {
      let terminatorIdx = str.indexOf(TERMINATORS[t]);
      terminatorIdx !== -1 && (str = str.substr(0, terminatorIdx));
    }
    return str;
  }
  __name(trimTerminator, "trimTerminator");
  function parseCookiePair(cookiePair, looseMode) {
    cookiePair = trimTerminator(cookiePair);
    let firstEq = cookiePair.indexOf("=");
    if (looseMode)
      firstEq === 0 && (cookiePair = cookiePair.substr(1), firstEq = cookiePair.indexOf("="));
    else if (firstEq <= 0)
      return;
    let cookieName, cookieValue;
    if (firstEq <= 0 ? (cookieName = "", cookieValue = cookiePair.trim()) : (cookieName = cookiePair.substr(0, firstEq).trim(), cookieValue = cookiePair.substr(firstEq + 1).trim()), CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue))
      return;
    let c = new Cookie();
    return c.key = cookieName, c.value = cookieValue, c;
  }
  __name(parseCookiePair, "parseCookiePair");
  function parse2(str, options) {
    (!options || typeof options != "object") && (options = {}), str = str.trim();
    let firstSemi = str.indexOf(";"), cookiePair = firstSemi === -1 ? str : str.substr(0, firstSemi), c = parseCookiePair(cookiePair, !!options.loose);
    if (!c)
      return;
    if (firstSemi === -1)
      return c;
    let unparsed = str.slice(firstSemi + 1).trim();
    if (unparsed.length === 0)
      return c;
    let cookie_avs = unparsed.split(";");
    for (; cookie_avs.length; ) {
      let av = cookie_avs.shift().trim();
      if (av.length === 0)
        continue;
      let av_sep = av.indexOf("="), av_key, av_value;
      switch (av_sep === -1 ? (av_key = av, av_value = null) : (av_key = av.substr(0, av_sep), av_value = av.substr(av_sep + 1)), av_key = av_key.trim().toLowerCase(), av_value && (av_value = av_value.trim()), av_key) {
        case "expires":
          if (av_value) {
            let exp = parseDate(av_value);
            exp && (c.expires = exp);
          }
          break;
        case "max-age":
          if (av_value && /^-?[0-9]+$/.test(av_value)) {
            let delta = parseInt(av_value, 10);
            c.setMaxAge(delta);
          }
          break;
        case "domain":
          if (av_value) {
            let domain = av_value.trim().replace(/^\./, "");
            domain && (c.domain = domain.toLowerCase());
          }
          break;
        case "path":
          c.path = av_value && av_value[0] === "/" ? av_value : null;
          break;
        case "secure":
          c.secure = !0;
          break;
        case "httponly":
          c.httpOnly = !0;
          break;
        case "samesite":
          switch (av_value ? av_value.toLowerCase() : "") {
            case "strict":
              c.sameSite = "strict";
              break;
            case "lax":
              c.sameSite = "lax";
              break;
            default:
              break;
          }
          break;
        default:
          c.extensions = c.extensions || [], c.extensions.push(av);
          break;
      }
    }
    return c;
  }
  __name(parse2, "parse");
  function isSecurePrefixConditionMet(cookie) {
    return !cookie.key.startsWith("__Secure-") || cookie.secure;
  }
  __name(isSecurePrefixConditionMet, "isSecurePrefixConditionMet");
  function isHostPrefixConditionMet(cookie) {
    return !cookie.key.startsWith("__Host-") || cookie.secure && cookie.hostOnly && cookie.path != null && cookie.path === "/";
  }
  __name(isHostPrefixConditionMet, "isHostPrefixConditionMet");
  function jsonParse(str) {
    let obj;
    try {
      obj = JSON.parse(str);
    } catch (e) {
      return e;
    }
    return obj;
  }
  __name(jsonParse, "jsonParse");
  function fromJSON(str) {
    if (!str)
      return null;
    let obj;
    if (typeof str == "string") {
      if (obj = jsonParse(str), obj instanceof Error)
        return null;
    } else
      obj = str;
    let c = new Cookie();
    for (let i = 0; i < Cookie.serializableProperties.length; i++) {
      let prop = Cookie.serializableProperties[i];
      obj[prop] === void 0 || obj[prop] === cookieDefaults[prop] || (prop === "expires" || prop === "creation" || prop === "lastAccessed" ? obj[prop] === null ? c[prop] = null : c[prop] = obj[prop] == "Infinity" ? "Infinity" : new Date(obj[prop]) : c[prop] = obj[prop]);
    }
    return c;
  }
  __name(fromJSON, "fromJSON");
  function cookieCompare(a, b) {
    let cmp = 0, aPathLen = a.path ? a.path.length : 0;
    if (cmp = (b.path ? b.path.length : 0) - aPathLen, cmp !== 0)
      return cmp;
    let aTime = a.creation ? a.creation.getTime() : MAX_TIME, bTime = b.creation ? b.creation.getTime() : MAX_TIME;
    return cmp = aTime - bTime, cmp !== 0 || (cmp = a.creationIndex - b.creationIndex), cmp;
  }
  __name(cookieCompare, "cookieCompare");
  function permutePath(path3) {
    if (path3 === "/")
      return ["/"];
    let permutations = [path3];
    for (; path3.length > 1; ) {
      let lindex = path3.lastIndexOf("/");
      if (lindex === 0)
        break;
      path3 = path3.substr(0, lindex), permutations.push(path3);
    }
    return permutations.push("/"), permutations;
  }
  __name(permutePath, "permutePath");
  function getCookieContext(url2) {
    if (url2 instanceof Object)
      return url2;
    try {
      url2 = decodeURI(url2);
    } catch (err) {
    }
    return urlParse(url2);
  }
  __name(getCookieContext, "getCookieContext");
  var cookieDefaults = {
    key: "",
    value: "",
    expires: "Infinity",
    maxAge: null,
    domain: null,
    path: null,
    secure: !1,
    httpOnly: !1,
    extensions: null,
    hostOnly: null,
    pathIsDefault: null,
    creation: null,
    lastAccessed: null,
    sameSite: "none"
  }, Cookie = class {
    constructor(options = {}) {
      util3.inspect.custom && (this[util3.inspect.custom] = this.inspect), Object.assign(this, cookieDefaults, options), this.creation = this.creation || new Date(), Object.defineProperty(this, "creationIndex", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: ++Cookie.cookiesCreated
      });
    }
    inspect() {
      let now = Date.now(), hostOnly = this.hostOnly != null ? this.hostOnly : "?", createAge = this.creation ? `${now - this.creation.getTime()}ms` : "?", accessAge = this.lastAccessed ? `${now - this.lastAccessed.getTime()}ms` : "?";
      return `Cookie="${this.toString()}; hostOnly=${hostOnly}; aAge=${accessAge}; cAge=${createAge}"`;
    }
    toJSON() {
      let obj = {};
      for (let prop of Cookie.serializableProperties)
        this[prop] !== cookieDefaults[prop] && (prop === "expires" || prop === "creation" || prop === "lastAccessed" ? this[prop] === null ? obj[prop] = null : obj[prop] = this[prop] == "Infinity" ? "Infinity" : this[prop].toISOString() : prop === "maxAge" ? this[prop] !== null && (obj[prop] = this[prop] == Infinity || this[prop] == -Infinity ? this[prop].toString() : this[prop]) : this[prop] !== cookieDefaults[prop] && (obj[prop] = this[prop]));
      return obj;
    }
    clone() {
      return fromJSON(this.toJSON());
    }
    validate() {
      if (!COOKIE_OCTETS.test(this.value) || this.expires != Infinity && !(this.expires instanceof Date) && !parseDate(this.expires) || this.maxAge != null && this.maxAge <= 0 || this.path != null && !PATH_VALUE.test(this.path))
        return !1;
      let cdomain = this.cdomain();
      return !(cdomain && (cdomain.match(/\.$/) || pubsuffix.getPublicSuffix(cdomain) == null));
    }
    setExpires(exp) {
      exp instanceof Date ? this.expires = exp : this.expires = parseDate(exp) || "Infinity";
    }
    setMaxAge(age) {
      age === Infinity || age === -Infinity ? this.maxAge = age.toString() : this.maxAge = age;
    }
    cookieString() {
      let val = this.value;
      return val == null && (val = ""), this.key === "" ? val : `${this.key}=${val}`;
    }
    toString() {
      let str = this.cookieString();
      if (this.expires != Infinity && (this.expires instanceof Date ? str += `; Expires=${formatDate(this.expires)}` : str += `; Expires=${this.expires}`), this.maxAge != null && this.maxAge != Infinity && (str += `; Max-Age=${this.maxAge}`), this.domain && !this.hostOnly && (str += `; Domain=${this.domain}`), this.path && (str += `; Path=${this.path}`), this.secure && (str += "; Secure"), this.httpOnly && (str += "; HttpOnly"), this.sameSite && this.sameSite !== "none") {
        let ssCanon = Cookie.sameSiteCanonical[this.sameSite.toLowerCase()];
        str += `; SameSite=${ssCanon || this.sameSite}`;
      }
      return this.extensions && this.extensions.forEach((ext) => {
        str += `; ${ext}`;
      }), str;
    }
    TTL(now) {
      if (this.maxAge != null)
        return this.maxAge <= 0 ? 0 : this.maxAge * 1e3;
      let expires = this.expires;
      return expires != Infinity ? (expires instanceof Date || (expires = parseDate(expires) || Infinity), expires == Infinity ? Infinity : expires.getTime() - (now || Date.now())) : Infinity;
    }
    expiryTime(now) {
      if (this.maxAge != null) {
        let relativeTo = now || this.creation || new Date(), age = this.maxAge <= 0 ? -Infinity : this.maxAge * 1e3;
        return relativeTo.getTime() + age;
      }
      return this.expires == Infinity ? Infinity : this.expires.getTime();
    }
    expiryDate(now) {
      let millisec = this.expiryTime(now);
      return millisec == Infinity ? new Date(MAX_TIME) : millisec == -Infinity ? new Date(MIN_TIME) : new Date(millisec);
    }
    isPersistent() {
      return this.maxAge != null || this.expires != Infinity;
    }
    canonicalizedDomain() {
      return this.domain == null ? null : canonicalDomain(this.domain);
    }
    cdomain() {
      return this.canonicalizedDomain();
    }
  };
  __name(Cookie, "Cookie");
  Cookie.cookiesCreated = 0;
  Cookie.parse = parse2;
  Cookie.fromJSON = fromJSON;
  Cookie.serializableProperties = Object.keys(cookieDefaults);
  Cookie.sameSiteLevel = {
    strict: 3,
    lax: 2,
    none: 1
  };
  Cookie.sameSiteCanonical = {
    strict: "Strict",
    lax: "Lax"
  };
  function getNormalizedPrefixSecurity(prefixSecurity) {
    if (prefixSecurity != null) {
      let normalizedPrefixSecurity = prefixSecurity.toLowerCase();
      switch (normalizedPrefixSecurity) {
        case PrefixSecurityEnum.STRICT:
        case PrefixSecurityEnum.SILENT:
        case PrefixSecurityEnum.DISABLED:
          return normalizedPrefixSecurity;
      }
    }
    return PrefixSecurityEnum.SILENT;
  }
  __name(getNormalizedPrefixSecurity, "getNormalizedPrefixSecurity");
  var CookieJar2 = class {
    constructor(store, options = {rejectPublicSuffixes: !0}) {
      typeof options == "boolean" && (options = {rejectPublicSuffixes: options}), this.rejectPublicSuffixes = options.rejectPublicSuffixes, this.enableLooseMode = !!options.looseMode, this.allowSpecialUseDomain = !!options.allowSpecialUseDomain, this.store = store || new MemoryCookieStore(), this.prefixSecurity = getNormalizedPrefixSecurity(options.prefixSecurity), this._cloneSync = syncWrap("clone"), this._importCookiesSync = syncWrap("_importCookies"), this.getCookiesSync = syncWrap("getCookies"), this.getCookieStringSync = syncWrap("getCookieString"), this.getSetCookieStringsSync = syncWrap("getSetCookieStrings"), this.removeAllCookiesSync = syncWrap("removeAllCookies"), this.setCookieSync = syncWrap("setCookie"), this.serializeSync = syncWrap("serialize");
    }
    setCookie(cookie, url2, options, cb) {
      let err, context = getCookieContext(url2);
      typeof options == "function" && (cb = options, options = {});
      let host = canonicalDomain(context.hostname), loose = options.loose || this.enableLooseMode, sameSiteContext = null;
      if (options.sameSiteContext && (sameSiteContext = checkSameSiteContext(options.sameSiteContext), !sameSiteContext))
        return cb(new Error(SAME_SITE_CONTEXT_VAL_ERR));
      if (typeof cookie == "string" || cookie instanceof String) {
        if (cookie = Cookie.parse(cookie, {loose}), !cookie)
          return err = new Error("Cookie failed to parse"), cb(options.ignoreError ? null : err);
      } else if (!(cookie instanceof Cookie))
        return err = new Error("First argument to setCookie must be a Cookie object or string"), cb(options.ignoreError ? null : err);
      let now = options.now || new Date();
      if (this.rejectPublicSuffixes && cookie.domain && pubsuffix.getPublicSuffix(cookie.cdomain()) == null)
        return err = new Error("Cookie has domain set to a public suffix"), cb(options.ignoreError ? null : err);
      if (cookie.domain) {
        if (!domainMatch(host, cookie.cdomain(), !1))
          return err = new Error(`Cookie not in this host's domain. Cookie:${cookie.cdomain()} Request:${host}`), cb(options.ignoreError ? null : err);
        cookie.hostOnly == null && (cookie.hostOnly = !1);
      } else
        cookie.hostOnly = !0, cookie.domain = host;
      if ((!cookie.path || cookie.path[0] !== "/") && (cookie.path = defaultPath(context.pathname), cookie.pathIsDefault = !0), options.http === !1 && cookie.httpOnly)
        return err = new Error("Cookie is HttpOnly and this isn't an HTTP API"), cb(options.ignoreError ? null : err);
      if (cookie.sameSite !== "none" && sameSiteContext && sameSiteContext === "none")
        return err = new Error("Cookie is SameSite but this is a cross-origin request"), cb(options.ignoreError ? null : err);
      let ignoreErrorForPrefixSecurity = this.prefixSecurity === PrefixSecurityEnum.SILENT;
      if (!(this.prefixSecurity === PrefixSecurityEnum.DISABLED)) {
        let errorFound = !1, errorMsg;
        if (isSecurePrefixConditionMet(cookie) ? isHostPrefixConditionMet(cookie) || (errorFound = !0, errorMsg = "Cookie has __Host prefix but either Secure or HostOnly attribute is not set or Path is not '/'") : (errorFound = !0, errorMsg = "Cookie has __Secure prefix but Secure attribute is not set"), errorFound)
          return cb(options.ignoreError || ignoreErrorForPrefixSecurity ? null : new Error(errorMsg));
      }
      let store = this.store;
      store.updateCookie || (store.updateCookie = function(oldCookie, newCookie, cb2) {
        this.putCookie(newCookie, cb2);
      });
      function withCookie(err2, oldCookie) {
        if (err2)
          return cb(err2);
        let next = /* @__PURE__ */ __name(function(err3) {
          if (err3)
            return cb(err3);
          cb(null, cookie);
        }, "next");
        if (oldCookie) {
          if (options.http === !1 && oldCookie.httpOnly)
            return err2 = new Error("old Cookie is HttpOnly and this isn't an HTTP API"), cb(options.ignoreError ? null : err2);
          cookie.creation = oldCookie.creation, cookie.creationIndex = oldCookie.creationIndex, cookie.lastAccessed = now, store.updateCookie(oldCookie, cookie, next);
        } else
          cookie.creation = cookie.lastAccessed = now, store.putCookie(cookie, next);
      }
      __name(withCookie, "withCookie"), store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
    }
    getCookies(url2, options, cb) {
      let context = getCookieContext(url2);
      typeof options == "function" && (cb = options, options = {});
      let host = canonicalDomain(context.hostname), path3 = context.pathname || "/", secure = options.secure;
      secure == null && context.protocol && (context.protocol == "https:" || context.protocol == "wss:") && (secure = !0);
      let sameSiteLevel = 0;
      if (options.sameSiteContext) {
        let sameSiteContext = checkSameSiteContext(options.sameSiteContext);
        if (sameSiteLevel = Cookie.sameSiteLevel[sameSiteContext], !sameSiteLevel)
          return cb(new Error(SAME_SITE_CONTEXT_VAL_ERR));
      }
      let http3 = options.http;
      http3 == null && (http3 = !0);
      let now = options.now || Date.now(), expireCheck = options.expire !== !1, allPaths = !!options.allPaths, store = this.store;
      function matchingCookie(c) {
        if (c.hostOnly) {
          if (c.domain != host)
            return !1;
        } else if (!domainMatch(host, c.domain, !1))
          return !1;
        return !allPaths && !pathMatch(path3, c.path) || c.secure && !secure || c.httpOnly && !http3 || sameSiteLevel && Cookie.sameSiteLevel[c.sameSite || "none"] > sameSiteLevel ? !1 : expireCheck && c.expiryTime() <= now ? (store.removeCookie(c.domain, c.path, c.key, () => {
        }), !1) : !0;
      }
      __name(matchingCookie, "matchingCookie"), store.findCookies(host, allPaths ? null : path3, this.allowSpecialUseDomain, (err, cookies) => {
        if (err)
          return cb(err);
        cookies = cookies.filter(matchingCookie), options.sort !== !1 && (cookies = cookies.sort(cookieCompare));
        let now2 = new Date();
        for (let cookie of cookies)
          cookie.lastAccessed = now2;
        cb(null, cookies);
      });
    }
    getCookieString(...args) {
      let cb = args.pop(), next = /* @__PURE__ */ __name(function(err, cookies) {
        err ? cb(err) : cb(null, cookies.sort(cookieCompare).map((c) => c.cookieString()).join("; "));
      }, "next");
      args.push(next), this.getCookies.apply(this, args);
    }
    getSetCookieStrings(...args) {
      let cb = args.pop(), next = /* @__PURE__ */ __name(function(err, cookies) {
        err ? cb(err) : cb(null, cookies.map((c) => c.toString()));
      }, "next");
      args.push(next), this.getCookies.apply(this, args);
    }
    serialize(cb) {
      let type3 = this.store.constructor.name;
      type3 === "Object" && (type3 = null);
      let serialized = {
        version: `tough-cookie@${VERSION2}`,
        storeType: type3,
        rejectPublicSuffixes: !!this.rejectPublicSuffixes,
        cookies: []
      };
      if (!(this.store.getAllCookies && typeof this.store.getAllCookies == "function"))
        return cb(new Error("store does not support getAllCookies and cannot be serialized"));
      this.store.getAllCookies((err, cookies) => err ? cb(err) : (serialized.cookies = cookies.map((cookie) => (cookie = cookie instanceof Cookie ? cookie.toJSON() : cookie, delete cookie.creationIndex, cookie)), cb(null, serialized)));
    }
    toJSON() {
      return this.serializeSync();
    }
    _importCookies(serialized, cb) {
      let cookies = serialized.cookies;
      if (!cookies || !Array.isArray(cookies))
        return cb(new Error("serialized jar has no cookies array"));
      cookies = cookies.slice();
      let putNext = /* @__PURE__ */ __name((err) => {
        if (err)
          return cb(err);
        if (!cookies.length)
          return cb(err, this);
        let cookie;
        try {
          cookie = fromJSON(cookies.shift());
        } catch (e) {
          return cb(e);
        }
        if (cookie === null)
          return putNext(null);
        this.store.putCookie(cookie, putNext);
      }, "putNext");
      putNext();
    }
    clone(newStore, cb) {
      arguments.length === 1 && (cb = newStore, newStore = null), this.serialize((err, serialized) => {
        if (err)
          return cb(err);
        CookieJar2.deserialize(serialized, newStore, cb);
      });
    }
    cloneSync(newStore) {
      if (arguments.length === 0)
        return this._cloneSync();
      if (!newStore.synchronous)
        throw new Error("CookieJar clone destination store is not synchronous; use async API instead.");
      return this._cloneSync(newStore);
    }
    removeAllCookies(cb) {
      let store = this.store;
      if (typeof store.removeAllCookies == "function" && store.removeAllCookies !== Store.prototype.removeAllCookies)
        return store.removeAllCookies(cb);
      store.getAllCookies((err, cookies) => {
        if (err)
          return cb(err);
        if (cookies.length === 0)
          return cb(null);
        let completedCount = 0, removeErrors = [];
        function removeCookieCb(removeErr) {
          if (removeErr && removeErrors.push(removeErr), completedCount++, completedCount === cookies.length)
            return cb(removeErrors.length ? removeErrors[0] : null);
        }
        __name(removeCookieCb, "removeCookieCb"), cookies.forEach((cookie) => {
          store.removeCookie(cookie.domain, cookie.path, cookie.key, removeCookieCb);
        });
      });
    }
    static deserialize(strOrObj, store, cb) {
      arguments.length !== 3 && (cb = store, store = null);
      let serialized;
      if (typeof strOrObj == "string") {
        if (serialized = jsonParse(strOrObj), serialized instanceof Error)
          return cb(serialized);
      } else
        serialized = strOrObj;
      let jar = new CookieJar2(store, serialized.rejectPublicSuffixes);
      jar._importCookies(serialized, (err) => {
        if (err)
          return cb(err);
        cb(null, jar);
      });
    }
    static deserializeSync(strOrObj, store) {
      let serialized = typeof strOrObj == "string" ? JSON.parse(strOrObj) : strOrObj, jar = new CookieJar2(store, serialized.rejectPublicSuffixes);
      if (!jar.store.synchronous)
        throw new Error("CookieJar store is not synchronous; use async API instead.");
      return jar._importCookiesSync(serialized), jar;
    }
  };
  __name(CookieJar2, "CookieJar");
  CookieJar2.fromJSON = CookieJar2.deserializeSync;
  [
    "_importCookies",
    "clone",
    "getCookies",
    "getCookieString",
    "getSetCookieStrings",
    "removeAllCookies",
    "serialize",
    "setCookie"
  ].forEach((name) => {
    CookieJar2.prototype[name] = fromCallback(CookieJar2.prototype[name]);
  });
  CookieJar2.deserialize = fromCallback(CookieJar2.deserialize);
  function syncWrap(method) {
    return function(...args) {
      if (!this.store.synchronous)
        throw new Error("CookieJar store is not synchronous; use async API instead.");
      let syncErr, syncResult;
      if (this[method](...args, (err, result) => {
        syncErr = err, syncResult = result;
      }), syncErr)
        throw syncErr;
      return syncResult;
    };
  }
  __name(syncWrap, "syncWrap");
  exports2.version = VERSION2;
  exports2.CookieJar = CookieJar2;
  exports2.Cookie = Cookie;
  exports2.Store = Store;
  exports2.MemoryCookieStore = MemoryCookieStore;
  exports2.parseDate = parseDate;
  exports2.formatDate = formatDate;
  exports2.parse = parse2;
  exports2.fromJSON = fromJSON;
  exports2.domainMatch = domainMatch;
  exports2.defaultPath = defaultPath;
  exports2.pathMatch = pathMatch;
  exports2.getPublicSuffix = pubsuffix.getPublicSuffix;
  exports2.cookieCompare = cookieCompare;
  exports2.permuteDomain = require_permuteDomain().permuteDomain;
  exports2.permutePath = permutePath;
  exports2.canonicalDomain = canonicalDomain;
  exports2.PrefixSecurityEnum = PrefixSecurityEnum;
});

// ../node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS((exports2, module2) => {
  var Stream2 = require("stream").Stream, util3 = require("util");
  module2.exports = DelayedStream;
  function DelayedStream() {
    this.source = null, this.dataSize = 0, this.maxDataSize = 1024 * 1024, this.pauseStream = !0, this._maxDataSizeExceeded = !1, this._released = !1, this._bufferedEvents = [];
  }
  __name(DelayedStream, "DelayedStream");
  util3.inherits(DelayedStream, Stream2);
  DelayedStream.create = function(source, options) {
    var delayedStream = new this();
    options = options || {};
    for (var option in options)
      delayedStream[option] = options[option];
    delayedStream.source = source;
    var realEmit = source.emit;
    return source.emit = function() {
      return delayedStream._handleEmit(arguments), realEmit.apply(source, arguments);
    }, source.on("error", function() {
    }), delayedStream.pauseStream && source.pause(), delayedStream;
  };
  Object.defineProperty(DelayedStream.prototype, "readable", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.source.readable;
    }
  });
  DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
  };
  DelayedStream.prototype.resume = function() {
    this._released || this.release(), this.source.resume();
  };
  DelayedStream.prototype.pause = function() {
    this.source.pause();
  };
  DelayedStream.prototype.release = function() {
    this._released = !0, this._bufferedEvents.forEach(function(args) {
      this.emit.apply(this, args);
    }.bind(this)), this._bufferedEvents = [];
  };
  DelayedStream.prototype.pipe = function() {
    var r = Stream2.prototype.pipe.apply(this, arguments);
    return this.resume(), r;
  };
  DelayedStream.prototype._handleEmit = function(args) {
    if (this._released) {
      this.emit.apply(this, args);
      return;
    }
    args[0] === "data" && (this.dataSize += args[1].length, this._checkIfMaxDataSizeExceeded()), this._bufferedEvents.push(args);
  };
  DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (!this._maxDataSizeExceeded && !(this.dataSize <= this.maxDataSize)) {
      this._maxDataSizeExceeded = !0;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    }
  };
});

// ../node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS((exports2, module2) => {
  var util3 = require("util"), Stream2 = require("stream").Stream, DelayedStream = require_delayed_stream();
  module2.exports = CombinedStream;
  function CombinedStream() {
    this.writable = !1, this.readable = !0, this.dataSize = 0, this.maxDataSize = 2 * 1024 * 1024, this.pauseStreams = !0, this._released = !1, this._streams = [], this._currentStream = null, this._insideLoop = !1, this._pendingNext = !1;
  }
  __name(CombinedStream, "CombinedStream");
  util3.inherits(CombinedStream, Stream2);
  CombinedStream.create = function(options) {
    var combinedStream = new this();
    options = options || {};
    for (var option in options)
      combinedStream[option] = options[option];
    return combinedStream;
  };
  CombinedStream.isStreamLike = function(stream) {
    return typeof stream != "function" && typeof stream != "string" && typeof stream != "boolean" && typeof stream != "number" && !Buffer.isBuffer(stream);
  };
  CombinedStream.prototype.append = function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      if (!(stream instanceof DelayedStream)) {
        var newStream = DelayedStream.create(stream, {
          maxDataSize: Infinity,
          pauseStream: this.pauseStreams
        });
        stream.on("data", this._checkDataSize.bind(this)), stream = newStream;
      }
      this._handleErrors(stream), this.pauseStreams && stream.pause();
    }
    return this._streams.push(stream), this;
  };
  CombinedStream.prototype.pipe = function(dest, options) {
    return Stream2.prototype.pipe.call(this, dest, options), this.resume(), dest;
  };
  CombinedStream.prototype._getNext = function() {
    if (this._currentStream = null, this._insideLoop) {
      this._pendingNext = !0;
      return;
    }
    this._insideLoop = !0;
    try {
      do
        this._pendingNext = !1, this._realGetNext();
      while (this._pendingNext);
    } finally {
      this._insideLoop = !1;
    }
  };
  CombinedStream.prototype._realGetNext = function() {
    var stream = this._streams.shift();
    if (typeof stream == "undefined") {
      this.end();
      return;
    }
    if (typeof stream != "function") {
      this._pipeNext(stream);
      return;
    }
    var getStream = stream;
    getStream(function(stream2) {
      var isStreamLike = CombinedStream.isStreamLike(stream2);
      isStreamLike && (stream2.on("data", this._checkDataSize.bind(this)), this._handleErrors(stream2)), this._pipeNext(stream2);
    }.bind(this));
  };
  CombinedStream.prototype._pipeNext = function(stream) {
    this._currentStream = stream;
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on("end", this._getNext.bind(this)), stream.pipe(this, {end: !1});
      return;
    }
    var value = stream;
    this.write(value), this._getNext();
  };
  CombinedStream.prototype._handleErrors = function(stream) {
    var self = this;
    stream.on("error", function(err) {
      self._emitError(err);
    });
  };
  CombinedStream.prototype.write = function(data) {
    this.emit("data", data);
  };
  CombinedStream.prototype.pause = function() {
    !this.pauseStreams || (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function" && this._currentStream.pause(), this.emit("pause"));
  };
  CombinedStream.prototype.resume = function() {
    this._released || (this._released = !0, this.writable = !0, this._getNext()), this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function" && this._currentStream.resume(), this.emit("resume");
  };
  CombinedStream.prototype.end = function() {
    this._reset(), this.emit("end");
  };
  CombinedStream.prototype.destroy = function() {
    this._reset(), this.emit("close");
  };
  CombinedStream.prototype._reset = function() {
    this.writable = !1, this._streams = [], this._currentStream = null;
  };
  CombinedStream.prototype._checkDataSize = function() {
    if (this._updateDataSize(), !(this.dataSize <= this.maxDataSize)) {
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    }
  };
  CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self = this;
    this._streams.forEach(function(stream) {
      !stream.dataSize || (self.dataSize += stream.dataSize);
    }), this._currentStream && this._currentStream.dataSize && (this.dataSize += this._currentStream.dataSize);
  };
  CombinedStream.prototype._emitError = function(err) {
    this._reset(), this.emit("error", err);
  };
});

// ../node_modules/mime-db/db.json
var require_db = __commonJS((exports2, module2) => {
  module2.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: !0
    },
    "application/a2l": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: !0
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: !0
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: !0
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: !1
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: !1,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/calendar+json": {
      source: "iana",
      compressible: !0
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: !0
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: !0
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["ccxml"]
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: !0
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: !0
    },
    "application/cfw": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: !0
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: !0
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: !0
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: !0
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: !0
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: !0
    },
    "application/csvm+json": {
      source: "iana",
      compressible: !0
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: !0
    },
    "application/dash+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mpd"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/dicom": {
      source: "iana"
    },
    "application/dicom+json": {
      source: "iana",
      compressible: !0
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: !0
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: !0
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: !0
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/ecmascript": {
      source: "iana",
      compressible: !0,
      extensions: ["ecma", "es"]
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: !1
    },
    "application/edifact": {
      source: "iana",
      compressible: !1
    },
    "application/efi": {
      source: "iana"
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: !0
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: !0
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: !0
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: !0
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: !0
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: !0
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: !0
    },
    "application/emma+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: !0
    },
    "application/epub+zip": {
      source: "iana",
      compressible: !1,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: !0
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/fido.trusted-apps+json": {
      compressible: !0
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: !1
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: !0
    },
    "application/geo+json": {
      source: "iana",
      compressible: !0,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: !0
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["gml"]
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["gpx"]
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: !1,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: !0
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: !0
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: !0
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "apache",
      compressible: !1,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: !1,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: !1,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["js", "mjs"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: !0
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: !0
    },
    "application/jrd+json": {
      source: "iana",
      compressible: !0
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: !0
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: !0,
      extensions: ["jsonml"]
    },
    "application/jwk+json": {
      source: "iana",
      compressible: !0
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: !0
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: !0
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: !0
    },
    "application/ld+json": {
      source: "iana",
      compressible: !0,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: !0
    },
    "application/lost+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: !0
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: !1
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      charset: "UTF-8",
      compressible: !0,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: !0
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: !0
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xdf"]
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xdf"]
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/msword": {
      source: "iana",
      compressible: !1,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: !0
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: !0
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: !1,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: !0
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: !1,
      extensions: ["ogx"]
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: !0
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: !1,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: !1,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana"
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["asc", "sig"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/postscript": {
      source: "iana",
      compressible: !0,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: !0
    },
    "application/problem+json": {
      source: "iana",
      compressible: !0
    },
    "application/problem+xml": {
      source: "iana",
      compressible: !0
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["provx"]
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: !1
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: !0
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: !0
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: !0,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: !0
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "iana"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: !0
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: !0
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: !0
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rusd"]
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: !0,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: !0
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: !0
    },
    "application/sarif+json": {
      source: "iana",
      compressible: !0
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: !0
    },
    "application/scim+json": {
      source: "iana",
      compressible: !0
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: !0
    },
    "application/senml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: !0
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: !0
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: !0
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: !0
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "iana"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: !0
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["srx"]
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: !0
    },
    "application/sql": {
      source: "iana"
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["ssdl"]
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["ssml"]
    },
    "application/stix+json": {
      source: "iana",
      compressible: !0
    },
    "application/swid+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: !0
    },
    "application/taxii+json": {
      source: "iana",
      compressible: !0
    },
    "application/td+json": {
      source: "iana",
      compressible: !0
    },
    "application/tei+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: !0
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/toml": {
      compressible: !0,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana"
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: !1,
      extensions: ["ubj"]
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: !0
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vcard+json": {
      source: "iana",
      compressible: !0
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["1km"]
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: !1,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.ah-barcode": {
      source: "iana"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: !1,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: !1,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: !0,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.frogans.fnc": {
      source: "iana",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "iana",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.geo+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.geocube+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.google-apps.document": {
      compressible: !1,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.presentation": {
      compressible: !1,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: !1,
      extensions: ["gsheet"]
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: !1,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.informix-visionary": {
      source: "iana"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana"
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: !1,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: !0,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: !0
    },
    "application/vnd.ms-outlook": {
      compressible: !1,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: !1,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: !0
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: !1,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: !1,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: !1,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: !1,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: !1,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["osm"]
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: !1,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: !1,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: !1,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["musicxml"]
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["uoml"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.youtube.yt": {
      source: "iana"
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: !0
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      compressible: !0,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: !0
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: !0
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: !1,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: !1,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: !1,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: !1,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: !1,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: !1
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: !1,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: !0,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: !1,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: !0
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: !1,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: !1
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: !0,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: !1,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: !1,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: !0,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: !1,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: !1,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: !0,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: !0,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: !0,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: !0,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: !0,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: !1,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: !0,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: !0,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: !0,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: !0,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: !0
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: !1,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: !0
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xer"]
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: !0
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xenc"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: !0
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: !0,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: !0
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: !0
    },
    "application/xop+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: !0
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: !0
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: !0
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: !0
    },
    "application/yin+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: !1,
      extensions: ["zip"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: !1,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana"
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana"
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: !1,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: !1
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: !1,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: !1,
      extensions: ["m4a", "mp4a"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: !1,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: !1,
      extensions: ["oga", "ogg", "spx"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: !1
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: !1
    },
    "audio/vorbis": {
      source: "iana",
      compressible: !1
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: !1,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: !1,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: !1,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: !1,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: !1,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: !0,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: !0,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      compressible: !1,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana"
    },
    "image/avcs": {
      source: "iana"
    },
    "image/avif": {
      compressible: !1,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: !0,
      extensions: ["bmp"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: !1,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/hsj2": {
      source: "iana",
      extensions: ["hsj2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: !1,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: !1,
      extensions: ["jpeg", "jpg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: !1,
      extensions: ["jpm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: !1,
      extensions: ["jpx", "jpf"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: !1
    },
    "image/png": {
      source: "iana",
      compressible: !1,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: !1,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: !0,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "apache",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: !0,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: !0,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: !1
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: !1
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: !0
    },
    "message/news": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: !1
    },
    "message/rfc822": {
      source: "iana",
      compressible: !0,
      extensions: ["eml", "mime"]
    },
    "message/s-http": {
      source: "iana"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "iana"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: !0,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: !0,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: !1,
      extensions: ["igs", "iges"]
    },
    "model/mesh": {
      source: "iana",
      compressible: !1,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: !0
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: !1,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: !1,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: !1,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: !1,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: !1
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: !1
    },
    "multipart/form-data": {
      source: "iana",
      compressible: !1
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: !1
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: !1
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: !0,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: !0
    },
    "text/cmd": {
      compressible: !0
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: !0,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "iana"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: !0,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      compressible: !0
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: !0,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: !0,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: !0,
      extensions: ["markdown", "md"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: !0,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: !0,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: !0,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: !0,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: !0,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: !0,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: !0,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "iana"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["vtt"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: !0
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: !0
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: !0,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: !0,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: !0,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: !0,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana"
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: !1,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: !1,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: !1,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: !1,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: !1,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: !1,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: !1,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: !1,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: !0
    },
    "x-shader/x-vertex": {
      compressible: !0
    }
  };
});

// ../node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports2, module2) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * MIT Licensed
   */
  module2.exports = require_db();
});

// ../node_modules/mime-types/index.js
var require_mime_types = __commonJS((exports2) => {
  /*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  var db = require_mime_db(), extname = require("path").extname, EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/, TEXT_TYPE_REGEXP = /^text\//i;
  exports2.charset = charset;
  exports2.charsets = {lookup: charset};
  exports2.contentType = contentType2;
  exports2.extension = extension;
  exports2.extensions = Object.create(null);
  exports2.lookup = lookup;
  exports2.types = Object.create(null);
  populateMaps(exports2.extensions, exports2.types);
  function charset(type3) {
    if (!type3 || typeof type3 != "string")
      return !1;
    var match = EXTRACT_TYPE_REGEXP.exec(type3), mime = match && db[match[1].toLowerCase()];
    return mime && mime.charset ? mime.charset : match && TEXT_TYPE_REGEXP.test(match[1]) ? "UTF-8" : !1;
  }
  __name(charset, "charset");
  function contentType2(str) {
    if (!str || typeof str != "string")
      return !1;
    var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
    if (!mime)
      return !1;
    if (mime.indexOf("charset") === -1) {
      var charset2 = exports2.charset(mime);
      charset2 && (mime += "; charset=" + charset2.toLowerCase());
    }
    return mime;
  }
  __name(contentType2, "contentType");
  function extension(type3) {
    if (!type3 || typeof type3 != "string")
      return !1;
    var match = EXTRACT_TYPE_REGEXP.exec(type3), exts = match && exports2.extensions[match[1].toLowerCase()];
    return !exts || !exts.length ? !1 : exts[0];
  }
  __name(extension, "extension");
  function lookup(path3) {
    if (!path3 || typeof path3 != "string")
      return !1;
    var extension2 = extname("x." + path3).toLowerCase().substr(1);
    return extension2 && exports2.types[extension2] || !1;
  }
  __name(lookup, "lookup");
  function populateMaps(extensions, types) {
    var preference = ["nginx", "apache", void 0, "iana"];
    Object.keys(db).forEach(/* @__PURE__ */ __name(function(type3) {
      var mime = db[type3], exts = mime.extensions;
      if (!(!exts || !exts.length)) {
        extensions[type3] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source), to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/"))
              continue;
          }
          types[extension2] = type3;
        }
      }
    }, "forEachMimeType"));
  }
  __name(populateMaps, "populateMaps");
});

// ../node_modules/asynckit/lib/defer.js
var require_defer = __commonJS((exports2, module2) => {
  module2.exports = defer;
  function defer(fn) {
    var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
    nextTick ? nextTick(fn) : setTimeout(fn, 0);
  }
  __name(defer, "defer");
});

// ../node_modules/asynckit/lib/async.js
var require_async = __commonJS((exports2, module2) => {
  var defer = require_defer();
  module2.exports = async;
  function async(callback) {
    var isAsync = !1;
    return defer(function() {
      isAsync = !0;
    }), /* @__PURE__ */ __name(function(err, result) {
      isAsync ? callback(err, result) : defer(/* @__PURE__ */ __name(function() {
        callback(err, result);
      }, "nextTick_callback"));
    }, "async_callback");
  }
  __name(async, "async");
});

// ../node_modules/asynckit/lib/abort.js
var require_abort = __commonJS((exports2, module2) => {
  module2.exports = abort;
  function abort(state) {
    Object.keys(state.jobs).forEach(clean.bind(state)), state.jobs = {};
  }
  __name(abort, "abort");
  function clean(key) {
    typeof this.jobs[key] == "function" && this.jobs[key]();
  }
  __name(clean, "clean");
});

// ../node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS((exports2, module2) => {
  var async = require_async(), abort = require_abort();
  module2.exports = iterate;
  function iterate(list, iterator, state, callback) {
    var key = state.keyedList ? state.keyedList[state.index] : state.index;
    state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
      key in state.jobs && (delete state.jobs[key], error ? abort(state) : state.results[key] = output, callback(error, state.results));
    });
  }
  __name(iterate, "iterate");
  function runJob(iterator, key, item, callback) {
    var aborter;
    return iterator.length == 2 ? aborter = iterator(item, async(callback)) : aborter = iterator(item, key, async(callback)), aborter;
  }
  __name(runJob, "runJob");
});

// ../node_modules/asynckit/lib/state.js
var require_state = __commonJS((exports2, module2) => {
  module2.exports = state;
  function state(list, sortMethod) {
    var isNamedList = !Array.isArray(list), initState = {
      index: 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs: {},
      results: isNamedList ? {} : [],
      size: isNamedList ? Object.keys(list).length : list.length
    };
    return sortMethod && initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
      return sortMethod(list[a], list[b]);
    }), initState;
  }
  __name(state, "state");
});

// ../node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS((exports2, module2) => {
  var abort = require_abort(), async = require_async();
  module2.exports = terminator;
  function terminator(callback) {
    !Object.keys(this.jobs).length || (this.index = this.size, abort(this), async(callback)(null, this.results));
  }
  __name(terminator, "terminator");
});

// ../node_modules/asynckit/parallel.js
var require_parallel = __commonJS((exports2, module2) => {
  var iterate = require_iterate(), initState = require_state(), terminator = require_terminator();
  module2.exports = parallel;
  function parallel(list, iterator, callback) {
    for (var state = initState(list); state.index < (state.keyedList || list).length; )
      iterate(list, iterator, state, function(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        if (Object.keys(state.jobs).length === 0) {
          callback(null, state.results);
          return;
        }
      }), state.index++;
    return terminator.bind(state, callback);
  }
  __name(parallel, "parallel");
});

// ../node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS((exports2, module2) => {
  var iterate = require_iterate(), initState = require_state(), terminator = require_terminator();
  module2.exports = serialOrdered;
  module2.exports.ascending = ascending;
  module2.exports.descending = descending;
  function serialOrdered(list, iterator, sortMethod, callback) {
    var state = initState(list, sortMethod);
    return iterate(list, iterator, state, /* @__PURE__ */ __name(function iteratorHandler(error, result) {
      if (error) {
        callback(error, result);
        return;
      }
      if (state.index++, state.index < (state.keyedList || list).length) {
        iterate(list, iterator, state, iteratorHandler);
        return;
      }
      callback(null, state.results);
    }, "iteratorHandler")), terminator.bind(state, callback);
  }
  __name(serialOrdered, "serialOrdered");
  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  __name(ascending, "ascending");
  function descending(a, b) {
    return -1 * ascending(a, b);
  }
  __name(descending, "descending");
});

// ../node_modules/asynckit/serial.js
var require_serial = __commonJS((exports2, module2) => {
  var serialOrdered = require_serialOrdered();
  module2.exports = serial;
  function serial(list, iterator, callback) {
    return serialOrdered(list, iterator, null, callback);
  }
  __name(serial, "serial");
});

// ../node_modules/asynckit/index.js
var require_asynckit = __commonJS((exports2, module2) => {
  module2.exports = {
    parallel: require_parallel(),
    serial: require_serial(),
    serialOrdered: require_serialOrdered()
  };
});

// ../node_modules/form-data/lib/populate.js
var require_populate = __commonJS((exports2, module2) => {
  module2.exports = function(dst, src) {
    return Object.keys(src).forEach(function(prop) {
      dst[prop] = dst[prop] || src[prop];
    }), dst;
  };
});

// ../node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS((exports2, module2) => {
  var CombinedStream = require_combined_stream(), util3 = require("util"), path3 = require("path"), http3 = require("http"), https3 = require("https"), parseUrl = require("url").parse, fs4 = require("fs"), mime = require_mime_types(), asynckit = require_asynckit(), populate = require_populate();
  module2.exports = FormData2;
  util3.inherits(FormData2, CombinedStream);
  function FormData2(options) {
    if (!(this instanceof FormData2))
      return new FormData2(options);
    this._overheadLength = 0, this._valueLength = 0, this._valuesToMeasure = [], CombinedStream.call(this), options = options || {};
    for (var option in options)
      this[option] = options[option];
  }
  __name(FormData2, "FormData");
  FormData2.LINE_BREAK = `\r
`;
  FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
  FormData2.prototype.append = function(field, value, options) {
    options = options || {}, typeof options == "string" && (options = {filename: options});
    var append = CombinedStream.prototype.append.bind(this);
    if (typeof value == "number" && (value = "" + value), util3.isArray(value)) {
      this._error(new Error("Arrays are not supported."));
      return;
    }
    var header = this._multiPartHeader(field, value, options), footer = this._multiPartFooter();
    append(header), append(value), append(footer), this._trackLength(header, value, options);
  };
  FormData2.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    options.knownLength != null ? valueLength += +options.knownLength : Buffer.isBuffer(value) ? valueLength = value.length : typeof value == "string" && (valueLength = Buffer.byteLength(value)), this._valueLength += valueLength, this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length, !(!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion"))) && (options.knownLength || this._valuesToMeasure.push(value));
  };
  FormData2.prototype._lengthRetriever = function(value, callback) {
    value.hasOwnProperty("fd") ? value.end != null && value.end != Infinity && value.start != null ? callback(null, value.end + 1 - (value.start ? value.start : 0)) : fs4.stat(value.path, function(err, stat2) {
      var fileSize;
      if (err) {
        callback(err);
        return;
      }
      fileSize = stat2.size - (value.start ? value.start : 0), callback(null, fileSize);
    }) : value.hasOwnProperty("httpVersion") ? callback(null, +value.headers["content-length"]) : value.hasOwnProperty("httpModule") ? (value.on("response", function(response) {
      value.pause(), callback(null, +response.headers["content-length"]);
    }), value.resume()) : callback("Unknown stream");
  };
  FormData2.prototype._multiPartHeader = function(field, value, options) {
    if (typeof options.header == "string")
      return options.header;
    var contentDisposition2 = this._getContentDisposition(value, options), contentType2 = this._getContentType(value, options), contents = "", headers = {
      "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition2 || []),
      "Content-Type": [].concat(contentType2 || [])
    };
    typeof options.header == "object" && populate(headers, options.header);
    var header;
    for (var prop in headers)
      !headers.hasOwnProperty(prop) || (header = headers[prop], header != null && (Array.isArray(header) || (header = [header]), header.length && (contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK)));
    return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
  };
  FormData2.prototype._getContentDisposition = function(value, options) {
    var filename, contentDisposition2;
    return typeof options.filepath == "string" ? filename = path3.normalize(options.filepath).replace(/\\/g, "/") : options.filename || value.name || value.path ? filename = path3.basename(options.filename || value.name || value.path) : value.readable && value.hasOwnProperty("httpVersion") && (filename = path3.basename(value.client._httpMessage.path || "")), filename && (contentDisposition2 = 'filename="' + filename + '"'), contentDisposition2;
  };
  FormData2.prototype._getContentType = function(value, options) {
    var contentType2 = options.contentType;
    return !contentType2 && value.name && (contentType2 = mime.lookup(value.name)), !contentType2 && value.path && (contentType2 = mime.lookup(value.path)), !contentType2 && value.readable && value.hasOwnProperty("httpVersion") && (contentType2 = value.headers["content-type"]), !contentType2 && (options.filepath || options.filename) && (contentType2 = mime.lookup(options.filepath || options.filename)), !contentType2 && typeof value == "object" && (contentType2 = FormData2.DEFAULT_CONTENT_TYPE), contentType2;
  };
  FormData2.prototype._multiPartFooter = function() {
    return function(next) {
      var footer = FormData2.LINE_BREAK, lastPart = this._streams.length === 0;
      lastPart && (footer += this._lastBoundary()), next(footer);
    }.bind(this);
  };
  FormData2.prototype._lastBoundary = function() {
    return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
  };
  FormData2.prototype.getHeaders = function(userHeaders) {
    var header, formHeaders = {
      "content-type": "multipart/form-data; boundary=" + this.getBoundary()
    };
    for (header in userHeaders)
      userHeaders.hasOwnProperty(header) && (formHeaders[header.toLowerCase()] = userHeaders[header]);
    return formHeaders;
  };
  FormData2.prototype.getBoundary = function() {
    return this._boundary || this._generateBoundary(), this._boundary;
  };
  FormData2.prototype.getBuffer = function() {
    for (var dataBuffer = new Buffer.alloc(0), boundary = this.getBoundary(), i = 0, len = this._streams.length; i < len; i++)
      typeof this._streams[i] != "function" && (Buffer.isBuffer(this._streams[i]) ? dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]) : dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]), (typeof this._streams[i] != "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) && (dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)])));
    return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
  };
  FormData2.prototype._generateBoundary = function() {
    for (var boundary = "--------------------------", i = 0; i < 24; i++)
      boundary += Math.floor(Math.random() * 10).toString(16);
    this._boundary = boundary;
  };
  FormData2.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    return this._streams.length && (knownLength += this._lastBoundary().length), this.hasKnownLength() || this._error(new Error("Cannot calculate proper length in synchronous way.")), knownLength;
  };
  FormData2.prototype.hasKnownLength = function() {
    var hasKnownLength = !0;
    return this._valuesToMeasure.length && (hasKnownLength = !1), hasKnownLength;
  };
  FormData2.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length && (knownLength += this._lastBoundary().length), !this._valuesToMeasure.length) {
      process.nextTick(cb.bind(this, null, knownLength));
      return;
    }
    asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
      if (err) {
        cb(err);
        return;
      }
      values.forEach(function(length) {
        knownLength += length;
      }), cb(null, knownLength);
    });
  };
  FormData2.prototype.submit = function(params, cb) {
    var request, options, defaults = {method: "post"};
    return typeof params == "string" ? (params = parseUrl(params), options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults)) : (options = populate(params, defaults), options.port || (options.port = options.protocol == "https:" ? 443 : 80)), options.headers = this.getHeaders(params.headers), options.protocol == "https:" ? request = https3.request(options) : request = http3.request(options), this.getLength(function(err, length) {
      if (err) {
        this._error(err);
        return;
      }
      if (request.setHeader("Content-Length", length), this.pipe(request), cb) {
        var onResponse, callback = /* @__PURE__ */ __name(function(error, responce) {
          return request.removeListener("error", callback), request.removeListener("response", onResponse), cb.call(this, error, responce);
        }, "callback");
        onResponse = callback.bind(this, null), request.on("error", callback), request.on("response", onResponse);
      }
    }.bind(this)), request;
  };
  FormData2.prototype._error = function(err) {
    this.error || (this.error = err, this.pause(), this.emit("error", err));
  };
  FormData2.prototype.toString = function() {
    return "[object FormData]";
  };
});

// ../node_modules/xml2js/lib/defaults.js
var require_defaults = __commonJS((exports2) => {
  (function() {
    exports2.defaults = {
      "0.1": {
        explicitCharkey: !1,
        trim: !0,
        normalize: !0,
        normalizeTags: !1,
        attrkey: "@",
        charkey: "#",
        explicitArray: !1,
        ignoreAttrs: !1,
        mergeAttrs: !1,
        explicitRoot: !1,
        validator: null,
        xmlns: !1,
        explicitChildren: !1,
        childkey: "@@",
        charsAsChildren: !1,
        includeWhiteChars: !1,
        async: !1,
        strict: !0,
        attrNameProcessors: null,
        attrValueProcessors: null,
        tagNameProcessors: null,
        valueProcessors: null,
        emptyTag: ""
      },
      "0.2": {
        explicitCharkey: !1,
        trim: !1,
        normalize: !1,
        normalizeTags: !1,
        attrkey: "$",
        charkey: "_",
        explicitArray: !0,
        ignoreAttrs: !1,
        mergeAttrs: !1,
        explicitRoot: !0,
        validator: null,
        xmlns: !1,
        explicitChildren: !1,
        preserveChildrenOrder: !1,
        childkey: "$$",
        charsAsChildren: !1,
        includeWhiteChars: !1,
        async: !1,
        strict: !0,
        attrNameProcessors: null,
        attrValueProcessors: null,
        tagNameProcessors: null,
        valueProcessors: null,
        rootName: "root",
        xmldec: {
          version: "1.0",
          encoding: "UTF-8",
          standalone: !0
        },
        doctype: null,
        renderOpts: {
          pretty: !0,
          indent: "  ",
          newline: `
`
        },
        headless: !1,
        chunkSize: 1e4,
        emptyTag: "",
        cdata: !1
      }
    };
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/Utility.js
var require_Utility = __commonJS((exports2, module2) => {
  (function() {
    var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject, slice = [].slice, hasProp = {}.hasOwnProperty;
    assign = /* @__PURE__ */ __name(function() {
      var i, key, len, source, sources, target;
      if (target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [], isFunction(Object.assign))
        Object.assign.apply(null, arguments);
      else
        for (i = 0, len = sources.length; i < len; i++)
          if (source = sources[i], source != null)
            for (key in source)
              !hasProp.call(source, key) || (target[key] = source[key]);
      return target;
    }, "assign"), isFunction = /* @__PURE__ */ __name(function(val) {
      return !!val && Object.prototype.toString.call(val) === "[object Function]";
    }, "isFunction"), isObject = /* @__PURE__ */ __name(function(val) {
      var ref;
      return !!val && ((ref = typeof val) === "function" || ref === "object");
    }, "isObject"), isArray = /* @__PURE__ */ __name(function(val) {
      return isFunction(Array.isArray) ? Array.isArray(val) : Object.prototype.toString.call(val) === "[object Array]";
    }, "isArray"), isEmpty = /* @__PURE__ */ __name(function(val) {
      var key;
      if (isArray(val))
        return !val.length;
      for (key in val)
        if (!!hasProp.call(val, key))
          return !1;
      return !0;
    }, "isEmpty"), isPlainObject = /* @__PURE__ */ __name(function(val) {
      var ctor, proto;
      return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor == "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
    }, "isPlainObject"), getValue = /* @__PURE__ */ __name(function(obj) {
      return isFunction(obj.valueOf) ? obj.valueOf() : obj;
    }, "getValue"), module2.exports.assign = assign, module2.exports.isFunction = isFunction, module2.exports.isObject = isObject, module2.exports.isArray = isArray, module2.exports.isEmpty = isEmpty, module2.exports.isPlainObject = isPlainObject, module2.exports.getValue = getValue;
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLDOMImplementation.js
var require_XMLDOMImplementation = __commonJS((exports2, module2) => {
  (function() {
    var XMLDOMImplementation;
    module2.exports = XMLDOMImplementation = function() {
      function XMLDOMImplementation2() {
      }
      return __name(XMLDOMImplementation2, "XMLDOMImplementation"), XMLDOMImplementation2.prototype.hasFeature = function(feature, version2) {
        return !0;
      }, XMLDOMImplementation2.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
        throw new Error("This DOM method is not implemented.");
      }, XMLDOMImplementation2.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
        throw new Error("This DOM method is not implemented.");
      }, XMLDOMImplementation2.prototype.createHTMLDocument = function(title) {
        throw new Error("This DOM method is not implemented.");
      }, XMLDOMImplementation2.prototype.getFeature = function(feature, version2) {
        throw new Error("This DOM method is not implemented.");
      }, XMLDOMImplementation2;
    }();
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js
var require_XMLDOMErrorHandler = __commonJS((exports2, module2) => {
  (function() {
    var XMLDOMErrorHandler;
    module2.exports = XMLDOMErrorHandler = function() {
      function XMLDOMErrorHandler2() {
      }
      return __name(XMLDOMErrorHandler2, "XMLDOMErrorHandler"), XMLDOMErrorHandler2.prototype.handleError = function(error) {
        throw new Error(error);
      }, XMLDOMErrorHandler2;
    }();
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLDOMStringList.js
var require_XMLDOMStringList = __commonJS((exports2, module2) => {
  (function() {
    var XMLDOMStringList;
    module2.exports = XMLDOMStringList = function() {
      function XMLDOMStringList2(arr) {
        this.arr = arr || [];
      }
      return __name(XMLDOMStringList2, "XMLDOMStringList"), Object.defineProperty(XMLDOMStringList2.prototype, "length", {
        get: function() {
          return this.arr.length;
        }
      }), XMLDOMStringList2.prototype.item = function(index) {
        return this.arr[index] || null;
      }, XMLDOMStringList2.prototype.contains = function(str) {
        return this.arr.indexOf(str) !== -1;
      }, XMLDOMStringList2;
    }();
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLDOMConfiguration.js
var require_XMLDOMConfiguration = __commonJS((exports2, module2) => {
  (function() {
    var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;
    XMLDOMErrorHandler = require_XMLDOMErrorHandler(), XMLDOMStringList = require_XMLDOMStringList(), module2.exports = XMLDOMConfiguration = function() {
      function XMLDOMConfiguration2() {
        var clonedSelf;
        this.defaultParams = {
          "canonical-form": !1,
          "cdata-sections": !1,
          comments: !1,
          "datatype-normalization": !1,
          "element-content-whitespace": !0,
          entities: !0,
          "error-handler": new XMLDOMErrorHandler(),
          infoset: !0,
          "validate-if-schema": !1,
          namespaces: !0,
          "namespace-declarations": !0,
          "normalize-characters": !1,
          "schema-location": "",
          "schema-type": "",
          "split-cdata-sections": !0,
          validate: !1,
          "well-formed": !0
        }, this.params = clonedSelf = Object.create(this.defaultParams);
      }
      return __name(XMLDOMConfiguration2, "XMLDOMConfiguration"), Object.defineProperty(XMLDOMConfiguration2.prototype, "parameterNames", {
        get: function() {
          return new XMLDOMStringList(Object.keys(this.defaultParams));
        }
      }), XMLDOMConfiguration2.prototype.getParameter = function(name) {
        return this.params.hasOwnProperty(name) ? this.params[name] : null;
      }, XMLDOMConfiguration2.prototype.canSetParameter = function(name, value) {
        return !0;
      }, XMLDOMConfiguration2.prototype.setParameter = function(name, value) {
        return value != null ? this.params[name] = value : delete this.params[name];
      }, XMLDOMConfiguration2;
    }();
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/NodeType.js
var require_NodeType = __commonJS((exports2, module2) => {
  (function() {
    module2.exports = {
      Element: 1,
      Attribute: 2,
      Text: 3,
      CData: 4,
      EntityReference: 5,
      EntityDeclaration: 6,
      ProcessingInstruction: 7,
      Comment: 8,
      Document: 9,
      DocType: 10,
      DocumentFragment: 11,
      NotationDeclaration: 12,
      Declaration: 201,
      Raw: 202,
      AttributeDeclaration: 203,
      ElementDeclaration: 204,
      Dummy: 205
    };
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLAttribute.js
var require_XMLAttribute = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLAttribute, XMLNode;
    NodeType = require_NodeType(), XMLNode = require_XMLNode(), module2.exports = XMLAttribute = function() {
      function XMLAttribute2(parent, name, value) {
        if (this.parent = parent, this.parent && (this.options = this.parent.options, this.stringify = this.parent.stringify), name == null)
          throw new Error("Missing attribute name. " + this.debugInfo(name));
        this.name = this.stringify.name(name), this.value = this.stringify.attValue(value), this.type = NodeType.Attribute, this.isId = !1, this.schemaTypeInfo = null;
      }
      return __name(XMLAttribute2, "XMLAttribute"), Object.defineProperty(XMLAttribute2.prototype, "nodeType", {
        get: function() {
          return this.type;
        }
      }), Object.defineProperty(XMLAttribute2.prototype, "ownerElement", {
        get: function() {
          return this.parent;
        }
      }), Object.defineProperty(XMLAttribute2.prototype, "textContent", {
        get: function() {
          return this.value;
        },
        set: function(value) {
          return this.value = value || "";
        }
      }), Object.defineProperty(XMLAttribute2.prototype, "namespaceURI", {
        get: function() {
          return "";
        }
      }), Object.defineProperty(XMLAttribute2.prototype, "prefix", {
        get: function() {
          return "";
        }
      }), Object.defineProperty(XMLAttribute2.prototype, "localName", {
        get: function() {
          return this.name;
        }
      }), Object.defineProperty(XMLAttribute2.prototype, "specified", {
        get: function() {
          return !0;
        }
      }), XMLAttribute2.prototype.clone = function() {
        return Object.create(this);
      }, XMLAttribute2.prototype.toString = function(options) {
        return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
      }, XMLAttribute2.prototype.debugInfo = function(name) {
        return name = name || this.name, name == null ? "parent: <" + this.parent.name + ">" : "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
      }, XMLAttribute2.prototype.isEqualNode = function(node) {
        return !(node.namespaceURI !== this.namespaceURI || node.prefix !== this.prefix || node.localName !== this.localName || node.value !== this.value);
      }, XMLAttribute2;
    }();
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLNamedNodeMap.js
var require_XMLNamedNodeMap = __commonJS((exports2, module2) => {
  (function() {
    var XMLNamedNodeMap;
    module2.exports = XMLNamedNodeMap = function() {
      function XMLNamedNodeMap2(nodes) {
        this.nodes = nodes;
      }
      return __name(XMLNamedNodeMap2, "XMLNamedNodeMap"), Object.defineProperty(XMLNamedNodeMap2.prototype, "length", {
        get: function() {
          return Object.keys(this.nodes).length || 0;
        }
      }), XMLNamedNodeMap2.prototype.clone = function() {
        return this.nodes = null;
      }, XMLNamedNodeMap2.prototype.getNamedItem = function(name) {
        return this.nodes[name];
      }, XMLNamedNodeMap2.prototype.setNamedItem = function(node) {
        var oldNode;
        return oldNode = this.nodes[node.nodeName], this.nodes[node.nodeName] = node, oldNode || null;
      }, XMLNamedNodeMap2.prototype.removeNamedItem = function(name) {
        var oldNode;
        return oldNode = this.nodes[name], delete this.nodes[name], oldNode || null;
      }, XMLNamedNodeMap2.prototype.item = function(index) {
        return this.nodes[Object.keys(this.nodes)[index]] || null;
      }, XMLNamedNodeMap2.prototype.getNamedItemNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented.");
      }, XMLNamedNodeMap2.prototype.setNamedItemNS = function(node) {
        throw new Error("This DOM method is not implemented.");
      }, XMLNamedNodeMap2.prototype.removeNamedItemNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented.");
      }, XMLNamedNodeMap2;
    }();
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLElement.js
var require_XMLElement = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLAttribute, XMLElement, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, ref, extend2 = /* @__PURE__ */ __name(function(child, parent) {
      for (var key in parent)
        hasProp.call(parent, key) && (child[key] = parent[key]);
      function ctor() {
        this.constructor = child;
      }
      return __name(ctor, "ctor"), ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, child;
    }, "extend"), hasProp = {}.hasOwnProperty;
    ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue, XMLNode = require_XMLNode(), NodeType = require_NodeType(), XMLAttribute = require_XMLAttribute(), XMLNamedNodeMap = require_XMLNamedNodeMap(), module2.exports = XMLElement = function(superClass) {
      extend2(XMLElement2, superClass);
      function XMLElement2(parent, name, attributes) {
        var child, j, len, ref1;
        if (XMLElement2.__super__.constructor.call(this, parent), name == null)
          throw new Error("Missing element name. " + this.debugInfo());
        if (this.name = this.stringify.name(name), this.type = NodeType.Element, this.attribs = {}, this.schemaTypeInfo = null, attributes != null && this.attribute(attributes), parent.type === NodeType.Document && (this.isRoot = !0, this.documentObject = parent, parent.rootObject = this, parent.children)) {
          for (ref1 = parent.children, j = 0, len = ref1.length; j < len; j++)
            if (child = ref1[j], child.type === NodeType.DocType) {
              child.name = this.name;
              break;
            }
        }
      }
      return __name(XMLElement2, "XMLElement"), Object.defineProperty(XMLElement2.prototype, "tagName", {
        get: function() {
          return this.name;
        }
      }), Object.defineProperty(XMLElement2.prototype, "namespaceURI", {
        get: function() {
          return "";
        }
      }), Object.defineProperty(XMLElement2.prototype, "prefix", {
        get: function() {
          return "";
        }
      }), Object.defineProperty(XMLElement2.prototype, "localName", {
        get: function() {
          return this.name;
        }
      }), Object.defineProperty(XMLElement2.prototype, "id", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), Object.defineProperty(XMLElement2.prototype, "className", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), Object.defineProperty(XMLElement2.prototype, "classList", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), Object.defineProperty(XMLElement2.prototype, "attributes", {
        get: function() {
          return (!this.attributeMap || !this.attributeMap.nodes) && (this.attributeMap = new XMLNamedNodeMap(this.attribs)), this.attributeMap;
        }
      }), XMLElement2.prototype.clone = function() {
        var att, attName, clonedSelf, ref1;
        clonedSelf = Object.create(this), clonedSelf.isRoot && (clonedSelf.documentObject = null), clonedSelf.attribs = {}, ref1 = this.attribs;
        for (attName in ref1)
          !hasProp.call(ref1, attName) || (att = ref1[attName], clonedSelf.attribs[attName] = att.clone());
        return clonedSelf.children = [], this.children.forEach(function(child) {
          var clonedChild;
          return clonedChild = child.clone(), clonedChild.parent = clonedSelf, clonedSelf.children.push(clonedChild);
        }), clonedSelf;
      }, XMLElement2.prototype.attribute = function(name, value) {
        var attName, attValue;
        if (name != null && (name = getValue(name)), isObject(name))
          for (attName in name)
            !hasProp.call(name, attName) || (attValue = name[attName], this.attribute(attName, attValue));
        else
          isFunction(value) && (value = value.apply()), this.options.keepNullAttributes && value == null ? this.attribs[name] = new XMLAttribute(this, name, "") : value != null && (this.attribs[name] = new XMLAttribute(this, name, value));
        return this;
      }, XMLElement2.prototype.removeAttribute = function(name) {
        var attName, j, len;
        if (name == null)
          throw new Error("Missing attribute name. " + this.debugInfo());
        if (name = getValue(name), Array.isArray(name))
          for (j = 0, len = name.length; j < len; j++)
            attName = name[j], delete this.attribs[attName];
        else
          delete this.attribs[name];
        return this;
      }, XMLElement2.prototype.toString = function(options) {
        return this.options.writer.element(this, this.options.writer.filterOptions(options));
      }, XMLElement2.prototype.att = function(name, value) {
        return this.attribute(name, value);
      }, XMLElement2.prototype.a = function(name, value) {
        return this.attribute(name, value);
      }, XMLElement2.prototype.getAttribute = function(name) {
        return this.attribs.hasOwnProperty(name) ? this.attribs[name].value : null;
      }, XMLElement2.prototype.setAttribute = function(name, value) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLElement2.prototype.getAttributeNode = function(name) {
        return this.attribs.hasOwnProperty(name) ? this.attribs[name] : null;
      }, XMLElement2.prototype.setAttributeNode = function(newAttr) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLElement2.prototype.removeAttributeNode = function(oldAttr) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLElement2.prototype.getElementsByTagName = function(name) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLElement2.prototype.getAttributeNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLElement2.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLElement2.prototype.removeAttributeNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLElement2.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLElement2.prototype.setAttributeNodeNS = function(newAttr) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLElement2.prototype.hasAttribute = function(name) {
        return this.attribs.hasOwnProperty(name);
      }, XMLElement2.prototype.hasAttributeNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLElement2.prototype.setIdAttribute = function(name, isId) {
        return this.attribs.hasOwnProperty(name) ? this.attribs[name].isId : isId;
      }, XMLElement2.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLElement2.prototype.setIdAttributeNode = function(idAttr, isId) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLElement2.prototype.getElementsByTagName = function(tagname) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLElement2.prototype.getElementsByClassName = function(classNames) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLElement2.prototype.isEqualNode = function(node) {
        var i, j, ref1;
        if (!XMLElement2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node) || node.namespaceURI !== this.namespaceURI || node.prefix !== this.prefix || node.localName !== this.localName || node.attribs.length !== this.attribs.length)
          return !1;
        for (i = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j)
          if (!this.attribs[i].isEqualNode(node.attribs[i]))
            return !1;
        return !0;
      }, XMLElement2;
    }(XMLNode);
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLCharacterData.js
var require_XMLCharacterData = __commonJS((exports2, module2) => {
  (function() {
    var XMLCharacterData, XMLNode, extend2 = /* @__PURE__ */ __name(function(child, parent) {
      for (var key in parent)
        hasProp.call(parent, key) && (child[key] = parent[key]);
      function ctor() {
        this.constructor = child;
      }
      return __name(ctor, "ctor"), ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, child;
    }, "extend"), hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode(), module2.exports = XMLCharacterData = function(superClass) {
      extend2(XMLCharacterData2, superClass);
      function XMLCharacterData2(parent) {
        XMLCharacterData2.__super__.constructor.call(this, parent), this.value = "";
      }
      return __name(XMLCharacterData2, "XMLCharacterData"), Object.defineProperty(XMLCharacterData2.prototype, "data", {
        get: function() {
          return this.value;
        },
        set: function(value) {
          return this.value = value || "";
        }
      }), Object.defineProperty(XMLCharacterData2.prototype, "length", {
        get: function() {
          return this.value.length;
        }
      }), Object.defineProperty(XMLCharacterData2.prototype, "textContent", {
        get: function() {
          return this.value;
        },
        set: function(value) {
          return this.value = value || "";
        }
      }), XMLCharacterData2.prototype.clone = function() {
        return Object.create(this);
      }, XMLCharacterData2.prototype.substringData = function(offset, count) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLCharacterData2.prototype.appendData = function(arg) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLCharacterData2.prototype.insertData = function(offset, arg) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLCharacterData2.prototype.deleteData = function(offset, count) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLCharacterData2.prototype.replaceData = function(offset, count, arg) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLCharacterData2.prototype.isEqualNode = function(node) {
        return !(!XMLCharacterData2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node) || node.data !== this.data);
      }, XMLCharacterData2;
    }(XMLNode);
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLCData.js
var require_XMLCData = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLCData, XMLCharacterData, extend2 = /* @__PURE__ */ __name(function(child, parent) {
      for (var key in parent)
        hasProp.call(parent, key) && (child[key] = parent[key]);
      function ctor() {
        this.constructor = child;
      }
      return __name(ctor, "ctor"), ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, child;
    }, "extend"), hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType(), XMLCharacterData = require_XMLCharacterData(), module2.exports = XMLCData = function(superClass) {
      extend2(XMLCData2, superClass);
      function XMLCData2(parent, text) {
        if (XMLCData2.__super__.constructor.call(this, parent), text == null)
          throw new Error("Missing CDATA text. " + this.debugInfo());
        this.name = "#cdata-section", this.type = NodeType.CData, this.value = this.stringify.cdata(text);
      }
      return __name(XMLCData2, "XMLCData"), XMLCData2.prototype.clone = function() {
        return Object.create(this);
      }, XMLCData2.prototype.toString = function(options) {
        return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
      }, XMLCData2;
    }(XMLCharacterData);
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLComment.js
var require_XMLComment = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLCharacterData, XMLComment, extend2 = /* @__PURE__ */ __name(function(child, parent) {
      for (var key in parent)
        hasProp.call(parent, key) && (child[key] = parent[key]);
      function ctor() {
        this.constructor = child;
      }
      return __name(ctor, "ctor"), ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, child;
    }, "extend"), hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType(), XMLCharacterData = require_XMLCharacterData(), module2.exports = XMLComment = function(superClass) {
      extend2(XMLComment2, superClass);
      function XMLComment2(parent, text) {
        if (XMLComment2.__super__.constructor.call(this, parent), text == null)
          throw new Error("Missing comment text. " + this.debugInfo());
        this.name = "#comment", this.type = NodeType.Comment, this.value = this.stringify.comment(text);
      }
      return __name(XMLComment2, "XMLComment"), XMLComment2.prototype.clone = function() {
        return Object.create(this);
      }, XMLComment2.prototype.toString = function(options) {
        return this.options.writer.comment(this, this.options.writer.filterOptions(options));
      }, XMLComment2;
    }(XMLCharacterData);
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLDeclaration.js
var require_XMLDeclaration = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLDeclaration, XMLNode, isObject, extend2 = /* @__PURE__ */ __name(function(child, parent) {
      for (var key in parent)
        hasProp.call(parent, key) && (child[key] = parent[key]);
      function ctor() {
        this.constructor = child;
      }
      return __name(ctor, "ctor"), ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, child;
    }, "extend"), hasProp = {}.hasOwnProperty;
    isObject = require_Utility().isObject, XMLNode = require_XMLNode(), NodeType = require_NodeType(), module2.exports = XMLDeclaration = function(superClass) {
      extend2(XMLDeclaration2, superClass);
      function XMLDeclaration2(parent, version2, encoding, standalone) {
        var ref;
        XMLDeclaration2.__super__.constructor.call(this, parent), isObject(version2) && (ref = version2, version2 = ref.version, encoding = ref.encoding, standalone = ref.standalone), version2 || (version2 = "1.0"), this.type = NodeType.Declaration, this.version = this.stringify.xmlVersion(version2), encoding != null && (this.encoding = this.stringify.xmlEncoding(encoding)), standalone != null && (this.standalone = this.stringify.xmlStandalone(standalone));
      }
      return __name(XMLDeclaration2, "XMLDeclaration"), XMLDeclaration2.prototype.toString = function(options) {
        return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
      }, XMLDeclaration2;
    }(XMLNode);
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLDTDAttList.js
var require_XMLDTDAttList = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLDTDAttList, XMLNode, extend2 = /* @__PURE__ */ __name(function(child, parent) {
      for (var key in parent)
        hasProp.call(parent, key) && (child[key] = parent[key]);
      function ctor() {
        this.constructor = child;
      }
      return __name(ctor, "ctor"), ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, child;
    }, "extend"), hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode(), NodeType = require_NodeType(), module2.exports = XMLDTDAttList = function(superClass) {
      extend2(XMLDTDAttList2, superClass);
      function XMLDTDAttList2(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        if (XMLDTDAttList2.__super__.constructor.call(this, parent), elementName == null)
          throw new Error("Missing DTD element name. " + this.debugInfo());
        if (attributeName == null)
          throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
        if (!attributeType)
          throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
        if (!defaultValueType)
          throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
        if (defaultValueType.indexOf("#") !== 0 && (defaultValueType = "#" + defaultValueType), !defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/))
          throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
        if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/))
          throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
        this.elementName = this.stringify.name(elementName), this.type = NodeType.AttributeDeclaration, this.attributeName = this.stringify.name(attributeName), this.attributeType = this.stringify.dtdAttType(attributeType), defaultValue && (this.defaultValue = this.stringify.dtdAttDefault(defaultValue)), this.defaultValueType = defaultValueType;
      }
      return __name(XMLDTDAttList2, "XMLDTDAttList"), XMLDTDAttList2.prototype.toString = function(options) {
        return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
      }, XMLDTDAttList2;
    }(XMLNode);
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLDTDEntity.js
var require_XMLDTDEntity = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLDTDEntity, XMLNode, isObject, extend2 = /* @__PURE__ */ __name(function(child, parent) {
      for (var key in parent)
        hasProp.call(parent, key) && (child[key] = parent[key]);
      function ctor() {
        this.constructor = child;
      }
      return __name(ctor, "ctor"), ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, child;
    }, "extend"), hasProp = {}.hasOwnProperty;
    isObject = require_Utility().isObject, XMLNode = require_XMLNode(), NodeType = require_NodeType(), module2.exports = XMLDTDEntity = function(superClass) {
      extend2(XMLDTDEntity2, superClass);
      function XMLDTDEntity2(parent, pe, name, value) {
        if (XMLDTDEntity2.__super__.constructor.call(this, parent), name == null)
          throw new Error("Missing DTD entity name. " + this.debugInfo(name));
        if (value == null)
          throw new Error("Missing DTD entity value. " + this.debugInfo(name));
        if (this.pe = !!pe, this.name = this.stringify.name(name), this.type = NodeType.EntityDeclaration, !isObject(value))
          this.value = this.stringify.dtdEntityValue(value), this.internal = !0;
        else {
          if (!value.pubID && !value.sysID)
            throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
          if (value.pubID && !value.sysID)
            throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
          if (this.internal = !1, value.pubID != null && (this.pubID = this.stringify.dtdPubID(value.pubID)), value.sysID != null && (this.sysID = this.stringify.dtdSysID(value.sysID)), value.nData != null && (this.nData = this.stringify.dtdNData(value.nData)), this.pe && this.nData)
            throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
        }
      }
      return __name(XMLDTDEntity2, "XMLDTDEntity"), Object.defineProperty(XMLDTDEntity2.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      }), Object.defineProperty(XMLDTDEntity2.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      }), Object.defineProperty(XMLDTDEntity2.prototype, "notationName", {
        get: function() {
          return this.nData || null;
        }
      }), Object.defineProperty(XMLDTDEntity2.prototype, "inputEncoding", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(XMLDTDEntity2.prototype, "xmlEncoding", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(XMLDTDEntity2.prototype, "xmlVersion", {
        get: function() {
          return null;
        }
      }), XMLDTDEntity2.prototype.toString = function(options) {
        return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
      }, XMLDTDEntity2;
    }(XMLNode);
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLDTDElement.js
var require_XMLDTDElement = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLDTDElement, XMLNode, extend2 = /* @__PURE__ */ __name(function(child, parent) {
      for (var key in parent)
        hasProp.call(parent, key) && (child[key] = parent[key]);
      function ctor() {
        this.constructor = child;
      }
      return __name(ctor, "ctor"), ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, child;
    }, "extend"), hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode(), NodeType = require_NodeType(), module2.exports = XMLDTDElement = function(superClass) {
      extend2(XMLDTDElement2, superClass);
      function XMLDTDElement2(parent, name, value) {
        if (XMLDTDElement2.__super__.constructor.call(this, parent), name == null)
          throw new Error("Missing DTD element name. " + this.debugInfo());
        value || (value = "(#PCDATA)"), Array.isArray(value) && (value = "(" + value.join(",") + ")"), this.name = this.stringify.name(name), this.type = NodeType.ElementDeclaration, this.value = this.stringify.dtdElementValue(value);
      }
      return __name(XMLDTDElement2, "XMLDTDElement"), XMLDTDElement2.prototype.toString = function(options) {
        return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
      }, XMLDTDElement2;
    }(XMLNode);
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLDTDNotation.js
var require_XMLDTDNotation = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLDTDNotation, XMLNode, extend2 = /* @__PURE__ */ __name(function(child, parent) {
      for (var key in parent)
        hasProp.call(parent, key) && (child[key] = parent[key]);
      function ctor() {
        this.constructor = child;
      }
      return __name(ctor, "ctor"), ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, child;
    }, "extend"), hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode(), NodeType = require_NodeType(), module2.exports = XMLDTDNotation = function(superClass) {
      extend2(XMLDTDNotation2, superClass);
      function XMLDTDNotation2(parent, name, value) {
        if (XMLDTDNotation2.__super__.constructor.call(this, parent), name == null)
          throw new Error("Missing DTD notation name. " + this.debugInfo(name));
        if (!value.pubID && !value.sysID)
          throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
        this.name = this.stringify.name(name), this.type = NodeType.NotationDeclaration, value.pubID != null && (this.pubID = this.stringify.dtdPubID(value.pubID)), value.sysID != null && (this.sysID = this.stringify.dtdSysID(value.sysID));
      }
      return __name(XMLDTDNotation2, "XMLDTDNotation"), Object.defineProperty(XMLDTDNotation2.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      }), Object.defineProperty(XMLDTDNotation2.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      }), XMLDTDNotation2.prototype.toString = function(options) {
        return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
      }, XMLDTDNotation2;
    }(XMLNode);
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLDocType.js
var require_XMLDocType = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNamedNodeMap, XMLNode, isObject, extend2 = /* @__PURE__ */ __name(function(child, parent) {
      for (var key in parent)
        hasProp.call(parent, key) && (child[key] = parent[key]);
      function ctor() {
        this.constructor = child;
      }
      return __name(ctor, "ctor"), ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, child;
    }, "extend"), hasProp = {}.hasOwnProperty;
    isObject = require_Utility().isObject, XMLNode = require_XMLNode(), NodeType = require_NodeType(), XMLDTDAttList = require_XMLDTDAttList(), XMLDTDEntity = require_XMLDTDEntity(), XMLDTDElement = require_XMLDTDElement(), XMLDTDNotation = require_XMLDTDNotation(), XMLNamedNodeMap = require_XMLNamedNodeMap(), module2.exports = XMLDocType = function(superClass) {
      extend2(XMLDocType2, superClass);
      function XMLDocType2(parent, pubID, sysID) {
        var child, i, len, ref, ref1, ref2;
        if (XMLDocType2.__super__.constructor.call(this, parent), this.type = NodeType.DocType, parent.children) {
          for (ref = parent.children, i = 0, len = ref.length; i < len; i++)
            if (child = ref[i], child.type === NodeType.Element) {
              this.name = child.name;
              break;
            }
        }
        this.documentObject = parent, isObject(pubID) && (ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID), sysID == null && (ref2 = [pubID, sysID], sysID = ref2[0], pubID = ref2[1]), pubID != null && (this.pubID = this.stringify.dtdPubID(pubID)), sysID != null && (this.sysID = this.stringify.dtdSysID(sysID));
      }
      return __name(XMLDocType2, "XMLDocType"), Object.defineProperty(XMLDocType2.prototype, "entities", {
        get: function() {
          var child, i, len, nodes, ref;
          for (nodes = {}, ref = this.children, i = 0, len = ref.length; i < len; i++)
            child = ref[i], child.type === NodeType.EntityDeclaration && !child.pe && (nodes[child.name] = child);
          return new XMLNamedNodeMap(nodes);
        }
      }), Object.defineProperty(XMLDocType2.prototype, "notations", {
        get: function() {
          var child, i, len, nodes, ref;
          for (nodes = {}, ref = this.children, i = 0, len = ref.length; i < len; i++)
            child = ref[i], child.type === NodeType.NotationDeclaration && (nodes[child.name] = child);
          return new XMLNamedNodeMap(nodes);
        }
      }), Object.defineProperty(XMLDocType2.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      }), Object.defineProperty(XMLDocType2.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      }), Object.defineProperty(XMLDocType2.prototype, "internalSubset", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), XMLDocType2.prototype.element = function(name, value) {
        var child;
        return child = new XMLDTDElement(this, name, value), this.children.push(child), this;
      }, XMLDocType2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        var child;
        return child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue), this.children.push(child), this;
      }, XMLDocType2.prototype.entity = function(name, value) {
        var child;
        return child = new XMLDTDEntity(this, !1, name, value), this.children.push(child), this;
      }, XMLDocType2.prototype.pEntity = function(name, value) {
        var child;
        return child = new XMLDTDEntity(this, !0, name, value), this.children.push(child), this;
      }, XMLDocType2.prototype.notation = function(name, value) {
        var child;
        return child = new XMLDTDNotation(this, name, value), this.children.push(child), this;
      }, XMLDocType2.prototype.toString = function(options) {
        return this.options.writer.docType(this, this.options.writer.filterOptions(options));
      }, XMLDocType2.prototype.ele = function(name, value) {
        return this.element(name, value);
      }, XMLDocType2.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
      }, XMLDocType2.prototype.ent = function(name, value) {
        return this.entity(name, value);
      }, XMLDocType2.prototype.pent = function(name, value) {
        return this.pEntity(name, value);
      }, XMLDocType2.prototype.not = function(name, value) {
        return this.notation(name, value);
      }, XMLDocType2.prototype.up = function() {
        return this.root() || this.documentObject;
      }, XMLDocType2.prototype.isEqualNode = function(node) {
        return !(!XMLDocType2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node) || node.name !== this.name || node.publicId !== this.publicId || node.systemId !== this.systemId);
      }, XMLDocType2;
    }(XMLNode);
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLRaw.js
var require_XMLRaw = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLNode, XMLRaw, extend2 = /* @__PURE__ */ __name(function(child, parent) {
      for (var key in parent)
        hasProp.call(parent, key) && (child[key] = parent[key]);
      function ctor() {
        this.constructor = child;
      }
      return __name(ctor, "ctor"), ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, child;
    }, "extend"), hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType(), XMLNode = require_XMLNode(), module2.exports = XMLRaw = function(superClass) {
      extend2(XMLRaw2, superClass);
      function XMLRaw2(parent, text) {
        if (XMLRaw2.__super__.constructor.call(this, parent), text == null)
          throw new Error("Missing raw text. " + this.debugInfo());
        this.type = NodeType.Raw, this.value = this.stringify.raw(text);
      }
      return __name(XMLRaw2, "XMLRaw"), XMLRaw2.prototype.clone = function() {
        return Object.create(this);
      }, XMLRaw2.prototype.toString = function(options) {
        return this.options.writer.raw(this, this.options.writer.filterOptions(options));
      }, XMLRaw2;
    }(XMLNode);
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLText.js
var require_XMLText = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLCharacterData, XMLText, extend2 = /* @__PURE__ */ __name(function(child, parent) {
      for (var key in parent)
        hasProp.call(parent, key) && (child[key] = parent[key]);
      function ctor() {
        this.constructor = child;
      }
      return __name(ctor, "ctor"), ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, child;
    }, "extend"), hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType(), XMLCharacterData = require_XMLCharacterData(), module2.exports = XMLText = function(superClass) {
      extend2(XMLText2, superClass);
      function XMLText2(parent, text) {
        if (XMLText2.__super__.constructor.call(this, parent), text == null)
          throw new Error("Missing element text. " + this.debugInfo());
        this.name = "#text", this.type = NodeType.Text, this.value = this.stringify.text(text);
      }
      return __name(XMLText2, "XMLText"), Object.defineProperty(XMLText2.prototype, "isElementContentWhitespace", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), Object.defineProperty(XMLText2.prototype, "wholeText", {
        get: function() {
          var next, prev, str;
          for (str = "", prev = this.previousSibling; prev; )
            str = prev.data + str, prev = prev.previousSibling;
          for (str += this.data, next = this.nextSibling; next; )
            str = str + next.data, next = next.nextSibling;
          return str;
        }
      }), XMLText2.prototype.clone = function() {
        return Object.create(this);
      }, XMLText2.prototype.toString = function(options) {
        return this.options.writer.text(this, this.options.writer.filterOptions(options));
      }, XMLText2.prototype.splitText = function(offset) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLText2.prototype.replaceWholeText = function(content) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLText2;
    }(XMLCharacterData);
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLProcessingInstruction.js
var require_XMLProcessingInstruction = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLCharacterData, XMLProcessingInstruction, extend2 = /* @__PURE__ */ __name(function(child, parent) {
      for (var key in parent)
        hasProp.call(parent, key) && (child[key] = parent[key]);
      function ctor() {
        this.constructor = child;
      }
      return __name(ctor, "ctor"), ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, child;
    }, "extend"), hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType(), XMLCharacterData = require_XMLCharacterData(), module2.exports = XMLProcessingInstruction = function(superClass) {
      extend2(XMLProcessingInstruction2, superClass);
      function XMLProcessingInstruction2(parent, target, value) {
        if (XMLProcessingInstruction2.__super__.constructor.call(this, parent), target == null)
          throw new Error("Missing instruction target. " + this.debugInfo());
        this.type = NodeType.ProcessingInstruction, this.target = this.stringify.insTarget(target), this.name = this.target, value && (this.value = this.stringify.insValue(value));
      }
      return __name(XMLProcessingInstruction2, "XMLProcessingInstruction"), XMLProcessingInstruction2.prototype.clone = function() {
        return Object.create(this);
      }, XMLProcessingInstruction2.prototype.toString = function(options) {
        return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
      }, XMLProcessingInstruction2.prototype.isEqualNode = function(node) {
        return !(!XMLProcessingInstruction2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node) || node.target !== this.target);
      }, XMLProcessingInstruction2;
    }(XMLCharacterData);
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLDummy.js
var require_XMLDummy = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLDummy, XMLNode, extend2 = /* @__PURE__ */ __name(function(child, parent) {
      for (var key in parent)
        hasProp.call(parent, key) && (child[key] = parent[key]);
      function ctor() {
        this.constructor = child;
      }
      return __name(ctor, "ctor"), ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, child;
    }, "extend"), hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode(), NodeType = require_NodeType(), module2.exports = XMLDummy = function(superClass) {
      extend2(XMLDummy2, superClass);
      function XMLDummy2(parent) {
        XMLDummy2.__super__.constructor.call(this, parent), this.type = NodeType.Dummy;
      }
      return __name(XMLDummy2, "XMLDummy"), XMLDummy2.prototype.clone = function() {
        return Object.create(this);
      }, XMLDummy2.prototype.toString = function(options) {
        return "";
      }, XMLDummy2;
    }(XMLNode);
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLNodeList.js
var require_XMLNodeList = __commonJS((exports2, module2) => {
  (function() {
    var XMLNodeList;
    module2.exports = XMLNodeList = function() {
      function XMLNodeList2(nodes) {
        this.nodes = nodes;
      }
      return __name(XMLNodeList2, "XMLNodeList"), Object.defineProperty(XMLNodeList2.prototype, "length", {
        get: function() {
          return this.nodes.length || 0;
        }
      }), XMLNodeList2.prototype.clone = function() {
        return this.nodes = null;
      }, XMLNodeList2.prototype.item = function(index) {
        return this.nodes[index] || null;
      }, XMLNodeList2;
    }();
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/DocumentPosition.js
var require_DocumentPosition = __commonJS((exports2, module2) => {
  (function() {
    module2.exports = {
      Disconnected: 1,
      Preceding: 2,
      Following: 4,
      Contains: 8,
      ContainedBy: 16,
      ImplementationSpecific: 32
    };
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLNode.js
var require_XMLNode = __commonJS((exports2, module2) => {
  (function() {
    var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, ref1, hasProp = {}.hasOwnProperty;
    ref1 = require_Utility(), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue, XMLElement = null, XMLCData = null, XMLComment = null, XMLDeclaration = null, XMLDocType = null, XMLRaw = null, XMLText = null, XMLProcessingInstruction = null, XMLDummy = null, NodeType = null, XMLNodeList = null, XMLNamedNodeMap = null, DocumentPosition = null, module2.exports = XMLNode = function() {
      function XMLNode2(parent1) {
        this.parent = parent1, this.parent && (this.options = this.parent.options, this.stringify = this.parent.stringify), this.value = null, this.children = [], this.baseURI = null, XMLElement || (XMLElement = require_XMLElement(), XMLCData = require_XMLCData(), XMLComment = require_XMLComment(), XMLDeclaration = require_XMLDeclaration(), XMLDocType = require_XMLDocType(), XMLRaw = require_XMLRaw(), XMLText = require_XMLText(), XMLProcessingInstruction = require_XMLProcessingInstruction(), XMLDummy = require_XMLDummy(), NodeType = require_NodeType(), XMLNodeList = require_XMLNodeList(), XMLNamedNodeMap = require_XMLNamedNodeMap(), DocumentPosition = require_DocumentPosition());
      }
      return __name(XMLNode2, "XMLNode"), Object.defineProperty(XMLNode2.prototype, "nodeName", {
        get: function() {
          return this.name;
        }
      }), Object.defineProperty(XMLNode2.prototype, "nodeType", {
        get: function() {
          return this.type;
        }
      }), Object.defineProperty(XMLNode2.prototype, "nodeValue", {
        get: function() {
          return this.value;
        }
      }), Object.defineProperty(XMLNode2.prototype, "parentNode", {
        get: function() {
          return this.parent;
        }
      }), Object.defineProperty(XMLNode2.prototype, "childNodes", {
        get: function() {
          return (!this.childNodeList || !this.childNodeList.nodes) && (this.childNodeList = new XMLNodeList(this.children)), this.childNodeList;
        }
      }), Object.defineProperty(XMLNode2.prototype, "firstChild", {
        get: function() {
          return this.children[0] || null;
        }
      }), Object.defineProperty(XMLNode2.prototype, "lastChild", {
        get: function() {
          return this.children[this.children.length - 1] || null;
        }
      }), Object.defineProperty(XMLNode2.prototype, "previousSibling", {
        get: function() {
          var i;
          return i = this.parent.children.indexOf(this), this.parent.children[i - 1] || null;
        }
      }), Object.defineProperty(XMLNode2.prototype, "nextSibling", {
        get: function() {
          var i;
          return i = this.parent.children.indexOf(this), this.parent.children[i + 1] || null;
        }
      }), Object.defineProperty(XMLNode2.prototype, "ownerDocument", {
        get: function() {
          return this.document() || null;
        }
      }), Object.defineProperty(XMLNode2.prototype, "textContent", {
        get: function() {
          var child, j, len, ref2, str;
          if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
            for (str = "", ref2 = this.children, j = 0, len = ref2.length; j < len; j++)
              child = ref2[j], child.textContent && (str += child.textContent);
            return str;
          } else
            return null;
        },
        set: function(value) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), XMLNode2.prototype.setParent = function(parent) {
        var child, j, len, ref2, results;
        for (this.parent = parent, parent && (this.options = parent.options, this.stringify = parent.stringify), ref2 = this.children, results = [], j = 0, len = ref2.length; j < len; j++)
          child = ref2[j], results.push(child.setParent(this));
        return results;
      }, XMLNode2.prototype.element = function(name, attributes, text) {
        var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;
        if (lastChild = null, attributes === null && text == null && (ref2 = [{}, null], attributes = ref2[0], text = ref2[1]), attributes == null && (attributes = {}), attributes = getValue(attributes), isObject(attributes) || (ref3 = [attributes, text], text = ref3[0], attributes = ref3[1]), name != null && (name = getValue(name)), Array.isArray(name))
          for (j = 0, len = name.length; j < len; j++)
            item = name[j], lastChild = this.element(item);
        else if (isFunction(name))
          lastChild = this.element(name.apply());
        else if (isObject(name)) {
          for (key in name)
            if (!!hasProp.call(name, key))
              if (val = name[key], isFunction(val) && (val = val.apply()), !this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0)
                lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
              else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val))
                lastChild = this.dummy();
              else if (isObject(val) && isEmpty(val))
                lastChild = this.element(key);
              else if (!this.options.keepNullNodes && val == null)
                lastChild = this.dummy();
              else if (!this.options.separateArrayItems && Array.isArray(val))
                for (k = 0, len1 = val.length; k < len1; k++)
                  item = val[k], childNode = {}, childNode[key] = item, lastChild = this.element(childNode);
              else
                isObject(val) ? !this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0 ? lastChild = this.element(val) : (lastChild = this.element(key), lastChild.element(val)) : lastChild = this.element(key, val);
        } else
          !this.options.keepNullNodes && text === null ? lastChild = this.dummy() : !this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0 ? lastChild = this.text(text) : !this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0 ? lastChild = this.cdata(text) : !this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0 ? lastChild = this.comment(text) : !this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0 ? lastChild = this.raw(text) : !this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0 ? lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text) : lastChild = this.node(name, attributes, text);
        if (lastChild == null)
          throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
        return lastChild;
      }, XMLNode2.prototype.insertBefore = function(name, attributes, text) {
        var child, i, newChild, refChild, removed;
        if (name != null ? name.type : void 0)
          return newChild = name, refChild = attributes, newChild.setParent(this), refChild ? (i = children.indexOf(refChild), removed = children.splice(i), children.push(newChild), Array.prototype.push.apply(children, removed)) : children.push(newChild), newChild;
        if (this.isRoot)
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
        return i = this.parent.children.indexOf(this), removed = this.parent.children.splice(i), child = this.parent.element(name, attributes, text), Array.prototype.push.apply(this.parent.children, removed), child;
      }, XMLNode2.prototype.insertAfter = function(name, attributes, text) {
        var child, i, removed;
        if (this.isRoot)
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
        return i = this.parent.children.indexOf(this), removed = this.parent.children.splice(i + 1), child = this.parent.element(name, attributes, text), Array.prototype.push.apply(this.parent.children, removed), child;
      }, XMLNode2.prototype.remove = function() {
        var i, ref2;
        if (this.isRoot)
          throw new Error("Cannot remove the root element. " + this.debugInfo());
        return i = this.parent.children.indexOf(this), [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref2 = [])), this.parent;
      }, XMLNode2.prototype.node = function(name, attributes, text) {
        var child, ref2;
        return name != null && (name = getValue(name)), attributes || (attributes = {}), attributes = getValue(attributes), isObject(attributes) || (ref2 = [attributes, text], text = ref2[0], attributes = ref2[1]), child = new XMLElement(this, name, attributes), text != null && child.text(text), this.children.push(child), child;
      }, XMLNode2.prototype.text = function(value) {
        var child;
        return isObject(value) && this.element(value), child = new XMLText(this, value), this.children.push(child), this;
      }, XMLNode2.prototype.cdata = function(value) {
        var child;
        return child = new XMLCData(this, value), this.children.push(child), this;
      }, XMLNode2.prototype.comment = function(value) {
        var child;
        return child = new XMLComment(this, value), this.children.push(child), this;
      }, XMLNode2.prototype.commentBefore = function(value) {
        var child, i, removed;
        return i = this.parent.children.indexOf(this), removed = this.parent.children.splice(i), child = this.parent.comment(value), Array.prototype.push.apply(this.parent.children, removed), this;
      }, XMLNode2.prototype.commentAfter = function(value) {
        var child, i, removed;
        return i = this.parent.children.indexOf(this), removed = this.parent.children.splice(i + 1), child = this.parent.comment(value), Array.prototype.push.apply(this.parent.children, removed), this;
      }, XMLNode2.prototype.raw = function(value) {
        var child;
        return child = new XMLRaw(this, value), this.children.push(child), this;
      }, XMLNode2.prototype.dummy = function() {
        var child;
        return child = new XMLDummy(this), child;
      }, XMLNode2.prototype.instruction = function(target, value) {
        var insTarget, insValue, instruction, j, len;
        if (target != null && (target = getValue(target)), value != null && (value = getValue(value)), Array.isArray(target))
          for (j = 0, len = target.length; j < len; j++)
            insTarget = target[j], this.instruction(insTarget);
        else if (isObject(target))
          for (insTarget in target)
            !hasProp.call(target, insTarget) || (insValue = target[insTarget], this.instruction(insTarget, insValue));
        else
          isFunction(value) && (value = value.apply()), instruction = new XMLProcessingInstruction(this, target, value), this.children.push(instruction);
        return this;
      }, XMLNode2.prototype.instructionBefore = function(target, value) {
        var child, i, removed;
        return i = this.parent.children.indexOf(this), removed = this.parent.children.splice(i), child = this.parent.instruction(target, value), Array.prototype.push.apply(this.parent.children, removed), this;
      }, XMLNode2.prototype.instructionAfter = function(target, value) {
        var child, i, removed;
        return i = this.parent.children.indexOf(this), removed = this.parent.children.splice(i + 1), child = this.parent.instruction(target, value), Array.prototype.push.apply(this.parent.children, removed), this;
      }, XMLNode2.prototype.declaration = function(version2, encoding, standalone) {
        var doc, xmldec;
        return doc = this.document(), xmldec = new XMLDeclaration(doc, version2, encoding, standalone), doc.children.length === 0 ? doc.children.unshift(xmldec) : doc.children[0].type === NodeType.Declaration ? doc.children[0] = xmldec : doc.children.unshift(xmldec), doc.root() || doc;
      }, XMLNode2.prototype.dtd = function(pubID, sysID) {
        var child, doc, doctype, i, j, k, len, len1, ref2, ref3;
        for (doc = this.document(), doctype = new XMLDocType(doc, pubID, sysID), ref2 = doc.children, i = j = 0, len = ref2.length; j < len; i = ++j)
          if (child = ref2[i], child.type === NodeType.DocType)
            return doc.children[i] = doctype, doctype;
        for (ref3 = doc.children, i = k = 0, len1 = ref3.length; k < len1; i = ++k)
          if (child = ref3[i], child.isRoot)
            return doc.children.splice(i, 0, doctype), doctype;
        return doc.children.push(doctype), doctype;
      }, XMLNode2.prototype.up = function() {
        if (this.isRoot)
          throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
        return this.parent;
      }, XMLNode2.prototype.root = function() {
        var node;
        for (node = this; node; ) {
          if (node.type === NodeType.Document)
            return node.rootObject;
          if (node.isRoot)
            return node;
          node = node.parent;
        }
      }, XMLNode2.prototype.document = function() {
        var node;
        for (node = this; node; ) {
          if (node.type === NodeType.Document)
            return node;
          node = node.parent;
        }
      }, XMLNode2.prototype.end = function(options) {
        return this.document().end(options);
      }, XMLNode2.prototype.prev = function() {
        var i;
        if (i = this.parent.children.indexOf(this), i < 1)
          throw new Error("Already at the first node. " + this.debugInfo());
        return this.parent.children[i - 1];
      }, XMLNode2.prototype.next = function() {
        var i;
        if (i = this.parent.children.indexOf(this), i === -1 || i === this.parent.children.length - 1)
          throw new Error("Already at the last node. " + this.debugInfo());
        return this.parent.children[i + 1];
      }, XMLNode2.prototype.importDocument = function(doc) {
        var clonedRoot;
        return clonedRoot = doc.root().clone(), clonedRoot.parent = this, clonedRoot.isRoot = !1, this.children.push(clonedRoot), this;
      }, XMLNode2.prototype.debugInfo = function(name) {
        var ref2, ref3;
        return name = name || this.name, name == null && !((ref2 = this.parent) != null ? ref2.name : void 0) ? "" : name == null ? "parent: <" + this.parent.name + ">" : ((ref3 = this.parent) != null ? ref3.name : void 0) ? "node: <" + name + ">, parent: <" + this.parent.name + ">" : "node: <" + name + ">";
      }, XMLNode2.prototype.ele = function(name, attributes, text) {
        return this.element(name, attributes, text);
      }, XMLNode2.prototype.nod = function(name, attributes, text) {
        return this.node(name, attributes, text);
      }, XMLNode2.prototype.txt = function(value) {
        return this.text(value);
      }, XMLNode2.prototype.dat = function(value) {
        return this.cdata(value);
      }, XMLNode2.prototype.com = function(value) {
        return this.comment(value);
      }, XMLNode2.prototype.ins = function(target, value) {
        return this.instruction(target, value);
      }, XMLNode2.prototype.doc = function() {
        return this.document();
      }, XMLNode2.prototype.dec = function(version2, encoding, standalone) {
        return this.declaration(version2, encoding, standalone);
      }, XMLNode2.prototype.e = function(name, attributes, text) {
        return this.element(name, attributes, text);
      }, XMLNode2.prototype.n = function(name, attributes, text) {
        return this.node(name, attributes, text);
      }, XMLNode2.prototype.t = function(value) {
        return this.text(value);
      }, XMLNode2.prototype.d = function(value) {
        return this.cdata(value);
      }, XMLNode2.prototype.c = function(value) {
        return this.comment(value);
      }, XMLNode2.prototype.r = function(value) {
        return this.raw(value);
      }, XMLNode2.prototype.i = function(target, value) {
        return this.instruction(target, value);
      }, XMLNode2.prototype.u = function() {
        return this.up();
      }, XMLNode2.prototype.importXMLBuilder = function(doc) {
        return this.importDocument(doc);
      }, XMLNode2.prototype.replaceChild = function(newChild, oldChild) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLNode2.prototype.removeChild = function(oldChild) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLNode2.prototype.appendChild = function(newChild) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLNode2.prototype.hasChildNodes = function() {
        return this.children.length !== 0;
      }, XMLNode2.prototype.cloneNode = function(deep) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLNode2.prototype.normalize = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLNode2.prototype.isSupported = function(feature, version2) {
        return !0;
      }, XMLNode2.prototype.hasAttributes = function() {
        return this.attribs.length !== 0;
      }, XMLNode2.prototype.compareDocumentPosition = function(other) {
        var ref, res;
        return ref = this, ref === other ? 0 : this.document() !== other.document() ? (res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific, Math.random() < 0.5 ? res |= DocumentPosition.Preceding : res |= DocumentPosition.Following, res) : ref.isAncestor(other) ? DocumentPosition.Contains | DocumentPosition.Preceding : ref.isDescendant(other) ? DocumentPosition.Contains | DocumentPosition.Following : ref.isPreceding(other) ? DocumentPosition.Preceding : DocumentPosition.Following;
      }, XMLNode2.prototype.isSameNode = function(other) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLNode2.prototype.lookupPrefix = function(namespaceURI) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLNode2.prototype.isDefaultNamespace = function(namespaceURI) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLNode2.prototype.lookupNamespaceURI = function(prefix2) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLNode2.prototype.isEqualNode = function(node) {
        var i, j, ref2;
        if (node.nodeType !== this.nodeType || node.children.length !== this.children.length)
          return !1;
        for (i = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j)
          if (!this.children[i].isEqualNode(node.children[i]))
            return !1;
        return !0;
      }, XMLNode2.prototype.getFeature = function(feature, version2) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLNode2.prototype.setUserData = function(key, data, handler) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLNode2.prototype.getUserData = function(key) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLNode2.prototype.contains = function(other) {
        return other ? other === this || this.isDescendant(other) : !1;
      }, XMLNode2.prototype.isDescendant = function(node) {
        var child, isDescendantChild, j, len, ref2;
        for (ref2 = this.children, j = 0, len = ref2.length; j < len; j++)
          if (child = ref2[j], node === child || (isDescendantChild = child.isDescendant(node), isDescendantChild))
            return !0;
        return !1;
      }, XMLNode2.prototype.isAncestor = function(node) {
        return node.isDescendant(this);
      }, XMLNode2.prototype.isPreceding = function(node) {
        var nodePos, thisPos;
        return nodePos = this.treePosition(node), thisPos = this.treePosition(this), nodePos === -1 || thisPos === -1 ? !1 : nodePos < thisPos;
      }, XMLNode2.prototype.isFollowing = function(node) {
        var nodePos, thisPos;
        return nodePos = this.treePosition(node), thisPos = this.treePosition(this), nodePos === -1 || thisPos === -1 ? !1 : nodePos > thisPos;
      }, XMLNode2.prototype.treePosition = function(node) {
        var found, pos;
        return pos = 0, found = !1, this.foreachTreeNode(this.document(), function(childNode) {
          if (pos++, !found && childNode === node)
            return found = !0;
        }), found ? pos : -1;
      }, XMLNode2.prototype.foreachTreeNode = function(node, func) {
        var child, j, len, ref2, res;
        for (node || (node = this.document()), ref2 = node.children, j = 0, len = ref2.length; j < len; j++) {
          if (child = ref2[j], res = func(child))
            return res;
          if (res = this.foreachTreeNode(child, func), res)
            return res;
        }
      }, XMLNode2;
    }();
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLStringifier.js
var require_XMLStringifier = __commonJS((exports2, module2) => {
  (function() {
    var XMLStringifier, bind = /* @__PURE__ */ __name(function(fn, me) {
      return function() {
        return fn.apply(me, arguments);
      };
    }, "bind"), hasProp = {}.hasOwnProperty;
    module2.exports = XMLStringifier = function() {
      function XMLStringifier2(options) {
        this.assertLegalName = bind(this.assertLegalName, this), this.assertLegalChar = bind(this.assertLegalChar, this);
        var key, ref, value;
        options || (options = {}), this.options = options, this.options.version || (this.options.version = "1.0"), ref = options.stringify || {};
        for (key in ref)
          !hasProp.call(ref, key) || (value = ref[key], this[key] = value);
      }
      return __name(XMLStringifier2, "XMLStringifier"), XMLStringifier2.prototype.name = function(val) {
        return this.options.noValidation ? val : this.assertLegalName("" + val || "");
      }, XMLStringifier2.prototype.text = function(val) {
        return this.options.noValidation ? val : this.assertLegalChar(this.textEscape("" + val || ""));
      }, XMLStringifier2.prototype.cdata = function(val) {
        return this.options.noValidation ? val : (val = "" + val || "", val = val.replace("]]>", "]]]]><![CDATA[>"), this.assertLegalChar(val));
      }, XMLStringifier2.prototype.comment = function(val) {
        if (this.options.noValidation)
          return val;
        if (val = "" + val || "", val.match(/--/))
          throw new Error("Comment text cannot contain double-hypen: " + val);
        return this.assertLegalChar(val);
      }, XMLStringifier2.prototype.raw = function(val) {
        return this.options.noValidation ? val : "" + val || "";
      }, XMLStringifier2.prototype.attValue = function(val) {
        return this.options.noValidation ? val : this.assertLegalChar(this.attEscape(val = "" + val || ""));
      }, XMLStringifier2.prototype.insTarget = function(val) {
        return this.options.noValidation ? val : this.assertLegalChar("" + val || "");
      }, XMLStringifier2.prototype.insValue = function(val) {
        if (this.options.noValidation)
          return val;
        if (val = "" + val || "", val.match(/\?>/))
          throw new Error("Invalid processing instruction value: " + val);
        return this.assertLegalChar(val);
      }, XMLStringifier2.prototype.xmlVersion = function(val) {
        if (this.options.noValidation)
          return val;
        if (val = "" + val || "", !val.match(/1\.[0-9]+/))
          throw new Error("Invalid version number: " + val);
        return val;
      }, XMLStringifier2.prototype.xmlEncoding = function(val) {
        if (this.options.noValidation)
          return val;
        if (val = "" + val || "", !val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/))
          throw new Error("Invalid encoding: " + val);
        return this.assertLegalChar(val);
      }, XMLStringifier2.prototype.xmlStandalone = function(val) {
        return this.options.noValidation ? val : val ? "yes" : "no";
      }, XMLStringifier2.prototype.dtdPubID = function(val) {
        return this.options.noValidation ? val : this.assertLegalChar("" + val || "");
      }, XMLStringifier2.prototype.dtdSysID = function(val) {
        return this.options.noValidation ? val : this.assertLegalChar("" + val || "");
      }, XMLStringifier2.prototype.dtdElementValue = function(val) {
        return this.options.noValidation ? val : this.assertLegalChar("" + val || "");
      }, XMLStringifier2.prototype.dtdAttType = function(val) {
        return this.options.noValidation ? val : this.assertLegalChar("" + val || "");
      }, XMLStringifier2.prototype.dtdAttDefault = function(val) {
        return this.options.noValidation ? val : this.assertLegalChar("" + val || "");
      }, XMLStringifier2.prototype.dtdEntityValue = function(val) {
        return this.options.noValidation ? val : this.assertLegalChar("" + val || "");
      }, XMLStringifier2.prototype.dtdNData = function(val) {
        return this.options.noValidation ? val : this.assertLegalChar("" + val || "");
      }, XMLStringifier2.prototype.convertAttKey = "@", XMLStringifier2.prototype.convertPIKey = "?", XMLStringifier2.prototype.convertTextKey = "#text", XMLStringifier2.prototype.convertCDataKey = "#cdata", XMLStringifier2.prototype.convertCommentKey = "#comment", XMLStringifier2.prototype.convertRawKey = "#raw", XMLStringifier2.prototype.assertLegalChar = function(str) {
        var regex, res;
        if (this.options.noValidation)
          return str;
        if (regex = "", this.options.version === "1.0") {
          if (regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, res = str.match(regex))
            throw new Error("Invalid character in string: " + str + " at index " + res.index);
        } else if (this.options.version === "1.1" && (regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, res = str.match(regex)))
          throw new Error("Invalid character in string: " + str + " at index " + res.index);
        return str;
      }, XMLStringifier2.prototype.assertLegalName = function(str) {
        var regex;
        if (this.options.noValidation)
          return str;
        if (this.assertLegalChar(str), regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/, !str.match(regex))
          throw new Error("Invalid character in name");
        return str;
      }, XMLStringifier2.prototype.textEscape = function(str) {
        var ampregex;
        return this.options.noValidation ? str : (ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;"));
      }, XMLStringifier2.prototype.attEscape = function(str) {
        var ampregex;
        return this.options.noValidation ? str : (ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;"));
      }, XMLStringifier2;
    }();
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/WriterState.js
var require_WriterState = __commonJS((exports2, module2) => {
  (function() {
    module2.exports = {
      None: 0,
      OpenTag: 1,
      InsideTag: 2,
      CloseTag: 3
    };
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLWriterBase.js
var require_XMLWriterBase = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, WriterState, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase, assign, hasProp = {}.hasOwnProperty;
    assign = require_Utility().assign, NodeType = require_NodeType(), XMLDeclaration = require_XMLDeclaration(), XMLDocType = require_XMLDocType(), XMLCData = require_XMLCData(), XMLComment = require_XMLComment(), XMLElement = require_XMLElement(), XMLRaw = require_XMLRaw(), XMLText = require_XMLText(), XMLProcessingInstruction = require_XMLProcessingInstruction(), XMLDummy = require_XMLDummy(), XMLDTDAttList = require_XMLDTDAttList(), XMLDTDElement = require_XMLDTDElement(), XMLDTDEntity = require_XMLDTDEntity(), XMLDTDNotation = require_XMLDTDNotation(), WriterState = require_WriterState(), module2.exports = XMLWriterBase = function() {
      function XMLWriterBase2(options) {
        var key, ref, value;
        options || (options = {}), this.options = options, ref = options.writer || {};
        for (key in ref)
          !hasProp.call(ref, key) || (value = ref[key], this["_" + key] = this[key], this[key] = value);
      }
      return __name(XMLWriterBase2, "XMLWriterBase"), XMLWriterBase2.prototype.filterOptions = function(options) {
        var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
        return options || (options = {}), options = assign({}, this.options, options), filteredOptions = {
          writer: this
        }, filteredOptions.pretty = options.pretty || !1, filteredOptions.allowEmpty = options.allowEmpty || !1, filteredOptions.indent = (ref = options.indent) != null ? ref : "  ", filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : `
`, filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0, filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0, filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : "", filteredOptions.spaceBeforeSlash === !0 && (filteredOptions.spaceBeforeSlash = " "), filteredOptions.suppressPrettyCount = 0, filteredOptions.user = {}, filteredOptions.state = WriterState.None, filteredOptions;
      }, XMLWriterBase2.prototype.indent = function(node, options, level) {
        var indentLevel;
        return !options.pretty || options.suppressPrettyCount ? "" : options.pretty && (indentLevel = (level || 0) + options.offset + 1, indentLevel > 0) ? new Array(indentLevel).join(options.indent) : "";
      }, XMLWriterBase2.prototype.endline = function(node, options, level) {
        return !options.pretty || options.suppressPrettyCount ? "" : options.newline;
      }, XMLWriterBase2.prototype.attribute = function(att, options, level) {
        var r;
        return this.openAttribute(att, options, level), r = " " + att.name + '="' + att.value + '"', this.closeAttribute(att, options, level), r;
      }, XMLWriterBase2.prototype.cdata = function(node, options, level) {
        var r;
        return this.openNode(node, options, level), options.state = WriterState.OpenTag, r = this.indent(node, options, level) + "<![CDATA[", options.state = WriterState.InsideTag, r += node.value, options.state = WriterState.CloseTag, r += "]]>" + this.endline(node, options, level), options.state = WriterState.None, this.closeNode(node, options, level), r;
      }, XMLWriterBase2.prototype.comment = function(node, options, level) {
        var r;
        return this.openNode(node, options, level), options.state = WriterState.OpenTag, r = this.indent(node, options, level) + "<!-- ", options.state = WriterState.InsideTag, r += node.value, options.state = WriterState.CloseTag, r += " -->" + this.endline(node, options, level), options.state = WriterState.None, this.closeNode(node, options, level), r;
      }, XMLWriterBase2.prototype.declaration = function(node, options, level) {
        var r;
        return this.openNode(node, options, level), options.state = WriterState.OpenTag, r = this.indent(node, options, level) + "<?xml", options.state = WriterState.InsideTag, r += ' version="' + node.version + '"', node.encoding != null && (r += ' encoding="' + node.encoding + '"'), node.standalone != null && (r += ' standalone="' + node.standalone + '"'), options.state = WriterState.CloseTag, r += options.spaceBeforeSlash + "?>", r += this.endline(node, options, level), options.state = WriterState.None, this.closeNode(node, options, level), r;
      }, XMLWriterBase2.prototype.docType = function(node, options, level) {
        var child, i, len, r, ref;
        if (level || (level = 0), this.openNode(node, options, level), options.state = WriterState.OpenTag, r = this.indent(node, options, level), r += "<!DOCTYPE " + node.root().name, node.pubID && node.sysID ? r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"' : node.sysID && (r += ' SYSTEM "' + node.sysID + '"'), node.children.length > 0) {
          for (r += " [", r += this.endline(node, options, level), options.state = WriterState.InsideTag, ref = node.children, i = 0, len = ref.length; i < len; i++)
            child = ref[i], r += this.writeChildNode(child, options, level + 1);
          options.state = WriterState.CloseTag, r += "]";
        }
        return options.state = WriterState.CloseTag, r += options.spaceBeforeSlash + ">", r += this.endline(node, options, level), options.state = WriterState.None, this.closeNode(node, options, level), r;
      }, XMLWriterBase2.prototype.element = function(node, options, level) {
        var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref, ref1, ref2;
        level || (level = 0), prettySuppressed = !1, r = "", this.openNode(node, options, level), options.state = WriterState.OpenTag, r += this.indent(node, options, level) + "<" + node.name, ref = node.attribs;
        for (name in ref)
          !hasProp.call(ref, name) || (att = ref[name], r += this.attribute(att, options, level));
        if (childNodeCount = node.children.length, firstChildNode = childNodeCount === 0 ? null : node.children[0], childNodeCount === 0 || node.children.every(function(e) {
          return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
        }))
          options.allowEmpty ? (r += ">", options.state = WriterState.CloseTag, r += "</" + node.name + ">" + this.endline(node, options, level)) : (options.state = WriterState.CloseTag, r += options.spaceBeforeSlash + "/>" + this.endline(node, options, level));
        else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null)
          r += ">", options.state = WriterState.InsideTag, options.suppressPrettyCount++, prettySuppressed = !0, r += this.writeChildNode(firstChildNode, options, level + 1), options.suppressPrettyCount--, prettySuppressed = !1, options.state = WriterState.CloseTag, r += "</" + node.name + ">" + this.endline(node, options, level);
        else {
          if (options.dontPrettyTextNodes) {
            for (ref1 = node.children, i = 0, len = ref1.length; i < len; i++)
              if (child = ref1[i], (child.type === NodeType.Text || child.type === NodeType.Raw) && child.value != null) {
                options.suppressPrettyCount++, prettySuppressed = !0;
                break;
              }
          }
          for (r += ">" + this.endline(node, options, level), options.state = WriterState.InsideTag, ref2 = node.children, j = 0, len1 = ref2.length; j < len1; j++)
            child = ref2[j], r += this.writeChildNode(child, options, level + 1);
          options.state = WriterState.CloseTag, r += this.indent(node, options, level) + "</" + node.name + ">", prettySuppressed && options.suppressPrettyCount--, r += this.endline(node, options, level), options.state = WriterState.None;
        }
        return this.closeNode(node, options, level), r;
      }, XMLWriterBase2.prototype.writeChildNode = function(node, options, level) {
        switch (node.type) {
          case NodeType.CData:
            return this.cdata(node, options, level);
          case NodeType.Comment:
            return this.comment(node, options, level);
          case NodeType.Element:
            return this.element(node, options, level);
          case NodeType.Raw:
            return this.raw(node, options, level);
          case NodeType.Text:
            return this.text(node, options, level);
          case NodeType.ProcessingInstruction:
            return this.processingInstruction(node, options, level);
          case NodeType.Dummy:
            return "";
          case NodeType.Declaration:
            return this.declaration(node, options, level);
          case NodeType.DocType:
            return this.docType(node, options, level);
          case NodeType.AttributeDeclaration:
            return this.dtdAttList(node, options, level);
          case NodeType.ElementDeclaration:
            return this.dtdElement(node, options, level);
          case NodeType.EntityDeclaration:
            return this.dtdEntity(node, options, level);
          case NodeType.NotationDeclaration:
            return this.dtdNotation(node, options, level);
          default:
            throw new Error("Unknown XML node type: " + node.constructor.name);
        }
      }, XMLWriterBase2.prototype.processingInstruction = function(node, options, level) {
        var r;
        return this.openNode(node, options, level), options.state = WriterState.OpenTag, r = this.indent(node, options, level) + "<?", options.state = WriterState.InsideTag, r += node.target, node.value && (r += " " + node.value), options.state = WriterState.CloseTag, r += options.spaceBeforeSlash + "?>", r += this.endline(node, options, level), options.state = WriterState.None, this.closeNode(node, options, level), r;
      }, XMLWriterBase2.prototype.raw = function(node, options, level) {
        var r;
        return this.openNode(node, options, level), options.state = WriterState.OpenTag, r = this.indent(node, options, level), options.state = WriterState.InsideTag, r += node.value, options.state = WriterState.CloseTag, r += this.endline(node, options, level), options.state = WriterState.None, this.closeNode(node, options, level), r;
      }, XMLWriterBase2.prototype.text = function(node, options, level) {
        var r;
        return this.openNode(node, options, level), options.state = WriterState.OpenTag, r = this.indent(node, options, level), options.state = WriterState.InsideTag, r += node.value, options.state = WriterState.CloseTag, r += this.endline(node, options, level), options.state = WriterState.None, this.closeNode(node, options, level), r;
      }, XMLWriterBase2.prototype.dtdAttList = function(node, options, level) {
        var r;
        return this.openNode(node, options, level), options.state = WriterState.OpenTag, r = this.indent(node, options, level) + "<!ATTLIST", options.state = WriterState.InsideTag, r += " " + node.elementName + " " + node.attributeName + " " + node.attributeType, node.defaultValueType !== "#DEFAULT" && (r += " " + node.defaultValueType), node.defaultValue && (r += ' "' + node.defaultValue + '"'), options.state = WriterState.CloseTag, r += options.spaceBeforeSlash + ">" + this.endline(node, options, level), options.state = WriterState.None, this.closeNode(node, options, level), r;
      }, XMLWriterBase2.prototype.dtdElement = function(node, options, level) {
        var r;
        return this.openNode(node, options, level), options.state = WriterState.OpenTag, r = this.indent(node, options, level) + "<!ELEMENT", options.state = WriterState.InsideTag, r += " " + node.name + " " + node.value, options.state = WriterState.CloseTag, r += options.spaceBeforeSlash + ">" + this.endline(node, options, level), options.state = WriterState.None, this.closeNode(node, options, level), r;
      }, XMLWriterBase2.prototype.dtdEntity = function(node, options, level) {
        var r;
        return this.openNode(node, options, level), options.state = WriterState.OpenTag, r = this.indent(node, options, level) + "<!ENTITY", options.state = WriterState.InsideTag, node.pe && (r += " %"), r += " " + node.name, node.value ? r += ' "' + node.value + '"' : (node.pubID && node.sysID ? r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"' : node.sysID && (r += ' SYSTEM "' + node.sysID + '"'), node.nData && (r += " NDATA " + node.nData)), options.state = WriterState.CloseTag, r += options.spaceBeforeSlash + ">" + this.endline(node, options, level), options.state = WriterState.None, this.closeNode(node, options, level), r;
      }, XMLWriterBase2.prototype.dtdNotation = function(node, options, level) {
        var r;
        return this.openNode(node, options, level), options.state = WriterState.OpenTag, r = this.indent(node, options, level) + "<!NOTATION", options.state = WriterState.InsideTag, r += " " + node.name, node.pubID && node.sysID ? r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"' : node.pubID ? r += ' PUBLIC "' + node.pubID + '"' : node.sysID && (r += ' SYSTEM "' + node.sysID + '"'), options.state = WriterState.CloseTag, r += options.spaceBeforeSlash + ">" + this.endline(node, options, level), options.state = WriterState.None, this.closeNode(node, options, level), r;
      }, XMLWriterBase2.prototype.openNode = function(node, options, level) {
      }, XMLWriterBase2.prototype.closeNode = function(node, options, level) {
      }, XMLWriterBase2.prototype.openAttribute = function(att, options, level) {
      }, XMLWriterBase2.prototype.closeAttribute = function(att, options, level) {
      }, XMLWriterBase2;
    }();
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLStringWriter.js
var require_XMLStringWriter = __commonJS((exports2, module2) => {
  (function() {
    var XMLStringWriter, XMLWriterBase, extend2 = /* @__PURE__ */ __name(function(child, parent) {
      for (var key in parent)
        hasProp.call(parent, key) && (child[key] = parent[key]);
      function ctor() {
        this.constructor = child;
      }
      return __name(ctor, "ctor"), ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, child;
    }, "extend"), hasProp = {}.hasOwnProperty;
    XMLWriterBase = require_XMLWriterBase(), module2.exports = XMLStringWriter = function(superClass) {
      extend2(XMLStringWriter2, superClass);
      function XMLStringWriter2(options) {
        XMLStringWriter2.__super__.constructor.call(this, options);
      }
      return __name(XMLStringWriter2, "XMLStringWriter"), XMLStringWriter2.prototype.document = function(doc, options) {
        var child, i, len, r, ref;
        for (options = this.filterOptions(options), r = "", ref = doc.children, i = 0, len = ref.length; i < len; i++)
          child = ref[i], r += this.writeChildNode(child, options, 0);
        return options.pretty && r.slice(-options.newline.length) === options.newline && (r = r.slice(0, -options.newline.length)), r;
      }, XMLStringWriter2;
    }(XMLWriterBase);
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLDocument.js
var require_XMLDocument = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend2 = /* @__PURE__ */ __name(function(child, parent) {
      for (var key in parent)
        hasProp.call(parent, key) && (child[key] = parent[key]);
      function ctor() {
        this.constructor = child;
      }
      return __name(ctor, "ctor"), ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, child;
    }, "extend"), hasProp = {}.hasOwnProperty;
    isPlainObject = require_Utility().isPlainObject, XMLDOMImplementation = require_XMLDOMImplementation(), XMLDOMConfiguration = require_XMLDOMConfiguration(), XMLNode = require_XMLNode(), NodeType = require_NodeType(), XMLStringifier = require_XMLStringifier(), XMLStringWriter = require_XMLStringWriter(), module2.exports = XMLDocument = function(superClass) {
      extend2(XMLDocument2, superClass);
      function XMLDocument2(options) {
        XMLDocument2.__super__.constructor.call(this, null), this.name = "#document", this.type = NodeType.Document, this.documentURI = null, this.domConfig = new XMLDOMConfiguration(), options || (options = {}), options.writer || (options.writer = new XMLStringWriter()), this.options = options, this.stringify = new XMLStringifier(options);
      }
      return __name(XMLDocument2, "XMLDocument"), Object.defineProperty(XMLDocument2.prototype, "implementation", {
        value: new XMLDOMImplementation()
      }), Object.defineProperty(XMLDocument2.prototype, "doctype", {
        get: function() {
          var child, i, len, ref;
          for (ref = this.children, i = 0, len = ref.length; i < len; i++)
            if (child = ref[i], child.type === NodeType.DocType)
              return child;
          return null;
        }
      }), Object.defineProperty(XMLDocument2.prototype, "documentElement", {
        get: function() {
          return this.rootObject || null;
        }
      }), Object.defineProperty(XMLDocument2.prototype, "inputEncoding", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(XMLDocument2.prototype, "strictErrorChecking", {
        get: function() {
          return !1;
        }
      }), Object.defineProperty(XMLDocument2.prototype, "xmlEncoding", {
        get: function() {
          return this.children.length !== 0 && this.children[0].type === NodeType.Declaration ? this.children[0].encoding : null;
        }
      }), Object.defineProperty(XMLDocument2.prototype, "xmlStandalone", {
        get: function() {
          return this.children.length !== 0 && this.children[0].type === NodeType.Declaration ? this.children[0].standalone === "yes" : !1;
        }
      }), Object.defineProperty(XMLDocument2.prototype, "xmlVersion", {
        get: function() {
          return this.children.length !== 0 && this.children[0].type === NodeType.Declaration ? this.children[0].version : "1.0";
        }
      }), Object.defineProperty(XMLDocument2.prototype, "URL", {
        get: function() {
          return this.documentURI;
        }
      }), Object.defineProperty(XMLDocument2.prototype, "origin", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(XMLDocument2.prototype, "compatMode", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(XMLDocument2.prototype, "characterSet", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(XMLDocument2.prototype, "contentType", {
        get: function() {
          return null;
        }
      }), XMLDocument2.prototype.end = function(writer) {
        var writerOptions;
        return writerOptions = {}, writer ? isPlainObject(writer) && (writerOptions = writer, writer = this.options.writer) : writer = this.options.writer, writer.document(this, writer.filterOptions(writerOptions));
      }, XMLDocument2.prototype.toString = function(options) {
        return this.options.writer.document(this, this.options.writer.filterOptions(options));
      }, XMLDocument2.prototype.createElement = function(tagName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLDocument2.prototype.createDocumentFragment = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLDocument2.prototype.createTextNode = function(data) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLDocument2.prototype.createComment = function(data) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLDocument2.prototype.createCDATASection = function(data) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLDocument2.prototype.createProcessingInstruction = function(target, data) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLDocument2.prototype.createAttribute = function(name) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLDocument2.prototype.createEntityReference = function(name) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLDocument2.prototype.getElementsByTagName = function(tagname) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLDocument2.prototype.importNode = function(importedNode, deep) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLDocument2.prototype.createElementNS = function(namespaceURI, qualifiedName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLDocument2.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLDocument2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLDocument2.prototype.getElementById = function(elementId) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLDocument2.prototype.adoptNode = function(source) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLDocument2.prototype.normalizeDocument = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLDocument2.prototype.renameNode = function(node, namespaceURI, qualifiedName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLDocument2.prototype.getElementsByClassName = function(classNames) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLDocument2.prototype.createEvent = function(eventInterface) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLDocument2.prototype.createRange = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLDocument2.prototype.createNodeIterator = function(root, whatToShow, filter) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLDocument2.prototype.createTreeWalker = function(root, whatToShow, filter) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, XMLDocument2;
    }(XMLNode);
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLDocumentCB.js
var require_XMLDocumentCB = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, ref, hasProp = {}.hasOwnProperty;
    ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue, NodeType = require_NodeType(), XMLDocument = require_XMLDocument(), XMLElement = require_XMLElement(), XMLCData = require_XMLCData(), XMLComment = require_XMLComment(), XMLRaw = require_XMLRaw(), XMLText = require_XMLText(), XMLProcessingInstruction = require_XMLProcessingInstruction(), XMLDeclaration = require_XMLDeclaration(), XMLDocType = require_XMLDocType(), XMLDTDAttList = require_XMLDTDAttList(), XMLDTDEntity = require_XMLDTDEntity(), XMLDTDElement = require_XMLDTDElement(), XMLDTDNotation = require_XMLDTDNotation(), XMLAttribute = require_XMLAttribute(), XMLStringifier = require_XMLStringifier(), XMLStringWriter = require_XMLStringWriter(), WriterState = require_WriterState(), module2.exports = XMLDocumentCB = function() {
      function XMLDocumentCB2(options, onData, onEnd) {
        var writerOptions;
        this.name = "?xml", this.type = NodeType.Document, options || (options = {}), writerOptions = {}, options.writer ? isPlainObject(options.writer) && (writerOptions = options.writer, options.writer = new XMLStringWriter()) : options.writer = new XMLStringWriter(), this.options = options, this.writer = options.writer, this.writerOptions = this.writer.filterOptions(writerOptions), this.stringify = new XMLStringifier(options), this.onDataCallback = onData || function() {
        }, this.onEndCallback = onEnd || function() {
        }, this.currentNode = null, this.currentLevel = -1, this.openTags = {}, this.documentStarted = !1, this.documentCompleted = !1, this.root = null;
      }
      return __name(XMLDocumentCB2, "XMLDocumentCB"), XMLDocumentCB2.prototype.createChildNode = function(node) {
        var att, attName, attributes, child, i, len, ref1, ref2;
        switch (node.type) {
          case NodeType.CData:
            this.cdata(node.value);
            break;
          case NodeType.Comment:
            this.comment(node.value);
            break;
          case NodeType.Element:
            attributes = {}, ref1 = node.attribs;
            for (attName in ref1)
              !hasProp.call(ref1, attName) || (att = ref1[attName], attributes[attName] = att.value);
            this.node(node.name, attributes);
            break;
          case NodeType.Dummy:
            this.dummy();
            break;
          case NodeType.Raw:
            this.raw(node.value);
            break;
          case NodeType.Text:
            this.text(node.value);
            break;
          case NodeType.ProcessingInstruction:
            this.instruction(node.target, node.value);
            break;
          default:
            throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
        }
        for (ref2 = node.children, i = 0, len = ref2.length; i < len; i++)
          child = ref2[i], this.createChildNode(child), child.type === NodeType.Element && this.up();
        return this;
      }, XMLDocumentCB2.prototype.dummy = function() {
        return this;
      }, XMLDocumentCB2.prototype.node = function(name, attributes, text) {
        var ref1;
        if (name == null)
          throw new Error("Missing node name.");
        if (this.root && this.currentLevel === -1)
          throw new Error("Document can only have one root node. " + this.debugInfo(name));
        return this.openCurrent(), name = getValue(name), attributes == null && (attributes = {}), attributes = getValue(attributes), isObject(attributes) || (ref1 = [attributes, text], text = ref1[0], attributes = ref1[1]), this.currentNode = new XMLElement(this, name, attributes), this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, text != null && this.text(text), this;
      }, XMLDocumentCB2.prototype.element = function(name, attributes, text) {
        var child, i, len, oldValidationFlag, ref1, root;
        if (this.currentNode && this.currentNode.type === NodeType.DocType)
          this.dtdElement.apply(this, arguments);
        else if (Array.isArray(name) || isObject(name) || isFunction(name))
          for (oldValidationFlag = this.options.noValidation, this.options.noValidation = !0, root = new XMLDocument(this.options).element("TEMP_ROOT"), root.element(name), this.options.noValidation = oldValidationFlag, ref1 = root.children, i = 0, len = ref1.length; i < len; i++)
            child = ref1[i], this.createChildNode(child), child.type === NodeType.Element && this.up();
        else
          this.node(name, attributes, text);
        return this;
      }, XMLDocumentCB2.prototype.attribute = function(name, value) {
        var attName, attValue;
        if (!this.currentNode || this.currentNode.children)
          throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
        if (name != null && (name = getValue(name)), isObject(name))
          for (attName in name)
            !hasProp.call(name, attName) || (attValue = name[attName], this.attribute(attName, attValue));
        else
          isFunction(value) && (value = value.apply()), this.options.keepNullAttributes && value == null ? this.currentNode.attribs[name] = new XMLAttribute(this, name, "") : value != null && (this.currentNode.attribs[name] = new XMLAttribute(this, name, value));
        return this;
      }, XMLDocumentCB2.prototype.text = function(value) {
        var node;
        return this.openCurrent(), node = new XMLText(this, value), this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, XMLDocumentCB2.prototype.cdata = function(value) {
        var node;
        return this.openCurrent(), node = new XMLCData(this, value), this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, XMLDocumentCB2.prototype.comment = function(value) {
        var node;
        return this.openCurrent(), node = new XMLComment(this, value), this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, XMLDocumentCB2.prototype.raw = function(value) {
        var node;
        return this.openCurrent(), node = new XMLRaw(this, value), this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, XMLDocumentCB2.prototype.instruction = function(target, value) {
        var i, insTarget, insValue, len, node;
        if (this.openCurrent(), target != null && (target = getValue(target)), value != null && (value = getValue(value)), Array.isArray(target))
          for (i = 0, len = target.length; i < len; i++)
            insTarget = target[i], this.instruction(insTarget);
        else if (isObject(target))
          for (insTarget in target)
            !hasProp.call(target, insTarget) || (insValue = target[insTarget], this.instruction(insTarget, insValue));
        else
          isFunction(value) && (value = value.apply()), node = new XMLProcessingInstruction(this, target, value), this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      }, XMLDocumentCB2.prototype.declaration = function(version2, encoding, standalone) {
        var node;
        if (this.openCurrent(), this.documentStarted)
          throw new Error("declaration() must be the first node.");
        return node = new XMLDeclaration(this, version2, encoding, standalone), this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, XMLDocumentCB2.prototype.doctype = function(root, pubID, sysID) {
        if (this.openCurrent(), root == null)
          throw new Error("Missing root node name.");
        if (this.root)
          throw new Error("dtd() must come before the root node.");
        return this.currentNode = new XMLDocType(this, pubID, sysID), this.currentNode.rootNodeName = root, this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, this;
      }, XMLDocumentCB2.prototype.dtdElement = function(name, value) {
        var node;
        return this.openCurrent(), node = new XMLDTDElement(this, name, value), this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, XMLDocumentCB2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        var node;
        return this.openCurrent(), node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue), this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, XMLDocumentCB2.prototype.entity = function(name, value) {
        var node;
        return this.openCurrent(), node = new XMLDTDEntity(this, !1, name, value), this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, XMLDocumentCB2.prototype.pEntity = function(name, value) {
        var node;
        return this.openCurrent(), node = new XMLDTDEntity(this, !0, name, value), this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, XMLDocumentCB2.prototype.notation = function(name, value) {
        var node;
        return this.openCurrent(), node = new XMLDTDNotation(this, name, value), this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, XMLDocumentCB2.prototype.up = function() {
        if (this.currentLevel < 0)
          throw new Error("The document node has no parent.");
        return this.currentNode ? (this.currentNode.children ? this.closeNode(this.currentNode) : this.openNode(this.currentNode), this.currentNode = null) : this.closeNode(this.openTags[this.currentLevel]), delete this.openTags[this.currentLevel], this.currentLevel--, this;
      }, XMLDocumentCB2.prototype.end = function() {
        for (; this.currentLevel >= 0; )
          this.up();
        return this.onEnd();
      }, XMLDocumentCB2.prototype.openCurrent = function() {
        if (this.currentNode)
          return this.currentNode.children = !0, this.openNode(this.currentNode);
      }, XMLDocumentCB2.prototype.openNode = function(node) {
        var att, chunk, name, ref1;
        if (!node.isOpen) {
          if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element && (this.root = node), chunk = "", node.type === NodeType.Element) {
            this.writerOptions.state = WriterState.OpenTag, chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<" + node.name, ref1 = node.attribs;
            for (name in ref1)
              !hasProp.call(ref1, name) || (att = ref1[name], chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel));
            chunk += (node.children ? ">" : "/>") + this.writer.endline(node, this.writerOptions, this.currentLevel), this.writerOptions.state = WriterState.InsideTag;
          } else
            this.writerOptions.state = WriterState.OpenTag, chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + node.rootNodeName, node.pubID && node.sysID ? chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"' : node.sysID && (chunk += ' SYSTEM "' + node.sysID + '"'), node.children ? (chunk += " [", this.writerOptions.state = WriterState.InsideTag) : (this.writerOptions.state = WriterState.CloseTag, chunk += ">"), chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
          return this.onData(chunk, this.currentLevel), node.isOpen = !0;
        }
      }, XMLDocumentCB2.prototype.closeNode = function(node) {
        var chunk;
        if (!node.isClosed)
          return chunk = "", this.writerOptions.state = WriterState.CloseTag, node.type === NodeType.Element ? chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "</" + node.name + ">" + this.writer.endline(node, this.writerOptions, this.currentLevel) : chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(node, this.writerOptions, this.currentLevel), this.writerOptions.state = WriterState.None, this.onData(chunk, this.currentLevel), node.isClosed = !0;
      }, XMLDocumentCB2.prototype.onData = function(chunk, level) {
        return this.documentStarted = !0, this.onDataCallback(chunk, level + 1);
      }, XMLDocumentCB2.prototype.onEnd = function() {
        return this.documentCompleted = !0, this.onEndCallback();
      }, XMLDocumentCB2.prototype.debugInfo = function(name) {
        return name == null ? "" : "node: <" + name + ">";
      }, XMLDocumentCB2.prototype.ele = function() {
        return this.element.apply(this, arguments);
      }, XMLDocumentCB2.prototype.nod = function(name, attributes, text) {
        return this.node(name, attributes, text);
      }, XMLDocumentCB2.prototype.txt = function(value) {
        return this.text(value);
      }, XMLDocumentCB2.prototype.dat = function(value) {
        return this.cdata(value);
      }, XMLDocumentCB2.prototype.com = function(value) {
        return this.comment(value);
      }, XMLDocumentCB2.prototype.ins = function(target, value) {
        return this.instruction(target, value);
      }, XMLDocumentCB2.prototype.dec = function(version2, encoding, standalone) {
        return this.declaration(version2, encoding, standalone);
      }, XMLDocumentCB2.prototype.dtd = function(root, pubID, sysID) {
        return this.doctype(root, pubID, sysID);
      }, XMLDocumentCB2.prototype.e = function(name, attributes, text) {
        return this.element(name, attributes, text);
      }, XMLDocumentCB2.prototype.n = function(name, attributes, text) {
        return this.node(name, attributes, text);
      }, XMLDocumentCB2.prototype.t = function(value) {
        return this.text(value);
      }, XMLDocumentCB2.prototype.d = function(value) {
        return this.cdata(value);
      }, XMLDocumentCB2.prototype.c = function(value) {
        return this.comment(value);
      }, XMLDocumentCB2.prototype.r = function(value) {
        return this.raw(value);
      }, XMLDocumentCB2.prototype.i = function(target, value) {
        return this.instruction(target, value);
      }, XMLDocumentCB2.prototype.att = function() {
        return this.currentNode && this.currentNode.type === NodeType.DocType ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
      }, XMLDocumentCB2.prototype.a = function() {
        return this.currentNode && this.currentNode.type === NodeType.DocType ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
      }, XMLDocumentCB2.prototype.ent = function(name, value) {
        return this.entity(name, value);
      }, XMLDocumentCB2.prototype.pent = function(name, value) {
        return this.pEntity(name, value);
      }, XMLDocumentCB2.prototype.not = function(name, value) {
        return this.notation(name, value);
      }, XMLDocumentCB2;
    }();
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/XMLStreamWriter.js
var require_XMLStreamWriter = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, WriterState, XMLStreamWriter, XMLWriterBase, extend2 = /* @__PURE__ */ __name(function(child, parent) {
      for (var key in parent)
        hasProp.call(parent, key) && (child[key] = parent[key]);
      function ctor() {
        this.constructor = child;
      }
      return __name(ctor, "ctor"), ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, child;
    }, "extend"), hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType(), XMLWriterBase = require_XMLWriterBase(), WriterState = require_WriterState(), module2.exports = XMLStreamWriter = function(superClass) {
      extend2(XMLStreamWriter2, superClass);
      function XMLStreamWriter2(stream, options) {
        this.stream = stream, XMLStreamWriter2.__super__.constructor.call(this, options);
      }
      return __name(XMLStreamWriter2, "XMLStreamWriter"), XMLStreamWriter2.prototype.endline = function(node, options, level) {
        return node.isLastRootNode && options.state === WriterState.CloseTag ? "" : XMLStreamWriter2.__super__.endline.call(this, node, options, level);
      }, XMLStreamWriter2.prototype.document = function(doc, options) {
        var child, i, j, k, len, len1, ref, ref1, results;
        for (ref = doc.children, i = j = 0, len = ref.length; j < len; i = ++j)
          child = ref[i], child.isLastRootNode = i === doc.children.length - 1;
        for (options = this.filterOptions(options), ref1 = doc.children, results = [], k = 0, len1 = ref1.length; k < len1; k++)
          child = ref1[k], results.push(this.writeChildNode(child, options, 0));
        return results;
      }, XMLStreamWriter2.prototype.attribute = function(att, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.attribute.call(this, att, options, level));
      }, XMLStreamWriter2.prototype.cdata = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.cdata.call(this, node, options, level));
      }, XMLStreamWriter2.prototype.comment = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.comment.call(this, node, options, level));
      }, XMLStreamWriter2.prototype.declaration = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.declaration.call(this, node, options, level));
      }, XMLStreamWriter2.prototype.docType = function(node, options, level) {
        var child, j, len, ref;
        if (level || (level = 0), this.openNode(node, options, level), options.state = WriterState.OpenTag, this.stream.write(this.indent(node, options, level)), this.stream.write("<!DOCTYPE " + node.root().name), node.pubID && node.sysID ? this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"') : node.sysID && this.stream.write(' SYSTEM "' + node.sysID + '"'), node.children.length > 0) {
          for (this.stream.write(" ["), this.stream.write(this.endline(node, options, level)), options.state = WriterState.InsideTag, ref = node.children, j = 0, len = ref.length; j < len; j++)
            child = ref[j], this.writeChildNode(child, options, level + 1);
          options.state = WriterState.CloseTag, this.stream.write("]");
        }
        return options.state = WriterState.CloseTag, this.stream.write(options.spaceBeforeSlash + ">"), this.stream.write(this.endline(node, options, level)), options.state = WriterState.None, this.closeNode(node, options, level);
      }, XMLStreamWriter2.prototype.element = function(node, options, level) {
        var att, child, childNodeCount, firstChildNode, j, len, name, prettySuppressed, ref, ref1;
        level || (level = 0), this.openNode(node, options, level), options.state = WriterState.OpenTag, this.stream.write(this.indent(node, options, level) + "<" + node.name), ref = node.attribs;
        for (name in ref)
          !hasProp.call(ref, name) || (att = ref[name], this.attribute(att, options, level));
        if (childNodeCount = node.children.length, firstChildNode = childNodeCount === 0 ? null : node.children[0], childNodeCount === 0 || node.children.every(function(e) {
          return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
        }))
          options.allowEmpty ? (this.stream.write(">"), options.state = WriterState.CloseTag, this.stream.write("</" + node.name + ">")) : (options.state = WriterState.CloseTag, this.stream.write(options.spaceBeforeSlash + "/>"));
        else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null)
          this.stream.write(">"), options.state = WriterState.InsideTag, options.suppressPrettyCount++, prettySuppressed = !0, this.writeChildNode(firstChildNode, options, level + 1), options.suppressPrettyCount--, prettySuppressed = !1, options.state = WriterState.CloseTag, this.stream.write("</" + node.name + ">");
        else {
          for (this.stream.write(">" + this.endline(node, options, level)), options.state = WriterState.InsideTag, ref1 = node.children, j = 0, len = ref1.length; j < len; j++)
            child = ref1[j], this.writeChildNode(child, options, level + 1);
          options.state = WriterState.CloseTag, this.stream.write(this.indent(node, options, level) + "</" + node.name + ">");
        }
        return this.stream.write(this.endline(node, options, level)), options.state = WriterState.None, this.closeNode(node, options, level);
      }, XMLStreamWriter2.prototype.processingInstruction = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.processingInstruction.call(this, node, options, level));
      }, XMLStreamWriter2.prototype.raw = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.raw.call(this, node, options, level));
      }, XMLStreamWriter2.prototype.text = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.text.call(this, node, options, level));
      }, XMLStreamWriter2.prototype.dtdAttList = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.dtdAttList.call(this, node, options, level));
      }, XMLStreamWriter2.prototype.dtdElement = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.dtdElement.call(this, node, options, level));
      }, XMLStreamWriter2.prototype.dtdEntity = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.dtdEntity.call(this, node, options, level));
      }, XMLStreamWriter2.prototype.dtdNotation = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.dtdNotation.call(this, node, options, level));
      }, XMLStreamWriter2;
    }(XMLWriterBase);
  }).call(exports2);
});

// ../node_modules/xmlbuilder/lib/index.js
var require_lib = __commonJS((exports2, module2) => {
  (function() {
    var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;
    ref = require_Utility(), assign = ref.assign, isFunction = ref.isFunction, XMLDOMImplementation = require_XMLDOMImplementation(), XMLDocument = require_XMLDocument(), XMLDocumentCB = require_XMLDocumentCB(), XMLStringWriter = require_XMLStringWriter(), XMLStreamWriter = require_XMLStreamWriter(), NodeType = require_NodeType(), WriterState = require_WriterState(), module2.exports.create = function(name, xmldec, doctype, options) {
      var doc, root;
      if (name == null)
        throw new Error("Root element needs a name.");
      return options = assign({}, xmldec, doctype, options), doc = new XMLDocument(options), root = doc.element(name), options.headless || (doc.declaration(options), (options.pubID != null || options.sysID != null) && doc.dtd(options)), root;
    }, module2.exports.begin = function(options, onData, onEnd) {
      var ref1;
      return isFunction(options) && (ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1], options = {}), onData ? new XMLDocumentCB(options, onData, onEnd) : new XMLDocument(options);
    }, module2.exports.stringWriter = function(options) {
      return new XMLStringWriter(options);
    }, module2.exports.streamWriter = function(stream, options) {
      return new XMLStreamWriter(stream, options);
    }, module2.exports.implementation = new XMLDOMImplementation(), module2.exports.nodeType = NodeType, module2.exports.writerState = WriterState;
  }).call(exports2);
});

// ../node_modules/xml2js/lib/builder.js
var require_builder = __commonJS((exports2) => {
  (function() {
    "use strict";
    var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
    builder = require_lib(), defaults = require_defaults().defaults, requiresCDATA = /* @__PURE__ */ __name(function(entry) {
      return typeof entry == "string" && (entry.indexOf("&") >= 0 || entry.indexOf(">") >= 0 || entry.indexOf("<") >= 0);
    }, "requiresCDATA"), wrapCDATA = /* @__PURE__ */ __name(function(entry) {
      return "<![CDATA[" + escapeCDATA(entry) + "]]>";
    }, "wrapCDATA"), escapeCDATA = /* @__PURE__ */ __name(function(entry) {
      return entry.replace("]]>", "]]]]><![CDATA[>");
    }, "escapeCDATA"), exports2.Builder = function() {
      function Builder2(opts) {
        var key, ref, value;
        this.options = {}, ref = defaults["0.2"];
        for (key in ref)
          !hasProp.call(ref, key) || (value = ref[key], this.options[key] = value);
        for (key in opts)
          !hasProp.call(opts, key) || (value = opts[key], this.options[key] = value);
      }
      return __name(Builder2, "Builder"), Builder2.prototype.buildObject = function(rootObj) {
        var attrkey, charkey, render, rootElement, rootName;
        return attrkey = this.options.attrkey, charkey = this.options.charkey, Object.keys(rootObj).length === 1 && this.options.rootName === defaults["0.2"].rootName ? (rootName = Object.keys(rootObj)[0], rootObj = rootObj[rootName]) : rootName = this.options.rootName, render = function(_this) {
          return function(element, obj) {
            var attr, child, entry, index, key, value;
            if (typeof obj != "object")
              _this.options.cdata && requiresCDATA(obj) ? element.raw(wrapCDATA(obj)) : element.txt(obj);
            else if (Array.isArray(obj)) {
              for (index in obj)
                if (!!hasProp.call(obj, index)) {
                  child = obj[index];
                  for (key in child)
                    entry = child[key], element = render(element.ele(key), entry).up();
                }
            } else
              for (key in obj)
                if (!!hasProp.call(obj, key))
                  if (child = obj[key], key === attrkey) {
                    if (typeof child == "object")
                      for (attr in child)
                        value = child[attr], element = element.att(attr, value);
                  } else if (key === charkey)
                    _this.options.cdata && requiresCDATA(child) ? element = element.raw(wrapCDATA(child)) : element = element.txt(child);
                  else if (Array.isArray(child))
                    for (index in child)
                      !hasProp.call(child, index) || (entry = child[index], typeof entry == "string" ? _this.options.cdata && requiresCDATA(entry) ? element = element.ele(key).raw(wrapCDATA(entry)).up() : element = element.ele(key, entry).up() : element = render(element.ele(key), entry).up());
                  else
                    typeof child == "object" ? element = render(element.ele(key), child).up() : typeof child == "string" && _this.options.cdata && requiresCDATA(child) ? element = element.ele(key).raw(wrapCDATA(child)).up() : (child == null && (child = ""), element = element.ele(key, child.toString()).up());
            return element;
          };
        }(this), rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
          headless: this.options.headless,
          allowSurrogateChars: this.options.allowSurrogateChars
        }), render(rootElement, rootObj).end(this.options.renderOpts);
      }, Builder2;
    }();
  }).call(exports2);
});

// ../node_modules/sax/lib/sax.js
var require_sax = __commonJS((exports2) => {
  (function(sax) {
    sax.parser = function(strict, opt) {
      return new SAXParser(strict, opt);
    }, sax.SAXParser = SAXParser, sax.SAXStream = SAXStream, sax.createStream = createStream, sax.MAX_BUFFER_LENGTH = 64 * 1024;
    var buffers = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script"
    ];
    sax.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace"
    ];
    function SAXParser(strict, opt) {
      if (!(this instanceof SAXParser))
        return new SAXParser(strict, opt);
      var parser = this;
      clearBuffers(parser), parser.q = parser.c = "", parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH, parser.opt = opt || {}, parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags, parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase", parser.tags = [], parser.closed = parser.closedRoot = parser.sawRoot = !1, parser.tag = parser.error = null, parser.strict = !!strict, parser.noscript = !!(strict || parser.opt.noscript), parser.state = S.BEGIN, parser.strictEntities = parser.opt.strictEntities, parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES), parser.attribList = [], parser.opt.xmlns && (parser.ns = Object.create(rootNS)), parser.trackPosition = parser.opt.position !== !1, parser.trackPosition && (parser.position = parser.line = parser.column = 0), emit(parser, "onready");
    }
    __name(SAXParser, "SAXParser"), Object.create || (Object.create = function(o) {
      function F() {
      }
      __name(F, "F"), F.prototype = o;
      var newf = new F();
      return newf;
    }), Object.keys || (Object.keys = function(o) {
      var a = [];
      for (var i in o)
        o.hasOwnProperty(i) && a.push(i);
      return a;
    });
    function checkBufferLength(parser) {
      for (var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10), maxActual = 0, i = 0, l = buffers.length; i < l; i++) {
        var len = parser[buffers[i]].length;
        if (len > maxAllowed)
          switch (buffers[i]) {
            case "textNode":
              closeText(parser);
              break;
            case "cdata":
              emitNode(parser, "oncdata", parser.cdata), parser.cdata = "";
              break;
            case "script":
              emitNode(parser, "onscript", parser.script), parser.script = "";
              break;
            default:
              error(parser, "Max buffer length exceeded: " + buffers[i]);
          }
        maxActual = Math.max(maxActual, len);
      }
      var m = sax.MAX_BUFFER_LENGTH - maxActual;
      parser.bufferCheckPosition = m + parser.position;
    }
    __name(checkBufferLength, "checkBufferLength");
    function clearBuffers(parser) {
      for (var i = 0, l = buffers.length; i < l; i++)
        parser[buffers[i]] = "";
    }
    __name(clearBuffers, "clearBuffers");
    function flushBuffers(parser) {
      closeText(parser), parser.cdata !== "" && (emitNode(parser, "oncdata", parser.cdata), parser.cdata = ""), parser.script !== "" && (emitNode(parser, "onscript", parser.script), parser.script = "");
    }
    __name(flushBuffers, "flushBuffers"), SAXParser.prototype = {
      end: function() {
        end(this);
      },
      write,
      resume: function() {
        return this.error = null, this;
      },
      close: function() {
        return this.write(null);
      },
      flush: function() {
        flushBuffers(this);
      }
    };
    var Stream2;
    try {
      Stream2 = require("stream").Stream;
    } catch (ex) {
      Stream2 = /* @__PURE__ */ __name(function() {
      }, "Stream");
    }
    var streamWraps = sax.EVENTS.filter(function(ev) {
      return ev !== "error" && ev !== "end";
    });
    function createStream(strict, opt) {
      return new SAXStream(strict, opt);
    }
    __name(createStream, "createStream");
    function SAXStream(strict, opt) {
      if (!(this instanceof SAXStream))
        return new SAXStream(strict, opt);
      Stream2.apply(this), this._parser = new SAXParser(strict, opt), this.writable = !0, this.readable = !0;
      var me = this;
      this._parser.onend = function() {
        me.emit("end");
      }, this._parser.onerror = function(er) {
        me.emit("error", er), me._parser.error = null;
      }, this._decoder = null, streamWraps.forEach(function(ev) {
        Object.defineProperty(me, "on" + ev, {
          get: function() {
            return me._parser["on" + ev];
          },
          set: function(h) {
            if (!h)
              return me.removeAllListeners(ev), me._parser["on" + ev] = h, h;
            me.on(ev, h);
          },
          enumerable: !0,
          configurable: !1
        });
      });
    }
    __name(SAXStream, "SAXStream"), SAXStream.prototype = Object.create(Stream2.prototype, {
      constructor: {
        value: SAXStream
      }
    }), SAXStream.prototype.write = function(data) {
      if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(data)) {
        if (!this._decoder) {
          var SD = require("string_decoder").StringDecoder;
          this._decoder = new SD("utf8");
        }
        data = this._decoder.write(data);
      }
      return this._parser.write(data.toString()), this.emit("data", data), !0;
    }, SAXStream.prototype.end = function(chunk) {
      return chunk && chunk.length && this.write(chunk), this._parser.end(), !0;
    }, SAXStream.prototype.on = function(ev, handler) {
      var me = this;
      return !me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1 && (me._parser["on" + ev] = function() {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
        args.splice(0, 0, ev), me.emit.apply(me, args);
      }), Stream2.prototype.on.call(me, ev, handler);
    };
    var CDATA = "[CDATA[", DOCTYPE = "DOCTYPE", XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace", XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/", rootNS = {xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE}, nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace(c) {
      return c === " " || c === `
` || c === "\r" || c === "	";
    }
    __name(isWhitespace, "isWhitespace");
    function isQuote(c) {
      return c === '"' || c === "'";
    }
    __name(isQuote, "isQuote");
    function isAttribEnd(c) {
      return c === ">" || isWhitespace(c);
    }
    __name(isAttribEnd, "isAttribEnd");
    function isMatch(regex, c) {
      return regex.test(c);
    }
    __name(isMatch, "isMatch");
    function notMatch(regex, c) {
      return !isMatch(regex, c);
    }
    __name(notMatch, "notMatch");
    var S = 0;
    sax.STATE = {
      BEGIN: S++,
      BEGIN_WHITESPACE: S++,
      TEXT: S++,
      TEXT_ENTITY: S++,
      OPEN_WAKA: S++,
      SGML_DECL: S++,
      SGML_DECL_QUOTED: S++,
      DOCTYPE: S++,
      DOCTYPE_QUOTED: S++,
      DOCTYPE_DTD: S++,
      DOCTYPE_DTD_QUOTED: S++,
      COMMENT_STARTING: S++,
      COMMENT: S++,
      COMMENT_ENDING: S++,
      COMMENT_ENDED: S++,
      CDATA: S++,
      CDATA_ENDING: S++,
      CDATA_ENDING_2: S++,
      PROC_INST: S++,
      PROC_INST_BODY: S++,
      PROC_INST_ENDING: S++,
      OPEN_TAG: S++,
      OPEN_TAG_SLASH: S++,
      ATTRIB: S++,
      ATTRIB_NAME: S++,
      ATTRIB_NAME_SAW_WHITE: S++,
      ATTRIB_VALUE: S++,
      ATTRIB_VALUE_QUOTED: S++,
      ATTRIB_VALUE_CLOSED: S++,
      ATTRIB_VALUE_UNQUOTED: S++,
      ATTRIB_VALUE_ENTITY_Q: S++,
      ATTRIB_VALUE_ENTITY_U: S++,
      CLOSE_TAG: S++,
      CLOSE_TAG_SAW_WHITE: S++,
      SCRIPT: S++,
      SCRIPT_ENDING: S++
    }, sax.XML_ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'"
    }, sax.ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'",
      AElig: 198,
      Aacute: 193,
      Acirc: 194,
      Agrave: 192,
      Aring: 197,
      Atilde: 195,
      Auml: 196,
      Ccedil: 199,
      ETH: 208,
      Eacute: 201,
      Ecirc: 202,
      Egrave: 200,
      Euml: 203,
      Iacute: 205,
      Icirc: 206,
      Igrave: 204,
      Iuml: 207,
      Ntilde: 209,
      Oacute: 211,
      Ocirc: 212,
      Ograve: 210,
      Oslash: 216,
      Otilde: 213,
      Ouml: 214,
      THORN: 222,
      Uacute: 218,
      Ucirc: 219,
      Ugrave: 217,
      Uuml: 220,
      Yacute: 221,
      aacute: 225,
      acirc: 226,
      aelig: 230,
      agrave: 224,
      aring: 229,
      atilde: 227,
      auml: 228,
      ccedil: 231,
      eacute: 233,
      ecirc: 234,
      egrave: 232,
      eth: 240,
      euml: 235,
      iacute: 237,
      icirc: 238,
      igrave: 236,
      iuml: 239,
      ntilde: 241,
      oacute: 243,
      ocirc: 244,
      ograve: 242,
      oslash: 248,
      otilde: 245,
      ouml: 246,
      szlig: 223,
      thorn: 254,
      uacute: 250,
      ucirc: 251,
      ugrave: 249,
      uuml: 252,
      yacute: 253,
      yuml: 255,
      copy: 169,
      reg: 174,
      nbsp: 160,
      iexcl: 161,
      cent: 162,
      pound: 163,
      curren: 164,
      yen: 165,
      brvbar: 166,
      sect: 167,
      uml: 168,
      ordf: 170,
      laquo: 171,
      not: 172,
      shy: 173,
      macr: 175,
      deg: 176,
      plusmn: 177,
      sup1: 185,
      sup2: 178,
      sup3: 179,
      acute: 180,
      micro: 181,
      para: 182,
      middot: 183,
      cedil: 184,
      ordm: 186,
      raquo: 187,
      frac14: 188,
      frac12: 189,
      frac34: 190,
      iquest: 191,
      times: 215,
      divide: 247,
      OElig: 338,
      oelig: 339,
      Scaron: 352,
      scaron: 353,
      Yuml: 376,
      fnof: 402,
      circ: 710,
      tilde: 732,
      Alpha: 913,
      Beta: 914,
      Gamma: 915,
      Delta: 916,
      Epsilon: 917,
      Zeta: 918,
      Eta: 919,
      Theta: 920,
      Iota: 921,
      Kappa: 922,
      Lambda: 923,
      Mu: 924,
      Nu: 925,
      Xi: 926,
      Omicron: 927,
      Pi: 928,
      Rho: 929,
      Sigma: 931,
      Tau: 932,
      Upsilon: 933,
      Phi: 934,
      Chi: 935,
      Psi: 936,
      Omega: 937,
      alpha: 945,
      beta: 946,
      gamma: 947,
      delta: 948,
      epsilon: 949,
      zeta: 950,
      eta: 951,
      theta: 952,
      iota: 953,
      kappa: 954,
      lambda: 955,
      mu: 956,
      nu: 957,
      xi: 958,
      omicron: 959,
      pi: 960,
      rho: 961,
      sigmaf: 962,
      sigma: 963,
      tau: 964,
      upsilon: 965,
      phi: 966,
      chi: 967,
      psi: 968,
      omega: 969,
      thetasym: 977,
      upsih: 978,
      piv: 982,
      ensp: 8194,
      emsp: 8195,
      thinsp: 8201,
      zwnj: 8204,
      zwj: 8205,
      lrm: 8206,
      rlm: 8207,
      ndash: 8211,
      mdash: 8212,
      lsquo: 8216,
      rsquo: 8217,
      sbquo: 8218,
      ldquo: 8220,
      rdquo: 8221,
      bdquo: 8222,
      dagger: 8224,
      Dagger: 8225,
      bull: 8226,
      hellip: 8230,
      permil: 8240,
      prime: 8242,
      Prime: 8243,
      lsaquo: 8249,
      rsaquo: 8250,
      oline: 8254,
      frasl: 8260,
      euro: 8364,
      image: 8465,
      weierp: 8472,
      real: 8476,
      trade: 8482,
      alefsym: 8501,
      larr: 8592,
      uarr: 8593,
      rarr: 8594,
      darr: 8595,
      harr: 8596,
      crarr: 8629,
      lArr: 8656,
      uArr: 8657,
      rArr: 8658,
      dArr: 8659,
      hArr: 8660,
      forall: 8704,
      part: 8706,
      exist: 8707,
      empty: 8709,
      nabla: 8711,
      isin: 8712,
      notin: 8713,
      ni: 8715,
      prod: 8719,
      sum: 8721,
      minus: 8722,
      lowast: 8727,
      radic: 8730,
      prop: 8733,
      infin: 8734,
      ang: 8736,
      and: 8743,
      or: 8744,
      cap: 8745,
      cup: 8746,
      int: 8747,
      there4: 8756,
      sim: 8764,
      cong: 8773,
      asymp: 8776,
      ne: 8800,
      equiv: 8801,
      le: 8804,
      ge: 8805,
      sub: 8834,
      sup: 8835,
      nsub: 8836,
      sube: 8838,
      supe: 8839,
      oplus: 8853,
      otimes: 8855,
      perp: 8869,
      sdot: 8901,
      lceil: 8968,
      rceil: 8969,
      lfloor: 8970,
      rfloor: 8971,
      lang: 9001,
      rang: 9002,
      loz: 9674,
      spades: 9824,
      clubs: 9827,
      hearts: 9829,
      diams: 9830
    }, Object.keys(sax.ENTITIES).forEach(function(key) {
      var e = sax.ENTITIES[key], s2 = typeof e == "number" ? String.fromCharCode(e) : e;
      sax.ENTITIES[key] = s2;
    });
    for (var s in sax.STATE)
      sax.STATE[sax.STATE[s]] = s;
    S = sax.STATE;
    function emit(parser, event, data) {
      parser[event] && parser[event](data);
    }
    __name(emit, "emit");
    function emitNode(parser, nodeType, data) {
      parser.textNode && closeText(parser), emit(parser, nodeType, data);
    }
    __name(emitNode, "emitNode");
    function closeText(parser) {
      parser.textNode = textopts(parser.opt, parser.textNode), parser.textNode && emit(parser, "ontext", parser.textNode), parser.textNode = "";
    }
    __name(closeText, "closeText");
    function textopts(opt, text) {
      return opt.trim && (text = text.trim()), opt.normalize && (text = text.replace(/\s+/g, " ")), text;
    }
    __name(textopts, "textopts");
    function error(parser, er) {
      return closeText(parser), parser.trackPosition && (er += `
Line: ` + parser.line + `
Column: ` + parser.column + `
Char: ` + parser.c), er = new Error(er), parser.error = er, emit(parser, "onerror", er), parser;
    }
    __name(error, "error");
    function end(parser) {
      return parser.sawRoot && !parser.closedRoot && strictFail(parser, "Unclosed root tag"), parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT && error(parser, "Unexpected end"), closeText(parser), parser.c = "", parser.closed = !0, emit(parser, "onend"), SAXParser.call(parser, parser.strict, parser.opt), parser;
    }
    __name(end, "end");
    function strictFail(parser, message) {
      if (typeof parser != "object" || !(parser instanceof SAXParser))
        throw new Error("bad call to strictFail");
      parser.strict && error(parser, message);
    }
    __name(strictFail, "strictFail");
    function newTag(parser) {
      parser.strict || (parser.tagName = parser.tagName[parser.looseCase]());
      var parent = parser.tags[parser.tags.length - 1] || parser, tag = parser.tag = {name: parser.tagName, attributes: {}};
      parser.opt.xmlns && (tag.ns = parent.ns), parser.attribList.length = 0, emitNode(parser, "onopentagstart", tag);
    }
    __name(newTag, "newTag");
    function qname(name, attribute) {
      var i = name.indexOf(":"), qualName = i < 0 ? ["", name] : name.split(":"), prefix2 = qualName[0], local = qualName[1];
      return attribute && name === "xmlns" && (prefix2 = "xmlns", local = ""), {prefix: prefix2, local};
    }
    __name(qname, "qname");
    function attrib(parser) {
      if (parser.strict || (parser.attribName = parser.attribName[parser.looseCase]()), parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
        parser.attribName = parser.attribValue = "";
        return;
      }
      if (parser.opt.xmlns) {
        var qn = qname(parser.attribName, !0), prefix2 = qn.prefix, local = qn.local;
        if (prefix2 === "xmlns")
          if (local === "xml" && parser.attribValue !== XML_NAMESPACE)
            strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + `
Actual: ` + parser.attribValue);
          else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE)
            strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + `
Actual: ` + parser.attribValue);
          else {
            var tag = parser.tag, parent = parser.tags[parser.tags.length - 1] || parser;
            tag.ns === parent.ns && (tag.ns = Object.create(parent.ns)), tag.ns[local] = parser.attribValue;
          }
        parser.attribList.push([parser.attribName, parser.attribValue]);
      } else
        parser.tag.attributes[parser.attribName] = parser.attribValue, emitNode(parser, "onattribute", {
          name: parser.attribName,
          value: parser.attribValue
        });
      parser.attribName = parser.attribValue = "";
    }
    __name(attrib, "attrib");
    function openTag(parser, selfClosing) {
      if (parser.opt.xmlns) {
        var tag = parser.tag, qn = qname(parser.tagName);
        tag.prefix = qn.prefix, tag.local = qn.local, tag.uri = tag.ns[qn.prefix] || "", tag.prefix && !tag.uri && (strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName)), tag.uri = qn.prefix);
        var parent = parser.tags[parser.tags.length - 1] || parser;
        tag.ns && parent.ns !== tag.ns && Object.keys(tag.ns).forEach(function(p) {
          emitNode(parser, "onopennamespace", {
            prefix: p,
            uri: tag.ns[p]
          });
        });
        for (var i = 0, l = parser.attribList.length; i < l; i++) {
          var nv = parser.attribList[i], name = nv[0], value = nv[1], qualName = qname(name, !0), prefix2 = qualName.prefix, local = qualName.local, uri = prefix2 === "" ? "" : tag.ns[prefix2] || "", a = {
            name,
            value,
            prefix: prefix2,
            local,
            uri
          };
          prefix2 && prefix2 !== "xmlns" && !uri && (strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix2)), a.uri = prefix2), parser.tag.attributes[name] = a, emitNode(parser, "onattribute", a);
        }
        parser.attribList.length = 0;
      }
      parser.tag.isSelfClosing = !!selfClosing, parser.sawRoot = !0, parser.tags.push(parser.tag), emitNode(parser, "onopentag", parser.tag), selfClosing || (!parser.noscript && parser.tagName.toLowerCase() === "script" ? parser.state = S.SCRIPT : parser.state = S.TEXT, parser.tag = null, parser.tagName = ""), parser.attribName = parser.attribValue = "", parser.attribList.length = 0;
    }
    __name(openTag, "openTag");
    function closeTag(parser) {
      if (!parser.tagName) {
        strictFail(parser, "Weird empty close tag."), parser.textNode += "</>", parser.state = S.TEXT;
        return;
      }
      if (parser.script) {
        if (parser.tagName !== "script") {
          parser.script += "</" + parser.tagName + ">", parser.tagName = "", parser.state = S.SCRIPT;
          return;
        }
        emitNode(parser, "onscript", parser.script), parser.script = "";
      }
      var t = parser.tags.length, tagName = parser.tagName;
      parser.strict || (tagName = tagName[parser.looseCase]());
      for (var closeTo = tagName; t--; ) {
        var close = parser.tags[t];
        if (close.name !== closeTo)
          strictFail(parser, "Unexpected close tag");
        else
          break;
      }
      if (t < 0) {
        strictFail(parser, "Unmatched closing tag: " + parser.tagName), parser.textNode += "</" + parser.tagName + ">", parser.state = S.TEXT;
        return;
      }
      parser.tagName = tagName;
      for (var s2 = parser.tags.length; s2-- > t; ) {
        var tag = parser.tag = parser.tags.pop();
        parser.tagName = parser.tag.name, emitNode(parser, "onclosetag", parser.tagName);
        var x = {};
        for (var i in tag.ns)
          x[i] = tag.ns[i];
        var parent = parser.tags[parser.tags.length - 1] || parser;
        parser.opt.xmlns && tag.ns !== parent.ns && Object.keys(tag.ns).forEach(function(p) {
          var n = tag.ns[p];
          emitNode(parser, "onclosenamespace", {prefix: p, uri: n});
        });
      }
      t === 0 && (parser.closedRoot = !0), parser.tagName = parser.attribValue = parser.attribName = "", parser.attribList.length = 0, parser.state = S.TEXT;
    }
    __name(closeTag, "closeTag");
    function parseEntity(parser) {
      var entity = parser.entity, entityLC = entity.toLowerCase(), num, numStr = "";
      return parser.ENTITIES[entity] ? parser.ENTITIES[entity] : parser.ENTITIES[entityLC] ? parser.ENTITIES[entityLC] : (entity = entityLC, entity.charAt(0) === "#" && (entity.charAt(1) === "x" ? (entity = entity.slice(2), num = parseInt(entity, 16), numStr = num.toString(16)) : (entity = entity.slice(1), num = parseInt(entity, 10), numStr = num.toString(10))), entity = entity.replace(/^0+/, ""), isNaN(num) || numStr.toLowerCase() !== entity ? (strictFail(parser, "Invalid character entity"), "&" + parser.entity + ";") : String.fromCodePoint(num));
    }
    __name(parseEntity, "parseEntity");
    function beginWhiteSpace(parser, c) {
      c === "<" ? (parser.state = S.OPEN_WAKA, parser.startTagPosition = parser.position) : isWhitespace(c) || (strictFail(parser, "Non-whitespace before first tag."), parser.textNode = c, parser.state = S.TEXT);
    }
    __name(beginWhiteSpace, "beginWhiteSpace");
    function charAt(chunk, i) {
      var result = "";
      return i < chunk.length && (result = chunk.charAt(i)), result;
    }
    __name(charAt, "charAt");
    function write(chunk) {
      var parser = this;
      if (this.error)
        throw this.error;
      if (parser.closed)
        return error(parser, "Cannot write after close. Assign an onready handler.");
      if (chunk === null)
        return end(parser);
      typeof chunk == "object" && (chunk = chunk.toString());
      for (var i = 0, c = ""; c = charAt(chunk, i++), parser.c = c, !!c; )
        switch (parser.trackPosition && (parser.position++, c === `
` ? (parser.line++, parser.column = 0) : parser.column++), parser.state) {
          case S.BEGIN:
            if (parser.state = S.BEGIN_WHITESPACE, c === "\uFEFF")
              continue;
            beginWhiteSpace(parser, c);
            continue;
          case S.BEGIN_WHITESPACE:
            beginWhiteSpace(parser, c);
            continue;
          case S.TEXT:
            if (parser.sawRoot && !parser.closedRoot) {
              for (var starti = i - 1; c && c !== "<" && c !== "&"; )
                c = charAt(chunk, i++), c && parser.trackPosition && (parser.position++, c === `
` ? (parser.line++, parser.column = 0) : parser.column++);
              parser.textNode += chunk.substring(starti, i - 1);
            }
            c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict) ? (parser.state = S.OPEN_WAKA, parser.startTagPosition = parser.position) : (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot) && strictFail(parser, "Text data outside of root node."), c === "&" ? parser.state = S.TEXT_ENTITY : parser.textNode += c);
            continue;
          case S.SCRIPT:
            c === "<" ? parser.state = S.SCRIPT_ENDING : parser.script += c;
            continue;
          case S.SCRIPT_ENDING:
            c === "/" ? parser.state = S.CLOSE_TAG : (parser.script += "<" + c, parser.state = S.SCRIPT);
            continue;
          case S.OPEN_WAKA:
            if (c === "!")
              parser.state = S.SGML_DECL, parser.sgmlDecl = "";
            else if (!isWhitespace(c))
              if (isMatch(nameStart, c))
                parser.state = S.OPEN_TAG, parser.tagName = c;
              else if (c === "/")
                parser.state = S.CLOSE_TAG, parser.tagName = "";
              else if (c === "?")
                parser.state = S.PROC_INST, parser.procInstName = parser.procInstBody = "";
              else {
                if (strictFail(parser, "Unencoded <"), parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c, parser.state = S.TEXT;
              }
            continue;
          case S.SGML_DECL:
            (parser.sgmlDecl + c).toUpperCase() === CDATA ? (emitNode(parser, "onopencdata"), parser.state = S.CDATA, parser.sgmlDecl = "", parser.cdata = "") : parser.sgmlDecl + c === "--" ? (parser.state = S.COMMENT, parser.comment = "", parser.sgmlDecl = "") : (parser.sgmlDecl + c).toUpperCase() === DOCTYPE ? (parser.state = S.DOCTYPE, (parser.doctype || parser.sawRoot) && strictFail(parser, "Inappropriately located doctype declaration"), parser.doctype = "", parser.sgmlDecl = "") : c === ">" ? (emitNode(parser, "onsgmldeclaration", parser.sgmlDecl), parser.sgmlDecl = "", parser.state = S.TEXT) : (isQuote(c) && (parser.state = S.SGML_DECL_QUOTED), parser.sgmlDecl += c);
            continue;
          case S.SGML_DECL_QUOTED:
            c === parser.q && (parser.state = S.SGML_DECL, parser.q = ""), parser.sgmlDecl += c;
            continue;
          case S.DOCTYPE:
            c === ">" ? (parser.state = S.TEXT, emitNode(parser, "ondoctype", parser.doctype), parser.doctype = !0) : (parser.doctype += c, c === "[" ? parser.state = S.DOCTYPE_DTD : isQuote(c) && (parser.state = S.DOCTYPE_QUOTED, parser.q = c));
            continue;
          case S.DOCTYPE_QUOTED:
            parser.doctype += c, c === parser.q && (parser.q = "", parser.state = S.DOCTYPE);
            continue;
          case S.DOCTYPE_DTD:
            parser.doctype += c, c === "]" ? parser.state = S.DOCTYPE : isQuote(c) && (parser.state = S.DOCTYPE_DTD_QUOTED, parser.q = c);
            continue;
          case S.DOCTYPE_DTD_QUOTED:
            parser.doctype += c, c === parser.q && (parser.state = S.DOCTYPE_DTD, parser.q = "");
            continue;
          case S.COMMENT:
            c === "-" ? parser.state = S.COMMENT_ENDING : parser.comment += c;
            continue;
          case S.COMMENT_ENDING:
            c === "-" ? (parser.state = S.COMMENT_ENDED, parser.comment = textopts(parser.opt, parser.comment), parser.comment && emitNode(parser, "oncomment", parser.comment), parser.comment = "") : (parser.comment += "-" + c, parser.state = S.COMMENT);
            continue;
          case S.COMMENT_ENDED:
            c !== ">" ? (strictFail(parser, "Malformed comment"), parser.comment += "--" + c, parser.state = S.COMMENT) : parser.state = S.TEXT;
            continue;
          case S.CDATA:
            c === "]" ? parser.state = S.CDATA_ENDING : parser.cdata += c;
            continue;
          case S.CDATA_ENDING:
            c === "]" ? parser.state = S.CDATA_ENDING_2 : (parser.cdata += "]" + c, parser.state = S.CDATA);
            continue;
          case S.CDATA_ENDING_2:
            c === ">" ? (parser.cdata && emitNode(parser, "oncdata", parser.cdata), emitNode(parser, "onclosecdata"), parser.cdata = "", parser.state = S.TEXT) : c === "]" ? parser.cdata += "]" : (parser.cdata += "]]" + c, parser.state = S.CDATA);
            continue;
          case S.PROC_INST:
            c === "?" ? parser.state = S.PROC_INST_ENDING : isWhitespace(c) ? parser.state = S.PROC_INST_BODY : parser.procInstName += c;
            continue;
          case S.PROC_INST_BODY:
            if (!parser.procInstBody && isWhitespace(c))
              continue;
            c === "?" ? parser.state = S.PROC_INST_ENDING : parser.procInstBody += c;
            continue;
          case S.PROC_INST_ENDING:
            c === ">" ? (emitNode(parser, "onprocessinginstruction", {
              name: parser.procInstName,
              body: parser.procInstBody
            }), parser.procInstName = parser.procInstBody = "", parser.state = S.TEXT) : (parser.procInstBody += "?" + c, parser.state = S.PROC_INST_BODY);
            continue;
          case S.OPEN_TAG:
            isMatch(nameBody, c) ? parser.tagName += c : (newTag(parser), c === ">" ? openTag(parser) : c === "/" ? parser.state = S.OPEN_TAG_SLASH : (isWhitespace(c) || strictFail(parser, "Invalid character in tag name"), parser.state = S.ATTRIB));
            continue;
          case S.OPEN_TAG_SLASH:
            c === ">" ? (openTag(parser, !0), closeTag(parser)) : (strictFail(parser, "Forward-slash in opening tag not followed by >"), parser.state = S.ATTRIB);
            continue;
          case S.ATTRIB:
            if (isWhitespace(c))
              continue;
            c === ">" ? openTag(parser) : c === "/" ? parser.state = S.OPEN_TAG_SLASH : isMatch(nameStart, c) ? (parser.attribName = c, parser.attribValue = "", parser.state = S.ATTRIB_NAME) : strictFail(parser, "Invalid attribute name");
            continue;
          case S.ATTRIB_NAME:
            c === "=" ? parser.state = S.ATTRIB_VALUE : c === ">" ? (strictFail(parser, "Attribute without value"), parser.attribValue = parser.attribName, attrib(parser), openTag(parser)) : isWhitespace(c) ? parser.state = S.ATTRIB_NAME_SAW_WHITE : isMatch(nameBody, c) ? parser.attribName += c : strictFail(parser, "Invalid attribute name");
            continue;
          case S.ATTRIB_NAME_SAW_WHITE:
            if (c === "=")
              parser.state = S.ATTRIB_VALUE;
            else {
              if (isWhitespace(c))
                continue;
              strictFail(parser, "Attribute without value"), parser.tag.attributes[parser.attribName] = "", parser.attribValue = "", emitNode(parser, "onattribute", {
                name: parser.attribName,
                value: ""
              }), parser.attribName = "", c === ">" ? openTag(parser) : isMatch(nameStart, c) ? (parser.attribName = c, parser.state = S.ATTRIB_NAME) : (strictFail(parser, "Invalid attribute name"), parser.state = S.ATTRIB);
            }
            continue;
          case S.ATTRIB_VALUE:
            if (isWhitespace(c))
              continue;
            isQuote(c) ? (parser.q = c, parser.state = S.ATTRIB_VALUE_QUOTED) : (strictFail(parser, "Unquoted attribute value"), parser.state = S.ATTRIB_VALUE_UNQUOTED, parser.attribValue = c);
            continue;
          case S.ATTRIB_VALUE_QUOTED:
            if (c !== parser.q) {
              c === "&" ? parser.state = S.ATTRIB_VALUE_ENTITY_Q : parser.attribValue += c;
              continue;
            }
            attrib(parser), parser.q = "", parser.state = S.ATTRIB_VALUE_CLOSED;
            continue;
          case S.ATTRIB_VALUE_CLOSED:
            isWhitespace(c) ? parser.state = S.ATTRIB : c === ">" ? openTag(parser) : c === "/" ? parser.state = S.OPEN_TAG_SLASH : isMatch(nameStart, c) ? (strictFail(parser, "No whitespace between attributes"), parser.attribName = c, parser.attribValue = "", parser.state = S.ATTRIB_NAME) : strictFail(parser, "Invalid attribute name");
            continue;
          case S.ATTRIB_VALUE_UNQUOTED:
            if (!isAttribEnd(c)) {
              c === "&" ? parser.state = S.ATTRIB_VALUE_ENTITY_U : parser.attribValue += c;
              continue;
            }
            attrib(parser), c === ">" ? openTag(parser) : parser.state = S.ATTRIB;
            continue;
          case S.CLOSE_TAG:
            if (parser.tagName)
              c === ">" ? closeTag(parser) : isMatch(nameBody, c) ? parser.tagName += c : parser.script ? (parser.script += "</" + parser.tagName, parser.tagName = "", parser.state = S.SCRIPT) : (isWhitespace(c) || strictFail(parser, "Invalid tagname in closing tag"), parser.state = S.CLOSE_TAG_SAW_WHITE);
            else {
              if (isWhitespace(c))
                continue;
              notMatch(nameStart, c) ? parser.script ? (parser.script += "</" + c, parser.state = S.SCRIPT) : strictFail(parser, "Invalid tagname in closing tag.") : parser.tagName = c;
            }
            continue;
          case S.CLOSE_TAG_SAW_WHITE:
            if (isWhitespace(c))
              continue;
            c === ">" ? closeTag(parser) : strictFail(parser, "Invalid characters in closing tag");
            continue;
          case S.TEXT_ENTITY:
          case S.ATTRIB_VALUE_ENTITY_Q:
          case S.ATTRIB_VALUE_ENTITY_U:
            var returnState, buffer;
            switch (parser.state) {
              case S.TEXT_ENTITY:
                returnState = S.TEXT, buffer = "textNode";
                break;
              case S.ATTRIB_VALUE_ENTITY_Q:
                returnState = S.ATTRIB_VALUE_QUOTED, buffer = "attribValue";
                break;
              case S.ATTRIB_VALUE_ENTITY_U:
                returnState = S.ATTRIB_VALUE_UNQUOTED, buffer = "attribValue";
                break;
            }
            c === ";" ? (parser[buffer] += parseEntity(parser), parser.entity = "", parser.state = returnState) : isMatch(parser.entity.length ? entityBody : entityStart, c) ? parser.entity += c : (strictFail(parser, "Invalid character in entity name"), parser[buffer] += "&" + parser.entity + c, parser.entity = "", parser.state = returnState);
            continue;
          default:
            throw new Error(parser, "Unknown state: " + parser.state);
        }
      return parser.position >= parser.bufferCheckPosition && checkBufferLength(parser), parser;
    }
    __name(write, "write");
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    String.fromCodePoint || function() {
      var stringFromCharCode = String.fromCharCode, floor = Math.floor, fromCodePoint = /* @__PURE__ */ __name(function() {
        var MAX_SIZE = 16384, codeUnits = [], highSurrogate, lowSurrogate, index = -1, length = arguments.length;
        if (!length)
          return "";
        for (var result = ""; ++index < length; ) {
          var codePoint = Number(arguments[index]);
          if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint)
            throw RangeError("Invalid code point: " + codePoint);
          codePoint <= 65535 ? codeUnits.push(codePoint) : (codePoint -= 65536, highSurrogate = (codePoint >> 10) + 55296, lowSurrogate = codePoint % 1024 + 56320, codeUnits.push(highSurrogate, lowSurrogate)), (index + 1 === length || codeUnits.length > MAX_SIZE) && (result += stringFromCharCode.apply(null, codeUnits), codeUnits.length = 0);
        }
        return result;
      }, "fromCodePoint");
      Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
        value: fromCodePoint,
        configurable: !0,
        writable: !0
      }) : String.fromCodePoint = fromCodePoint;
    }();
  })(typeof exports2 == "undefined" ? exports2.sax = {} : exports2);
});

// ../node_modules/xml2js/lib/bom.js
var require_bom = __commonJS((exports2) => {
  (function() {
    "use strict";
    exports2.stripBOM = function(str) {
      return str[0] === "\uFEFF" ? str.substring(1) : str;
    };
  }).call(exports2);
});

// ../node_modules/xml2js/lib/processors.js
var require_processors = __commonJS((exports2) => {
  (function() {
    "use strict";
    var prefixMatch;
    prefixMatch = new RegExp(/(?!xmlns)^.*:/), exports2.normalize = function(str) {
      return str.toLowerCase();
    }, exports2.firstCharLowerCase = function(str) {
      return str.charAt(0).toLowerCase() + str.slice(1);
    }, exports2.stripPrefix = function(str) {
      return str.replace(prefixMatch, "");
    }, exports2.parseNumbers = function(str) {
      return isNaN(str) || (str = str % 1 == 0 ? parseInt(str, 10) : parseFloat(str)), str;
    }, exports2.parseBooleans = function(str) {
      return /^(?:true|false)$/i.test(str) && (str = str.toLowerCase() === "true"), str;
    };
  }).call(exports2);
});

// ../node_modules/xml2js/lib/parser.js
var require_parser = __commonJS((exports2) => {
  (function() {
    "use strict";
    var bom, defaults, events, isEmpty, processItem, processors, sax, setImmediate2, bind = /* @__PURE__ */ __name(function(fn, me) {
      return function() {
        return fn.apply(me, arguments);
      };
    }, "bind"), extend2 = /* @__PURE__ */ __name(function(child, parent) {
      for (var key in parent)
        hasProp.call(parent, key) && (child[key] = parent[key]);
      function ctor() {
        this.constructor = child;
      }
      return __name(ctor, "ctor"), ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, child;
    }, "extend"), hasProp = {}.hasOwnProperty;
    sax = require_sax(), events = require("events"), bom = require_bom(), processors = require_processors(), setImmediate2 = require("timers").setImmediate, defaults = require_defaults().defaults, isEmpty = /* @__PURE__ */ __name(function(thing) {
      return typeof thing == "object" && thing != null && Object.keys(thing).length === 0;
    }, "isEmpty"), processItem = /* @__PURE__ */ __name(function(processors2, item, key) {
      var i, len, process2;
      for (i = 0, len = processors2.length; i < len; i++)
        process2 = processors2[i], item = process2(item, key);
      return item;
    }, "processItem"), exports2.Parser = function(superClass) {
      extend2(Parser2, superClass);
      function Parser2(opts) {
        this.parseStringPromise = bind(this.parseStringPromise, this), this.parseString = bind(this.parseString, this), this.reset = bind(this.reset, this), this.assignOrPush = bind(this.assignOrPush, this), this.processAsync = bind(this.processAsync, this);
        var key, ref, value;
        if (!(this instanceof exports2.Parser))
          return new exports2.Parser(opts);
        this.options = {}, ref = defaults["0.2"];
        for (key in ref)
          !hasProp.call(ref, key) || (value = ref[key], this.options[key] = value);
        for (key in opts)
          !hasProp.call(opts, key) || (value = opts[key], this.options[key] = value);
        this.options.xmlns && (this.options.xmlnskey = this.options.attrkey + "ns"), this.options.normalizeTags && (this.options.tagNameProcessors || (this.options.tagNameProcessors = []), this.options.tagNameProcessors.unshift(processors.normalize)), this.reset();
      }
      return __name(Parser2, "Parser"), Parser2.prototype.processAsync = function() {
        var chunk, err;
        try {
          return this.remaining.length <= this.options.chunkSize ? (chunk = this.remaining, this.remaining = "", this.saxParser = this.saxParser.write(chunk), this.saxParser.close()) : (chunk = this.remaining.substr(0, this.options.chunkSize), this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length), this.saxParser = this.saxParser.write(chunk), setImmediate2(this.processAsync));
        } catch (error1) {
          if (err = error1, !this.saxParser.errThrown)
            return this.saxParser.errThrown = !0, this.emit(err);
        }
      }, Parser2.prototype.assignOrPush = function(obj, key, newValue) {
        return key in obj ? (obj[key] instanceof Array || (obj[key] = [obj[key]]), obj[key].push(newValue)) : this.options.explicitArray ? obj[key] = [newValue] : obj[key] = newValue;
      }, Parser2.prototype.reset = function() {
        var attrkey, charkey, ontext, stack;
        return this.removeAllListeners(), this.saxParser = sax.parser(this.options.strict, {
          trim: !1,
          normalize: !1,
          xmlns: this.options.xmlns
        }), this.saxParser.errThrown = !1, this.saxParser.onerror = function(_this) {
          return function(error) {
            if (_this.saxParser.resume(), !_this.saxParser.errThrown)
              return _this.saxParser.errThrown = !0, _this.emit("error", error);
          };
        }(this), this.saxParser.onend = function(_this) {
          return function() {
            if (!_this.saxParser.ended)
              return _this.saxParser.ended = !0, _this.emit("end", _this.resultObject);
          };
        }(this), this.saxParser.ended = !1, this.EXPLICIT_CHARKEY = this.options.explicitCharkey, this.resultObject = null, stack = [], attrkey = this.options.attrkey, charkey = this.options.charkey, this.saxParser.onopentag = function(_this) {
          return function(node) {
            var key, newValue, obj, processedKey, ref;
            if (obj = {}, obj[charkey] = "", !_this.options.ignoreAttrs) {
              ref = node.attributes;
              for (key in ref)
                !hasProp.call(ref, key) || (!(attrkey in obj) && !_this.options.mergeAttrs && (obj[attrkey] = {}), newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key], processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key, _this.options.mergeAttrs ? _this.assignOrPush(obj, processedKey, newValue) : obj[attrkey][processedKey] = newValue);
            }
            return obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name, _this.options.xmlns && (obj[_this.options.xmlnskey] = {
              uri: node.uri,
              local: node.local
            }), stack.push(obj);
          };
        }(this), this.saxParser.onclosetag = function(_this) {
          return function() {
            var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
            if (obj = stack.pop(), nodeName = obj["#name"], (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) && delete obj["#name"], obj.cdata === !0 && (cdata = obj.cdata, delete obj.cdata), s = stack[stack.length - 1], obj[charkey].match(/^\s*$/) && !cdata ? (emptyStr = obj[charkey], delete obj[charkey]) : (_this.options.trim && (obj[charkey] = obj[charkey].trim()), _this.options.normalize && (obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim()), obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey], Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY && (obj = obj[charkey])), isEmpty(obj) && (obj = _this.options.emptyTag !== "" ? _this.options.emptyTag : emptyStr), _this.options.validator != null && (xpath = "/" + function() {
              var i, len, results;
              for (results = [], i = 0, len = stack.length; i < len; i++)
                node = stack[i], results.push(node["#name"]);
              return results;
            }().concat(nodeName).join("/"), function() {
              var err;
              try {
                return obj = _this.options.validator(xpath, s && s[nodeName], obj);
              } catch (error1) {
                return err = error1, _this.emit("error", err);
              }
            }()), _this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj == "object") {
              if (!_this.options.preserveChildrenOrder)
                node = {}, _this.options.attrkey in obj && (node[_this.options.attrkey] = obj[_this.options.attrkey], delete obj[_this.options.attrkey]), !_this.options.charsAsChildren && _this.options.charkey in obj && (node[_this.options.charkey] = obj[_this.options.charkey], delete obj[_this.options.charkey]), Object.getOwnPropertyNames(obj).length > 0 && (node[_this.options.childkey] = obj), obj = node;
              else if (s) {
                s[_this.options.childkey] = s[_this.options.childkey] || [], objClone = {};
                for (key in obj)
                  !hasProp.call(obj, key) || (objClone[key] = obj[key]);
                s[_this.options.childkey].push(objClone), delete obj["#name"], Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY && (obj = obj[charkey]);
              }
            }
            return stack.length > 0 ? _this.assignOrPush(s, nodeName, obj) : (_this.options.explicitRoot && (old = obj, obj = {}, obj[nodeName] = old), _this.resultObject = obj, _this.saxParser.ended = !0, _this.emit("end", _this.resultObject));
          };
        }(this), ontext = function(_this) {
          return function(text) {
            var charChild, s;
            if (s = stack[stack.length - 1], s)
              return s[charkey] += text, _this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, "").trim() !== "") && (s[_this.options.childkey] = s[_this.options.childkey] || [], charChild = {
                "#name": "__text__"
              }, charChild[charkey] = text, _this.options.normalize && (charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim()), s[_this.options.childkey].push(charChild)), s;
          };
        }(this), this.saxParser.ontext = ontext, this.saxParser.oncdata = function(_this) {
          return function(text) {
            var s;
            if (s = ontext(text), s)
              return s.cdata = !0;
          };
        }(this);
      }, Parser2.prototype.parseString = function(str, cb) {
        var err;
        cb != null && typeof cb == "function" && (this.on("end", function(result) {
          return this.reset(), cb(null, result);
        }), this.on("error", function(err2) {
          return this.reset(), cb(err2);
        }));
        try {
          return str = str.toString(), str.trim() === "" ? (this.emit("end", null), !0) : (str = bom.stripBOM(str), this.options.async ? (this.remaining = str, setImmediate2(this.processAsync), this.saxParser) : this.saxParser.write(str).close());
        } catch (error1) {
          if (err = error1, this.saxParser.errThrown || this.saxParser.ended) {
            if (this.saxParser.ended)
              throw err;
          } else
            return this.emit("error", err), this.saxParser.errThrown = !0;
        }
      }, Parser2.prototype.parseStringPromise = function(str) {
        return new Promise(function(_this) {
          return function(resolve, reject) {
            return _this.parseString(str, function(err, value) {
              return err ? reject(err) : resolve(value);
            });
          };
        }(this));
      }, Parser2;
    }(events), exports2.parseString = function(str, a, b) {
      var cb, options, parser;
      return b != null ? (typeof b == "function" && (cb = b), typeof a == "object" && (options = a)) : (typeof a == "function" && (cb = a), options = {}), parser = new exports2.Parser(options), parser.parseString(str, cb);
    }, exports2.parseStringPromise = function(str, a) {
      var options, parser;
      return typeof a == "object" && (options = a), parser = new exports2.Parser(options), parser.parseStringPromise(str);
    };
  }).call(exports2);
});

// ../node_modules/xml2js/lib/xml2js.js
var require_xml2js = __commonJS((exports2) => {
  (function() {
    "use strict";
    var builder, defaults, parser, processors, extend2 = /* @__PURE__ */ __name(function(child, parent) {
      for (var key in parent)
        hasProp.call(parent, key) && (child[key] = parent[key]);
      function ctor() {
        this.constructor = child;
      }
      return __name(ctor, "ctor"), ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, child;
    }, "extend"), hasProp = {}.hasOwnProperty;
    defaults = require_defaults(), builder = require_builder(), parser = require_parser(), processors = require_processors(), exports2.defaults = defaults.defaults, exports2.processors = processors, exports2.ValidationError = function(superClass) {
      extend2(ValidationError, superClass);
      function ValidationError(message) {
        this.message = message;
      }
      return __name(ValidationError, "ValidationError"), ValidationError;
    }(Error), exports2.Builder = builder.Builder, exports2.Parser = parser.Parser, exports2.parseString = parser.parseString, exports2.parseStringPromise = parser.parseStringPromise;
  }).call(exports2);
});

// ../node_modules/@opentelemetry/api/build/src/common/Logger.js
var require_Logger = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/api/build/src/common/Time.js
var require_Time = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/api/build/src/context/propagation/getter.js
var require_getter = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2.defaultGetter = void 0;
  function defaultGetter(carrier, key) {
    return carrier[key];
  }
  __name(defaultGetter, "defaultGetter");
  exports2.defaultGetter = defaultGetter;
});

// ../node_modules/@opentelemetry/api/build/src/context/propagation/HttpTextPropagator.js
var require_HttpTextPropagator = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/api/build/src/context/propagation/NoopHttpTextPropagator.js
var require_NoopHttpTextPropagator = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2.NOOP_HTTP_TEXT_PROPAGATOR = exports2.NoopHttpTextPropagator = void 0;
  var NoopHttpTextPropagator = function() {
    function NoopHttpTextPropagator2() {
    }
    return __name(NoopHttpTextPropagator2, "NoopHttpTextPropagator"), NoopHttpTextPropagator2.prototype.inject = function(context, carrier, setter) {
    }, NoopHttpTextPropagator2.prototype.extract = function(context, carrier, getter) {
      return context;
    }, NoopHttpTextPropagator2;
  }();
  exports2.NoopHttpTextPropagator = NoopHttpTextPropagator;
  exports2.NOOP_HTTP_TEXT_PROPAGATOR = new NoopHttpTextPropagator();
});

// ../node_modules/@opentelemetry/api/build/src/context/propagation/setter.js
var require_setter = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2.defaultSetter = void 0;
  function defaultSetter(carrier, key, value) {
    carrier[key] = value;
  }
  __name(defaultSetter, "defaultSetter");
  exports2.defaultSetter = defaultSetter;
});

// ../node_modules/@opentelemetry/api/build/src/correlation_context/CorrelationContext.js
var require_CorrelationContext = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/api/build/src/correlation_context/EntryValue.js
var require_EntryValue = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2.EntryTtl = void 0;
  var EntryTtl;
  (function(EntryTtl2) {
    EntryTtl2[EntryTtl2.NO_PROPAGATION = 0] = "NO_PROPAGATION", EntryTtl2[EntryTtl2.UNLIMITED_PROPAGATION = -1] = "UNLIMITED_PROPAGATION";
  })(EntryTtl = exports2.EntryTtl || (exports2.EntryTtl = {}));
});

// ../node_modules/@opentelemetry/api/build/src/metrics/BatchObserverResult.js
var require_BatchObserverResult = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/api/build/src/metrics/BoundInstrument.js
var require_BoundInstrument = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/api/build/src/metrics/Meter.js
var require_Meter = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/api/build/src/metrics/MeterProvider.js
var require_MeterProvider = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/api/build/src/metrics/Metric.js
var require_Metric = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2.ValueType = void 0;
  var ValueType;
  (function(ValueType2) {
    ValueType2[ValueType2.INT = 0] = "INT", ValueType2[ValueType2.DOUBLE = 1] = "DOUBLE";
  })(ValueType = exports2.ValueType || (exports2.ValueType = {}));
});

// ../node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js
var require_NoopMeter = __commonJS((exports2) => {
  "use strict";
  var __extends2 = exports2 && exports2.__extends || function() {
    var extendStatics2 = /* @__PURE__ */ __name(function(d, b) {
      return extendStatics2 = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          b2.hasOwnProperty(p) && (d2[p] = b2[p]);
      }, extendStatics2(d, b);
    }, "extendStatics");
    return function(d, b) {
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      __name(__, "__"), d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2.NOOP_BATCH_OBSERVER_METRIC = exports2.NOOP_SUM_OBSERVER_METRIC = exports2.NOOP_UP_DOWN_SUM_OBSERVER_METRIC = exports2.NOOP_VALUE_OBSERVER_METRIC = exports2.NOOP_BOUND_BASE_OBSERVER = exports2.NOOP_VALUE_RECORDER_METRIC = exports2.NOOP_BOUND_VALUE_RECORDER = exports2.NOOP_COUNTER_METRIC = exports2.NOOP_BOUND_COUNTER = exports2.NOOP_METER = exports2.NoopBoundBaseObserver = exports2.NoopBoundValueRecorder = exports2.NoopBoundCounter = exports2.NoopBatchObserverMetric = exports2.NoopBaseObserverMetric = exports2.NoopValueRecorderMetric = exports2.NoopCounterMetric = exports2.NoopMetric = exports2.NoopMeter = void 0;
  var NoopMeter = function() {
    function NoopMeter2() {
    }
    return __name(NoopMeter2, "NoopMeter"), NoopMeter2.prototype.createValueRecorder = function(name, options) {
      return exports2.NOOP_VALUE_RECORDER_METRIC;
    }, NoopMeter2.prototype.createCounter = function(name, options) {
      return exports2.NOOP_COUNTER_METRIC;
    }, NoopMeter2.prototype.createUpDownCounter = function(name, options) {
      return exports2.NOOP_COUNTER_METRIC;
    }, NoopMeter2.prototype.createValueObserver = function(name, options, callback) {
      return exports2.NOOP_VALUE_OBSERVER_METRIC;
    }, NoopMeter2.prototype.createBatchObserver = function(name, callback) {
      return exports2.NOOP_BATCH_OBSERVER_METRIC;
    }, NoopMeter2;
  }();
  exports2.NoopMeter = NoopMeter;
  var NoopMetric = function() {
    function NoopMetric2(instrument) {
      this._instrument = instrument;
    }
    return __name(NoopMetric2, "NoopMetric"), NoopMetric2.prototype.bind = function(labels) {
      return this._instrument;
    }, NoopMetric2.prototype.unbind = function(labels) {
    }, NoopMetric2.prototype.clear = function() {
    }, NoopMetric2;
  }();
  exports2.NoopMetric = NoopMetric;
  var NoopCounterMetric = function(_super) {
    __extends2(NoopCounterMetric2, _super);
    function NoopCounterMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return __name(NoopCounterMetric2, "NoopCounterMetric"), NoopCounterMetric2.prototype.add = function(value, labels) {
      this.bind(labels).add(value);
    }, NoopCounterMetric2;
  }(NoopMetric);
  exports2.NoopCounterMetric = NoopCounterMetric;
  var NoopValueRecorderMetric = function(_super) {
    __extends2(NoopValueRecorderMetric2, _super);
    function NoopValueRecorderMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return __name(NoopValueRecorderMetric2, "NoopValueRecorderMetric"), NoopValueRecorderMetric2.prototype.record = function(value, labels, correlationContext, spanContext) {
      typeof correlationContext == "undefined" ? this.bind(labels).record(value) : typeof spanContext == "undefined" ? this.bind(labels).record(value, correlationContext) : this.bind(labels).record(value, correlationContext, spanContext);
    }, NoopValueRecorderMetric2;
  }(NoopMetric);
  exports2.NoopValueRecorderMetric = NoopValueRecorderMetric;
  var NoopBaseObserverMetric = function(_super) {
    __extends2(NoopBaseObserverMetric2, _super);
    function NoopBaseObserverMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return __name(NoopBaseObserverMetric2, "NoopBaseObserverMetric"), NoopBaseObserverMetric2.prototype.observation = function() {
      return {
        observer: this,
        value: 0
      };
    }, NoopBaseObserverMetric2;
  }(NoopMetric);
  exports2.NoopBaseObserverMetric = NoopBaseObserverMetric;
  var NoopBatchObserverMetric = function(_super) {
    __extends2(NoopBatchObserverMetric2, _super);
    function NoopBatchObserverMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return __name(NoopBatchObserverMetric2, "NoopBatchObserverMetric"), NoopBatchObserverMetric2;
  }(NoopMetric);
  exports2.NoopBatchObserverMetric = NoopBatchObserverMetric;
  var NoopBoundCounter = function() {
    function NoopBoundCounter2() {
    }
    return __name(NoopBoundCounter2, "NoopBoundCounter"), NoopBoundCounter2.prototype.add = function(value) {
    }, NoopBoundCounter2;
  }();
  exports2.NoopBoundCounter = NoopBoundCounter;
  var NoopBoundValueRecorder = function() {
    function NoopBoundValueRecorder2() {
    }
    return __name(NoopBoundValueRecorder2, "NoopBoundValueRecorder"), NoopBoundValueRecorder2.prototype.record = function(value, correlationContext, spanContext) {
    }, NoopBoundValueRecorder2;
  }();
  exports2.NoopBoundValueRecorder = NoopBoundValueRecorder;
  var NoopBoundBaseObserver = function() {
    function NoopBoundBaseObserver2() {
    }
    return __name(NoopBoundBaseObserver2, "NoopBoundBaseObserver"), NoopBoundBaseObserver2.prototype.update = function(value) {
    }, NoopBoundBaseObserver2;
  }();
  exports2.NoopBoundBaseObserver = NoopBoundBaseObserver;
  exports2.NOOP_METER = new NoopMeter();
  exports2.NOOP_BOUND_COUNTER = new NoopBoundCounter();
  exports2.NOOP_COUNTER_METRIC = new NoopCounterMetric(exports2.NOOP_BOUND_COUNTER);
  exports2.NOOP_BOUND_VALUE_RECORDER = new NoopBoundValueRecorder();
  exports2.NOOP_VALUE_RECORDER_METRIC = new NoopValueRecorderMetric(exports2.NOOP_BOUND_VALUE_RECORDER);
  exports2.NOOP_BOUND_BASE_OBSERVER = new NoopBoundBaseObserver();
  exports2.NOOP_VALUE_OBSERVER_METRIC = new NoopBaseObserverMetric(exports2.NOOP_BOUND_BASE_OBSERVER);
  exports2.NOOP_UP_DOWN_SUM_OBSERVER_METRIC = new NoopBaseObserverMetric(exports2.NOOP_BOUND_BASE_OBSERVER);
  exports2.NOOP_SUM_OBSERVER_METRIC = new NoopBaseObserverMetric(exports2.NOOP_BOUND_BASE_OBSERVER);
  exports2.NOOP_BATCH_OBSERVER_METRIC = new NoopBatchObserverMetric();
});

// ../node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js
var require_NoopMeterProvider = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2.NOOP_METER_PROVIDER = exports2.NoopMeterProvider = void 0;
  var NoopMeter_1 = require_NoopMeter(), NoopMeterProvider = function() {
    function NoopMeterProvider2() {
    }
    return __name(NoopMeterProvider2, "NoopMeterProvider"), NoopMeterProvider2.prototype.getMeter = function(_name, _version) {
      return NoopMeter_1.NOOP_METER;
    }, NoopMeterProvider2;
  }();
  exports2.NoopMeterProvider = NoopMeterProvider;
  exports2.NOOP_METER_PROVIDER = new NoopMeterProvider();
});

// ../node_modules/@opentelemetry/api/build/src/metrics/Observation.js
var require_Observation = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/api/build/src/metrics/ObserverResult.js
var require_ObserverResult = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/api/build/src/trace/attributes.js
var require_attributes = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/api/build/src/trace/Event.js
var require_Event = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/api/build/src/trace/instrumentation/Plugin.js
var require_Plugin = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/api/build/src/trace/link_context.js
var require_link_context = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/api/build/src/trace/link.js
var require_link = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/api/build/src/trace/trace_flags.js
var require_trace_flags = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2.TraceFlags = void 0;
  var TraceFlags2;
  (function(TraceFlags3) {
    TraceFlags3[TraceFlags3.NONE = 0] = "NONE", TraceFlags3[TraceFlags3.SAMPLED = 1] = "SAMPLED";
  })(TraceFlags2 = exports2.TraceFlags || (exports2.TraceFlags = {}));
});

// ../node_modules/@opentelemetry/api/build/src/trace/NoopSpan.js
var require_NoopSpan = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2.NOOP_SPAN = exports2.NoopSpan = exports2.INVALID_SPAN_ID = exports2.INVALID_TRACE_ID = void 0;
  var trace_flags_1 = require_trace_flags();
  exports2.INVALID_TRACE_ID = "0";
  exports2.INVALID_SPAN_ID = "0";
  var INVALID_SPAN_CONTEXT = {
    traceId: exports2.INVALID_TRACE_ID,
    spanId: exports2.INVALID_SPAN_ID,
    traceFlags: trace_flags_1.TraceFlags.NONE
  }, NoopSpan = function() {
    function NoopSpan2(_spanContext) {
      _spanContext === void 0 && (_spanContext = INVALID_SPAN_CONTEXT), this._spanContext = _spanContext;
    }
    return __name(NoopSpan2, "NoopSpan"), NoopSpan2.prototype.context = function() {
      return this._spanContext;
    }, NoopSpan2.prototype.setAttribute = function(key, value) {
      return this;
    }, NoopSpan2.prototype.setAttributes = function(attributes) {
      return this;
    }, NoopSpan2.prototype.addEvent = function(name, attributes) {
      return this;
    }, NoopSpan2.prototype.setStatus = function(status) {
      return this;
    }, NoopSpan2.prototype.updateName = function(name) {
      return this;
    }, NoopSpan2.prototype.end = function(endTime) {
    }, NoopSpan2.prototype.isRecording = function() {
      return !1;
    }, NoopSpan2;
  }();
  exports2.NoopSpan = NoopSpan;
  exports2.NOOP_SPAN = new NoopSpan();
});

// ../node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js
var require_NoopTracer = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2.NOOP_TRACER = exports2.NoopTracer = void 0;
  var NoopSpan_1 = require_NoopSpan(), NoopTracer = function() {
    function NoopTracer2() {
    }
    return __name(NoopTracer2, "NoopTracer"), NoopTracer2.prototype.getCurrentSpan = function() {
      return NoopSpan_1.NOOP_SPAN;
    }, NoopTracer2.prototype.startSpan = function(name, options) {
      return NoopSpan_1.NOOP_SPAN;
    }, NoopTracer2.prototype.withSpan = function(span, fn) {
      return fn();
    }, NoopTracer2.prototype.bind = function(target, span) {
      return target;
    }, NoopTracer2;
  }();
  exports2.NoopTracer = NoopTracer;
  exports2.NOOP_TRACER = new NoopTracer();
});

// ../node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js
var require_NoopTracerProvider = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2.NOOP_TRACER_PROVIDER = exports2.NoopTracerProvider = void 0;
  var NoopTracer_1 = require_NoopTracer(), NoopTracerProvider = function() {
    function NoopTracerProvider2() {
    }
    return __name(NoopTracerProvider2, "NoopTracerProvider"), NoopTracerProvider2.prototype.getTracer = function(_name, _version) {
      return NoopTracer_1.NOOP_TRACER;
    }, NoopTracerProvider2;
  }();
  exports2.NoopTracerProvider = NoopTracerProvider;
  exports2.NOOP_TRACER_PROVIDER = new NoopTracerProvider();
});

// ../node_modules/@opentelemetry/api/build/src/trace/Sampler.js
var require_Sampler = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js
var require_SamplingResult = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2.SamplingDecision = void 0;
  var SamplingDecision;
  (function(SamplingDecision2) {
    SamplingDecision2[SamplingDecision2.NOT_RECORD = 0] = "NOT_RECORD", SamplingDecision2[SamplingDecision2.RECORD = 1] = "RECORD", SamplingDecision2[SamplingDecision2.RECORD_AND_SAMPLED = 2] = "RECORD_AND_SAMPLED";
  })(SamplingDecision = exports2.SamplingDecision || (exports2.SamplingDecision = {}));
});

// ../node_modules/@opentelemetry/api/build/src/trace/span_context.js
var require_span_context = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/api/build/src/trace/span_kind.js
var require_span_kind = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2.SpanKind = void 0;
  var SpanKind3;
  (function(SpanKind4) {
    SpanKind4[SpanKind4.INTERNAL = 0] = "INTERNAL", SpanKind4[SpanKind4.SERVER = 1] = "SERVER", SpanKind4[SpanKind4.CLIENT = 2] = "CLIENT", SpanKind4[SpanKind4.PRODUCER = 3] = "PRODUCER", SpanKind4[SpanKind4.CONSUMER = 4] = "CONSUMER";
  })(SpanKind3 = exports2.SpanKind || (exports2.SpanKind = {}));
});

// ../node_modules/@opentelemetry/api/build/src/trace/span.js
var require_span = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/api/build/src/trace/SpanOptions.js
var require_SpanOptions = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/api/build/src/trace/status.js
var require_status = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2.CanonicalCode = void 0;
  var CanonicalCode5;
  (function(CanonicalCode6) {
    CanonicalCode6[CanonicalCode6.OK = 0] = "OK", CanonicalCode6[CanonicalCode6.CANCELLED = 1] = "CANCELLED", CanonicalCode6[CanonicalCode6.UNKNOWN = 2] = "UNKNOWN", CanonicalCode6[CanonicalCode6.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", CanonicalCode6[CanonicalCode6.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", CanonicalCode6[CanonicalCode6.NOT_FOUND = 5] = "NOT_FOUND", CanonicalCode6[CanonicalCode6.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", CanonicalCode6[CanonicalCode6.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", CanonicalCode6[CanonicalCode6.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", CanonicalCode6[CanonicalCode6.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", CanonicalCode6[CanonicalCode6.ABORTED = 10] = "ABORTED", CanonicalCode6[CanonicalCode6.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", CanonicalCode6[CanonicalCode6.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", CanonicalCode6[CanonicalCode6.INTERNAL = 13] = "INTERNAL", CanonicalCode6[CanonicalCode6.UNAVAILABLE = 14] = "UNAVAILABLE", CanonicalCode6[CanonicalCode6.DATA_LOSS = 15] = "DATA_LOSS", CanonicalCode6[CanonicalCode6.UNAUTHENTICATED = 16] = "UNAUTHENTICATED";
  })(CanonicalCode5 = exports2.CanonicalCode || (exports2.CanonicalCode = {}));
});

// ../node_modules/@opentelemetry/api/build/src/trace/TimedEvent.js
var require_TimedEvent = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/api/build/src/trace/trace_state.js
var require_trace_state = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/api/build/src/trace/tracer_provider.js
var require_tracer_provider = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/api/build/src/trace/tracer.js
var require_tracer = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/context-base/build/src/types.js
var require_types = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
});

// ../node_modules/@opentelemetry/context-base/build/src/context.js
var require_context = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2.Context = void 0;
  var Context = function() {
    function Context2(parentContext) {
      this._currentContext = parentContext ? new Map(parentContext) : new Map();
    }
    return __name(Context2, "Context"), Context2.createKey = function(description) {
      return Symbol(description);
    }, Context2.prototype.getValue = function(key) {
      return this._currentContext.get(key);
    }, Context2.prototype.setValue = function(key, value) {
      var context = new Context2(this._currentContext);
      return context._currentContext.set(key, value), context;
    }, Context2.prototype.deleteValue = function(key) {
      var context = new Context2(this._currentContext);
      return context._currentContext.delete(key), context;
    }, Context2.ROOT_CONTEXT = new Context2(), Context2.TODO = Context2.ROOT_CONTEXT, Context2;
  }();
  exports2.Context = Context;
});

// ../node_modules/@opentelemetry/context-base/build/src/NoopContextManager.js
var require_NoopContextManager = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2.NoopContextManager = void 0;
  var context_1 = require_context(), NoopContextManager = function() {
    function NoopContextManager2() {
    }
    return __name(NoopContextManager2, "NoopContextManager"), NoopContextManager2.prototype.active = function() {
      return context_1.Context.ROOT_CONTEXT;
    }, NoopContextManager2.prototype.with = function(context, fn) {
      return fn();
    }, NoopContextManager2.prototype.bind = function(target, context) {
      return target;
    }, NoopContextManager2.prototype.enable = function() {
      return this;
    }, NoopContextManager2.prototype.disable = function() {
      return this;
    }, NoopContextManager2;
  }();
  exports2.NoopContextManager = NoopContextManager;
});

// ../node_modules/@opentelemetry/context-base/build/src/index.js
var require_src = __commonJS((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, {enumerable: !0, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    k2 === void 0 && (k2 = k), o[k2] = m[k];
  }), __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      p !== "default" && !exports3.hasOwnProperty(p) && __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  __exportStar2(require_types(), exports2);
  __exportStar2(require_context(), exports2);
  __exportStar2(require_NoopContextManager(), exports2);
});

// ../node_modules/@opentelemetry/api/build/src/platform/node/globalThis.js
var require_globalThis = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2._globalThis = void 0;
  exports2._globalThis = typeof globalThis == "object" ? globalThis : global;
});

// ../node_modules/@opentelemetry/api/build/src/platform/node/index.js
var require_node = __commonJS((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, {enumerable: !0, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    k2 === void 0 && (k2 = k), o[k2] = m[k];
  }), __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      p !== "default" && !exports3.hasOwnProperty(p) && __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  __exportStar2(require_globalThis(), exports2);
});

// ../node_modules/@opentelemetry/api/build/src/platform/index.js
var require_platform = __commonJS((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, {enumerable: !0, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    k2 === void 0 && (k2 = k), o[k2] = m[k];
  }), __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      p !== "default" && !exports3.hasOwnProperty(p) && __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  __exportStar2(require_node(), exports2);
});

// ../node_modules/@opentelemetry/api/build/src/api/global-utils.js
var require_global_utils = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2.API_BACKWARDS_COMPATIBILITY_VERSION = exports2.makeGetter = exports2._global = exports2.GLOBAL_TRACE_API_KEY = exports2.GLOBAL_PROPAGATION_API_KEY = exports2.GLOBAL_METRICS_API_KEY = exports2.GLOBAL_CONTEXT_MANAGER_API_KEY = void 0;
  var platform_1 = require_platform();
  exports2.GLOBAL_CONTEXT_MANAGER_API_KEY = Symbol.for("io.opentelemetry.js.api.context");
  exports2.GLOBAL_METRICS_API_KEY = Symbol.for("io.opentelemetry.js.api.metrics");
  exports2.GLOBAL_PROPAGATION_API_KEY = Symbol.for("io.opentelemetry.js.api.propagation");
  exports2.GLOBAL_TRACE_API_KEY = Symbol.for("io.opentelemetry.js.api.trace");
  exports2._global = platform_1._globalThis;
  function makeGetter(requiredVersion, instance, fallback) {
    return function(version2) {
      return version2 === requiredVersion ? instance : fallback;
    };
  }
  __name(makeGetter, "makeGetter");
  exports2.makeGetter = makeGetter;
  exports2.API_BACKWARDS_COMPATIBILITY_VERSION = 0;
});

// ../node_modules/@opentelemetry/api/build/src/api/context.js
var require_context2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2.ContextAPI = void 0;
  var context_base_1 = require_src(), global_utils_1 = require_global_utils(), NOOP_CONTEXT_MANAGER = new context_base_1.NoopContextManager(), ContextAPI = function() {
    function ContextAPI2() {
    }
    return __name(ContextAPI2, "ContextAPI"), ContextAPI2.getInstance = function() {
      return this._instance || (this._instance = new ContextAPI2()), this._instance;
    }, ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
      return global_utils_1._global[global_utils_1.GLOBAL_CONTEXT_MANAGER_API_KEY] ? this._getContextManager() : (global_utils_1._global[global_utils_1.GLOBAL_CONTEXT_MANAGER_API_KEY] = global_utils_1.makeGetter(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, contextManager, NOOP_CONTEXT_MANAGER), contextManager);
    }, ContextAPI2.prototype.active = function() {
      return this._getContextManager().active();
    }, ContextAPI2.prototype.with = function(context, fn) {
      return this._getContextManager().with(context, fn);
    }, ContextAPI2.prototype.bind = function(target, context) {
      return context === void 0 && (context = this.active()), this._getContextManager().bind(target, context);
    }, ContextAPI2.prototype._getContextManager = function() {
      var _a, _b;
      return (_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_CONTEXT_MANAGER_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NOOP_CONTEXT_MANAGER;
    }, ContextAPI2.prototype.disable = function() {
      this._getContextManager().disable(), delete global_utils_1._global[global_utils_1.GLOBAL_CONTEXT_MANAGER_API_KEY];
    }, ContextAPI2;
  }();
  exports2.ContextAPI = ContextAPI;
});

// ../node_modules/@opentelemetry/api/build/src/api/trace.js
var require_trace = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2.TraceAPI = void 0;
  var NoopTracerProvider_1 = require_NoopTracerProvider(), global_utils_1 = require_global_utils(), TraceAPI = function() {
    function TraceAPI2() {
    }
    return __name(TraceAPI2, "TraceAPI"), TraceAPI2.getInstance = function() {
      return this._instance || (this._instance = new TraceAPI2()), this._instance;
    }, TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
      return global_utils_1._global[global_utils_1.GLOBAL_TRACE_API_KEY] ? this.getTracerProvider() : (global_utils_1._global[global_utils_1.GLOBAL_TRACE_API_KEY] = global_utils_1.makeGetter(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, provider, NoopTracerProvider_1.NOOP_TRACER_PROVIDER), this.getTracerProvider());
    }, TraceAPI2.prototype.getTracerProvider = function() {
      var _a, _b;
      return (_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_TRACE_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NoopTracerProvider_1.NOOP_TRACER_PROVIDER;
    }, TraceAPI2.prototype.getTracer = function(name, version2) {
      return this.getTracerProvider().getTracer(name, version2);
    }, TraceAPI2.prototype.disable = function() {
      delete global_utils_1._global[global_utils_1.GLOBAL_TRACE_API_KEY];
    }, TraceAPI2;
  }();
  exports2.TraceAPI = TraceAPI;
});

// ../node_modules/@opentelemetry/api/build/src/api/metrics.js
var require_metrics = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2.MetricsAPI = void 0;
  var NoopMeterProvider_1 = require_NoopMeterProvider(), global_utils_1 = require_global_utils(), MetricsAPI = function() {
    function MetricsAPI2() {
    }
    return __name(MetricsAPI2, "MetricsAPI"), MetricsAPI2.getInstance = function() {
      return this._instance || (this._instance = new MetricsAPI2()), this._instance;
    }, MetricsAPI2.prototype.setGlobalMeterProvider = function(provider) {
      return global_utils_1._global[global_utils_1.GLOBAL_METRICS_API_KEY] ? this.getMeterProvider() : (global_utils_1._global[global_utils_1.GLOBAL_METRICS_API_KEY] = global_utils_1.makeGetter(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, provider, NoopMeterProvider_1.NOOP_METER_PROVIDER), provider);
    }, MetricsAPI2.prototype.getMeterProvider = function() {
      var _a, _b;
      return (_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_METRICS_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NoopMeterProvider_1.NOOP_METER_PROVIDER;
    }, MetricsAPI2.prototype.getMeter = function(name, version2) {
      return this.getMeterProvider().getMeter(name, version2);
    }, MetricsAPI2.prototype.disable = function() {
      delete global_utils_1._global[global_utils_1.GLOBAL_METRICS_API_KEY];
    }, MetricsAPI2;
  }();
  exports2.MetricsAPI = MetricsAPI;
});

// ../node_modules/@opentelemetry/api/build/src/api/propagation.js
var require_propagation = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2.PropagationAPI = void 0;
  var getter_1 = require_getter(), NoopHttpTextPropagator_1 = require_NoopHttpTextPropagator(), setter_1 = require_setter(), context_1 = require_context2(), global_utils_1 = require_global_utils(), contextApi = context_1.ContextAPI.getInstance(), PropagationAPI = function() {
    function PropagationAPI2() {
    }
    return __name(PropagationAPI2, "PropagationAPI"), PropagationAPI2.getInstance = function() {
      return this._instance || (this._instance = new PropagationAPI2()), this._instance;
    }, PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {
      return global_utils_1._global[global_utils_1.GLOBAL_PROPAGATION_API_KEY] ? this._getGlobalPropagator() : (global_utils_1._global[global_utils_1.GLOBAL_PROPAGATION_API_KEY] = global_utils_1.makeGetter(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, propagator, NoopHttpTextPropagator_1.NOOP_HTTP_TEXT_PROPAGATOR), propagator);
    }, PropagationAPI2.prototype.inject = function(carrier, setter, context) {
      return setter === void 0 && (setter = setter_1.defaultSetter), context === void 0 && (context = contextApi.active()), this._getGlobalPropagator().inject(context, carrier, setter);
    }, PropagationAPI2.prototype.extract = function(carrier, getter, context) {
      return getter === void 0 && (getter = getter_1.defaultGetter), context === void 0 && (context = contextApi.active()), this._getGlobalPropagator().extract(context, carrier, getter);
    }, PropagationAPI2.prototype.disable = function() {
      delete global_utils_1._global[global_utils_1.GLOBAL_PROPAGATION_API_KEY];
    }, PropagationAPI2.prototype._getGlobalPropagator = function() {
      var _a, _b;
      return (_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_PROPAGATION_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NoopHttpTextPropagator_1.NOOP_HTTP_TEXT_PROPAGATOR;
    }, PropagationAPI2;
  }();
  exports2.PropagationAPI = PropagationAPI;
});

// ../node_modules/@opentelemetry/api/build/src/index.js
var require_src2 = __commonJS((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, {enumerable: !0, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    k2 === void 0 && (k2 = k), o[k2] = m[k];
  }), __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      p !== "default" && !exports3.hasOwnProperty(p) && __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  exports2.propagation = exports2.metrics = exports2.trace = exports2.context = void 0;
  __exportStar2(require_Logger(), exports2);
  __exportStar2(require_Time(), exports2);
  __exportStar2(require_getter(), exports2);
  __exportStar2(require_HttpTextPropagator(), exports2);
  __exportStar2(require_NoopHttpTextPropagator(), exports2);
  __exportStar2(require_setter(), exports2);
  __exportStar2(require_CorrelationContext(), exports2);
  __exportStar2(require_EntryValue(), exports2);
  __exportStar2(require_BatchObserverResult(), exports2);
  __exportStar2(require_BoundInstrument(), exports2);
  __exportStar2(require_Meter(), exports2);
  __exportStar2(require_MeterProvider(), exports2);
  __exportStar2(require_Metric(), exports2);
  __exportStar2(require_NoopMeter(), exports2);
  __exportStar2(require_NoopMeterProvider(), exports2);
  __exportStar2(require_Observation(), exports2);
  __exportStar2(require_ObserverResult(), exports2);
  __exportStar2(require_attributes(), exports2);
  __exportStar2(require_Event(), exports2);
  __exportStar2(require_Plugin(), exports2);
  __exportStar2(require_link_context(), exports2);
  __exportStar2(require_link(), exports2);
  __exportStar2(require_NoopSpan(), exports2);
  __exportStar2(require_NoopTracer(), exports2);
  __exportStar2(require_NoopTracerProvider(), exports2);
  __exportStar2(require_Sampler(), exports2);
  __exportStar2(require_SamplingResult(), exports2);
  __exportStar2(require_span_context(), exports2);
  __exportStar2(require_span_kind(), exports2);
  __exportStar2(require_span(), exports2);
  __exportStar2(require_SpanOptions(), exports2);
  __exportStar2(require_status(), exports2);
  __exportStar2(require_TimedEvent(), exports2);
  __exportStar2(require_trace_flags(), exports2);
  __exportStar2(require_trace_state(), exports2);
  __exportStar2(require_tracer_provider(), exports2);
  __exportStar2(require_tracer(), exports2);
  var context_base_1 = require_src();
  Object.defineProperty(exports2, "Context", {enumerable: !0, get: function() {
    return context_base_1.Context;
  }});
  var context_1 = require_context2();
  exports2.context = context_1.ContextAPI.getInstance();
  var trace_1 = require_trace();
  exports2.trace = trace_1.TraceAPI.getInstance();
  var metrics_1 = require_metrics();
  exports2.metrics = metrics_1.MetricsAPI.getInstance();
  var propagation_1 = require_propagation();
  exports2.propagation = propagation_1.PropagationAPI.getInstance();
  exports2.default = {
    trace: exports2.trace,
    metrics: exports2.metrics,
    context: exports2.context,
    propagation: exports2.propagation
  };
});

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/index.js
var require_src3 = __commonJS((exports2) => {
  __export(exports2, {
    AccountSASPermissions: () => AccountSASPermissions,
    AccountSASResourceTypes: () => AccountSASResourceTypes,
    AccountSASServices: () => AccountSASServices,
    AnonymousCredential: () => AnonymousCredential,
    AnonymousCredentialPolicy: () => AnonymousCredentialPolicy,
    AppendBlobClient: () => AppendBlobClient,
    BaseRequestPolicy: () => BaseRequestPolicy,
    BlobBatch: () => BlobBatch,
    BlobBatchClient: () => BlobBatchClient,
    BlobClient: () => BlobClient,
    BlobLeaseClient: () => BlobLeaseClient,
    BlobSASPermissions: () => BlobSASPermissions,
    BlobServiceClient: () => BlobServiceClient,
    BlockBlobClient: () => BlockBlobClient,
    BlockBlobTier: () => BlockBlobTier,
    ContainerClient: () => ContainerClient,
    ContainerSASPermissions: () => ContainerSASPermissions,
    Credential: () => Credential,
    CredentialPolicy: () => CredentialPolicy,
    HttpHeaders: () => HttpHeaders,
    PageBlobClient: () => PageBlobClient,
    Pipeline: () => Pipeline,
    PremiumPageBlobTier: () => PremiumPageBlobTier,
    RequestPolicyOptions: () => RequestPolicyOptions,
    RestError: () => RestError,
    SASProtocol: () => SASProtocol,
    SASQueryParameters: () => SASQueryParameters,
    StorageBrowserPolicy: () => StorageBrowserPolicy,
    StorageBrowserPolicyFactory: () => StorageBrowserPolicyFactory,
    StorageOAuthScopes: () => StorageOAuthScopes,
    StorageRetryPolicy: () => StorageRetryPolicy,
    StorageRetryPolicyFactory: () => StorageRetryPolicyFactory,
    StorageRetryPolicyType: () => StorageRetryPolicyType,
    StorageSharedKeyCredential: () => StorageSharedKeyCredential,
    StorageSharedKeyCredentialPolicy: () => StorageSharedKeyCredentialPolicy,
    WebResource: () => WebResource,
    deserializationPolicy: () => deserializationPolicy,
    generateAccountSASQueryParameters: () => generateAccountSASQueryParameters,
    generateBlobSASQueryParameters: () => generateBlobSASQueryParameters,
    logger: () => logger2,
    newPipeline: () => newPipeline
  });
});

// ../node_modules/@actions/cache/lib/internal/requestUtils.js
var require_requestUtils = __commonJS((exports2) => {
  "use strict";
  var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return __name(adopt, "adopt"), new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(fulfilled, "fulfilled");
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(rejected, "rejected");
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      __name(step, "step"), step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }, __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
    return result.default = mod, result;
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var core = __importStar(require_core()), http_client_1 = require_http_client(), constants_1 = require_constants();
  function isSuccessStatusCode(statusCode) {
    return statusCode ? statusCode >= 200 && statusCode < 300 : !1;
  }
  __name(isSuccessStatusCode, "isSuccessStatusCode");
  exports2.isSuccessStatusCode = isSuccessStatusCode;
  function isServerErrorStatusCode(statusCode) {
    return statusCode ? statusCode >= 500 : !0;
  }
  __name(isServerErrorStatusCode, "isServerErrorStatusCode");
  exports2.isServerErrorStatusCode = isServerErrorStatusCode;
  function isRetryableStatusCode(statusCode) {
    return statusCode ? [
      http_client_1.HttpCodes.BadGateway,
      http_client_1.HttpCodes.ServiceUnavailable,
      http_client_1.HttpCodes.GatewayTimeout
    ].includes(statusCode) : !1;
  }
  __name(isRetryableStatusCode, "isRetryableStatusCode");
  exports2.isRetryableStatusCode = isRetryableStatusCode;
  function sleep(milliseconds) {
    return __awaiter2(this, void 0, void 0, function* () {
      return new Promise((resolve) => setTimeout(resolve, milliseconds));
    });
  }
  __name(sleep, "sleep");
  function retry3(name, method, getStatusCode, maxAttempts = constants_1.DefaultRetryAttempts, delay3 = constants_1.DefaultRetryDelay, onError = void 0) {
    return __awaiter2(this, void 0, void 0, function* () {
      let errorMessage = "", attempt = 1;
      for (; attempt <= maxAttempts; ) {
        let response, statusCode, isRetryable = !1;
        try {
          response = yield method();
        } catch (error) {
          onError && (response = onError(error)), isRetryable = !0, errorMessage = error.message;
        }
        if (response && (statusCode = getStatusCode(response), !isServerErrorStatusCode(statusCode)))
          return response;
        if (statusCode && (isRetryable = isRetryableStatusCode(statusCode), errorMessage = `Cache service responded with ${statusCode}`), core.debug(`${name} - Attempt ${attempt} of ${maxAttempts} failed with error: ${errorMessage}`), !isRetryable) {
          core.debug(`${name} - Error is not retryable`);
          break;
        }
        yield sleep(delay3), attempt++;
      }
      throw Error(`${name} failed: ${errorMessage}`);
    });
  }
  __name(retry3, "retry");
  exports2.retry = retry3;
  function retryTypedResponse(name, method, maxAttempts = constants_1.DefaultRetryAttempts, delay3 = constants_1.DefaultRetryDelay) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield retry3(name, method, (response) => response.statusCode, maxAttempts, delay3, (error) => {
        if (error instanceof http_client_1.HttpClientError)
          return {
            statusCode: error.statusCode,
            result: null,
            headers: {}
          };
      });
    });
  }
  __name(retryTypedResponse, "retryTypedResponse");
  exports2.retryTypedResponse = retryTypedResponse;
  function retryHttpClientResponse(name, method, maxAttempts = constants_1.DefaultRetryAttempts, delay3 = constants_1.DefaultRetryDelay) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield retry3(name, method, (response) => response.message.statusCode, maxAttempts, delay3);
    });
  }
  __name(retryHttpClientResponse, "retryHttpClientResponse");
  exports2.retryHttpClientResponse = retryHttpClientResponse;
});

// ../node_modules/@actions/cache/lib/internal/downloadUtils.js
var require_downloadUtils = __commonJS((exports2) => {
  "use strict";
  var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return __name(adopt, "adopt"), new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(fulfilled, "fulfilled");
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(rejected, "rejected");
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      __name(step, "step"), step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }, __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
    return result.default = mod, result;
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var core = __importStar(require_core()), http_client_1 = require_http_client(), storage_blob_1 = require_src3(), buffer = __importStar(require("buffer")), fs4 = __importStar(require("fs")), stream = __importStar(require("stream")), util3 = __importStar(require("util")), utils6 = __importStar(require_cacheUtils()), constants_1 = require_constants(), requestUtils_1 = require_requestUtils();
  function pipeResponseToStream(response, output) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield util3.promisify(stream.pipeline)(response.message, output);
    });
  }
  __name(pipeResponseToStream, "pipeResponseToStream");
  var DownloadProgress = class {
    constructor(contentLength2) {
      this.contentLength = contentLength2, this.segmentIndex = 0, this.segmentSize = 0, this.segmentOffset = 0, this.receivedBytes = 0, this.displayedComplete = !1, this.startTime = Date.now();
    }
    nextSegment(segmentSize) {
      this.segmentOffset = this.segmentOffset + this.segmentSize, this.segmentIndex = this.segmentIndex + 1, this.segmentSize = segmentSize, this.receivedBytes = 0, core.debug(`Downloading segment at offset ${this.segmentOffset} with length ${this.segmentSize}...`);
    }
    setReceivedBytes(receivedBytes) {
      this.receivedBytes = receivedBytes;
    }
    getTransferredBytes() {
      return this.segmentOffset + this.receivedBytes;
    }
    isDone() {
      return this.getTransferredBytes() === this.contentLength;
    }
    display() {
      if (this.displayedComplete)
        return;
      let transferredBytes = this.segmentOffset + this.receivedBytes, percentage = (100 * (transferredBytes / this.contentLength)).toFixed(1), elapsedTime = Date.now() - this.startTime, downloadSpeed = (transferredBytes / (1024 * 1024) / (elapsedTime / 1e3)).toFixed(1);
      core.info(`Received ${transferredBytes} of ${this.contentLength} (${percentage}%), ${downloadSpeed} MBs/sec`), this.isDone() && (this.displayedComplete = !0);
    }
    onProgress() {
      return (progress) => {
        this.setReceivedBytes(progress.loadedBytes);
      };
    }
    startDisplayTimer(delayInMs = 1e3) {
      let displayCallback = /* @__PURE__ */ __name(() => {
        this.display(), this.isDone() || (this.timeoutHandle = setTimeout(displayCallback, delayInMs));
      }, "displayCallback");
      this.timeoutHandle = setTimeout(displayCallback, delayInMs);
    }
    stopDisplayTimer() {
      this.timeoutHandle && (clearTimeout(this.timeoutHandle), this.timeoutHandle = void 0), this.display();
    }
  };
  __name(DownloadProgress, "DownloadProgress");
  exports2.DownloadProgress = DownloadProgress;
  function downloadCacheHttpClient(archiveLocation, archivePath) {
    return __awaiter2(this, void 0, void 0, function* () {
      let writeStream = fs4.createWriteStream(archivePath), httpClient = new http_client_1.HttpClient("actions/cache"), downloadResponse = yield requestUtils_1.retryHttpClientResponse("downloadCache", () => __awaiter2(this, void 0, void 0, function* () {
        return httpClient.get(archiveLocation);
      }));
      downloadResponse.message.socket.setTimeout(constants_1.SocketTimeout, () => {
        downloadResponse.message.destroy(), core.debug(`Aborting download, socket timed out after ${constants_1.SocketTimeout} ms`);
      }), yield pipeResponseToStream(downloadResponse, writeStream);
      let contentLengthHeader = downloadResponse.message.headers["content-length"];
      if (contentLengthHeader) {
        let expectedLength = parseInt(contentLengthHeader), actualLength = utils6.getArchiveFileSizeIsBytes(archivePath);
        if (actualLength !== expectedLength)
          throw new Error(`Incomplete download. Expected file size: ${expectedLength}, actual file size: ${actualLength}`);
      } else
        core.debug("Unable to validate download, no Content-Length header");
    });
  }
  __name(downloadCacheHttpClient, "downloadCacheHttpClient");
  exports2.downloadCacheHttpClient = downloadCacheHttpClient;
  function downloadCacheStorageSDK(archiveLocation, archivePath, options) {
    var _a;
    return __awaiter2(this, void 0, void 0, function* () {
      let client = new storage_blob_1.BlockBlobClient(archiveLocation, void 0, {
        retryOptions: {
          tryTimeoutInMs: options.timeoutInMs
        }
      }), contentLength2 = (_a = (yield client.getProperties()).contentLength) !== null && _a !== void 0 ? _a : -1;
      if (contentLength2 < 0)
        core.debug("Unable to determine content length, downloading file with http-client..."), yield downloadCacheHttpClient(archiveLocation, archivePath);
      else {
        let maxSegmentSize = buffer.constants.MAX_LENGTH, downloadProgress = new DownloadProgress(contentLength2), fd = fs4.openSync(archivePath, "w");
        try {
          for (downloadProgress.startDisplayTimer(); !downloadProgress.isDone(); ) {
            let segmentStart = downloadProgress.segmentOffset + downloadProgress.segmentSize, segmentSize = Math.min(maxSegmentSize, contentLength2 - segmentStart);
            downloadProgress.nextSegment(segmentSize);
            let result = yield client.downloadToBuffer(segmentStart, segmentSize, {
              concurrency: options.downloadConcurrency,
              onProgress: downloadProgress.onProgress()
            });
            fs4.writeFileSync(fd, result);
          }
        } finally {
          downloadProgress.stopDisplayTimer(), fs4.closeSync(fd);
        }
      }
    });
  }
  __name(downloadCacheStorageSDK, "downloadCacheStorageSDK");
  exports2.downloadCacheStorageSDK = downloadCacheStorageSDK;
});

// ../node_modules/@actions/cache/lib/options.js
var require_options = __commonJS((exports2) => {
  "use strict";
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
    return result.default = mod, result;
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var core = __importStar(require_core());
  function getUploadOptions(copy) {
    let result = {
      uploadConcurrency: 4,
      uploadChunkSize: 32 * 1024 * 1024
    };
    return copy && (typeof copy.uploadConcurrency == "number" && (result.uploadConcurrency = copy.uploadConcurrency), typeof copy.uploadChunkSize == "number" && (result.uploadChunkSize = copy.uploadChunkSize)), core.debug(`Upload concurrency: ${result.uploadConcurrency}`), core.debug(`Upload chunk size: ${result.uploadChunkSize}`), result;
  }
  __name(getUploadOptions, "getUploadOptions");
  exports2.getUploadOptions = getUploadOptions;
  function getDownloadOptions(copy) {
    let result = {
      useAzureSdk: !0,
      downloadConcurrency: 8,
      timeoutInMs: 3e4
    };
    return copy && (typeof copy.useAzureSdk == "boolean" && (result.useAzureSdk = copy.useAzureSdk), typeof copy.downloadConcurrency == "number" && (result.downloadConcurrency = copy.downloadConcurrency), typeof copy.timeoutInMs == "number" && (result.timeoutInMs = copy.timeoutInMs)), core.debug(`Use Azure SDK: ${result.useAzureSdk}`), core.debug(`Download concurrency: ${result.downloadConcurrency}`), core.debug(`Request timeout (ms): ${result.timeoutInMs}`), result;
  }
  __name(getDownloadOptions, "getDownloadOptions");
  exports2.getDownloadOptions = getDownloadOptions;
});

// ../node_modules/@actions/cache/lib/internal/cacheHttpClient.js
var require_cacheHttpClient = __commonJS((exports2) => {
  "use strict";
  var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return __name(adopt, "adopt"), new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(fulfilled, "fulfilled");
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(rejected, "rejected");
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      __name(step, "step"), step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }, __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
    return result.default = mod, result;
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var core = __importStar(require_core()), http_client_1 = require_http_client(), auth_1 = require_auth(), crypto2 = __importStar(require("crypto")), fs4 = __importStar(require("fs")), url_1 = require("url"), utils6 = __importStar(require_cacheUtils()), constants_1 = require_constants(), downloadUtils_1 = require_downloadUtils(), options_1 = require_options(), requestUtils_1 = require_requestUtils(), versionSalt = "1.0";
  function getCacheApiUrl(resource) {
    let baseUrl = (process.env.ACTIONS_CACHE_URL || process.env.ACTIONS_RUNTIME_URL || "").replace("pipelines", "artifactcache");
    if (!baseUrl)
      throw new Error("Cache Service Url not found, unable to restore cache.");
    let url2 = `${baseUrl}_apis/artifactcache/${resource}`;
    return core.debug(`Resource Url: ${url2}`), url2;
  }
  __name(getCacheApiUrl, "getCacheApiUrl");
  function createAcceptHeader(type3, apiVersion) {
    return `${type3};api-version=${apiVersion}`;
  }
  __name(createAcceptHeader, "createAcceptHeader");
  function getRequestOptions() {
    return {
      headers: {
        Accept: createAcceptHeader("application/json", "6.0-preview.1")
      }
    };
  }
  __name(getRequestOptions, "getRequestOptions");
  function createHttpClient() {
    let token = process.env.ACTIONS_RUNTIME_TOKEN || "", bearerCredentialHandler = new auth_1.BearerCredentialHandler(token);
    return new http_client_1.HttpClient("actions/cache", [bearerCredentialHandler], getRequestOptions());
  }
  __name(createHttpClient, "createHttpClient");
  function getCacheVersion(paths, compressionMethod) {
    let components = paths.concat(!compressionMethod || compressionMethod === constants_1.CompressionMethod.Gzip ? [] : [compressionMethod]);
    return components.push(versionSalt), crypto2.createHash("sha256").update(components.join("|")).digest("hex");
  }
  __name(getCacheVersion, "getCacheVersion");
  exports2.getCacheVersion = getCacheVersion;
  function getCacheEntry(keys, paths, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      let httpClient = createHttpClient(), version2 = getCacheVersion(paths, options == null ? void 0 : options.compressionMethod), resource = `cache?keys=${encodeURIComponent(keys.join(","))}&version=${version2}`, response = yield requestUtils_1.retryTypedResponse("getCacheEntry", () => __awaiter2(this, void 0, void 0, function* () {
        return httpClient.getJson(getCacheApiUrl(resource));
      }));
      if (response.statusCode === 204)
        return null;
      if (!requestUtils_1.isSuccessStatusCode(response.statusCode))
        throw new Error(`Cache service responded with ${response.statusCode}`);
      let cacheResult = response.result, cacheDownloadUrl = cacheResult == null ? void 0 : cacheResult.archiveLocation;
      if (!cacheDownloadUrl)
        throw new Error("Cache not found.");
      return core.setSecret(cacheDownloadUrl), core.debug("Cache Result:"), core.debug(JSON.stringify(cacheResult)), cacheResult;
    });
  }
  __name(getCacheEntry, "getCacheEntry");
  exports2.getCacheEntry = getCacheEntry;
  function downloadCache(archiveLocation, archivePath, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      let archiveUrl = new url_1.URL(archiveLocation), downloadOptions = options_1.getDownloadOptions(options);
      downloadOptions.useAzureSdk && archiveUrl.hostname.endsWith(".blob.core.windows.net") ? yield downloadUtils_1.downloadCacheStorageSDK(archiveLocation, archivePath, downloadOptions) : yield downloadUtils_1.downloadCacheHttpClient(archiveLocation, archivePath);
    });
  }
  __name(downloadCache, "downloadCache");
  exports2.downloadCache = downloadCache;
  function reserveCache(key, paths, options) {
    var _a, _b;
    return __awaiter2(this, void 0, void 0, function* () {
      let httpClient = createHttpClient(), version2 = getCacheVersion(paths, options == null ? void 0 : options.compressionMethod), reserveCacheRequest = {
        key,
        version: version2
      }, response = yield requestUtils_1.retryTypedResponse("reserveCache", () => __awaiter2(this, void 0, void 0, function* () {
        return httpClient.postJson(getCacheApiUrl("caches"), reserveCacheRequest);
      }));
      return (_b = (_a = response == null ? void 0 : response.result) === null || _a === void 0 ? void 0 : _a.cacheId) !== null && _b !== void 0 ? _b : -1;
    });
  }
  __name(reserveCache, "reserveCache");
  exports2.reserveCache = reserveCache;
  function getContentRange(start, end) {
    return `bytes ${start}-${end}/*`;
  }
  __name(getContentRange, "getContentRange");
  function uploadChunk(httpClient, resourceUrl, openStream, start, end) {
    return __awaiter2(this, void 0, void 0, function* () {
      core.debug(`Uploading chunk of size ${end - start + 1} bytes at offset ${start} with content range: ${getContentRange(start, end)}`);
      let additionalHeaders = {
        "Content-Type": "application/octet-stream",
        "Content-Range": getContentRange(start, end)
      }, uploadChunkResponse = yield requestUtils_1.retryHttpClientResponse(`uploadChunk (start: ${start}, end: ${end})`, () => __awaiter2(this, void 0, void 0, function* () {
        return httpClient.sendStream("PATCH", resourceUrl, openStream(), additionalHeaders);
      }));
      if (!requestUtils_1.isSuccessStatusCode(uploadChunkResponse.message.statusCode))
        throw new Error(`Cache service responded with ${uploadChunkResponse.message.statusCode} during upload chunk.`);
    });
  }
  __name(uploadChunk, "uploadChunk");
  function uploadFile(httpClient, cacheId, archivePath, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      let fileSize = fs4.statSync(archivePath).size, resourceUrl = getCacheApiUrl(`caches/${cacheId.toString()}`), fd = fs4.openSync(archivePath, "r"), uploadOptions = options_1.getUploadOptions(options), concurrency = utils6.assertDefined("uploadConcurrency", uploadOptions.uploadConcurrency), maxChunkSize = utils6.assertDefined("uploadChunkSize", uploadOptions.uploadChunkSize), parallelUploads = [...new Array(concurrency).keys()];
      core.debug("Awaiting all uploads");
      let offset = 0;
      try {
        yield Promise.all(parallelUploads.map(() => __awaiter2(this, void 0, void 0, function* () {
          for (; offset < fileSize; ) {
            let chunkSize = Math.min(fileSize - offset, maxChunkSize), start = offset, end = offset + chunkSize - 1;
            offset += maxChunkSize, yield uploadChunk(httpClient, resourceUrl, () => fs4.createReadStream(archivePath, {
              fd,
              start,
              end,
              autoClose: !1
            }).on("error", (error) => {
              throw new Error(`Cache upload failed because file read failed with ${error.message}`);
            }), start, end);
          }
        })));
      } finally {
        fs4.closeSync(fd);
      }
    });
  }
  __name(uploadFile, "uploadFile");
  function commitCache(httpClient, cacheId, filesize) {
    return __awaiter2(this, void 0, void 0, function* () {
      let commitCacheRequest = {size: filesize};
      return yield requestUtils_1.retryTypedResponse("commitCache", () => __awaiter2(this, void 0, void 0, function* () {
        return httpClient.postJson(getCacheApiUrl(`caches/${cacheId.toString()}`), commitCacheRequest);
      }));
    });
  }
  __name(commitCache, "commitCache");
  function saveCache2(cacheId, archivePath, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      let httpClient = createHttpClient();
      core.debug("Upload cache"), yield uploadFile(httpClient, cacheId, archivePath, options), core.debug("Commiting cache");
      let cacheSize = utils6.getArchiveFileSizeIsBytes(archivePath), commitCacheResponse = yield commitCache(httpClient, cacheId, cacheSize);
      if (!requestUtils_1.isSuccessStatusCode(commitCacheResponse.statusCode))
        throw new Error(`Cache service responded with ${commitCacheResponse.statusCode} during commit cache.`);
      core.info("Cache saved successfully");
    });
  }
  __name(saveCache2, "saveCache");
  exports2.saveCache = saveCache2;
});

// ../node_modules/@actions/cache/lib/internal/tar.js
var require_tar = __commonJS((exports2) => {
  "use strict";
  var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return __name(adopt, "adopt"), new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(fulfilled, "fulfilled");
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(rejected, "rejected");
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      __name(step, "step"), step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }, __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
    return result.default = mod, result;
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var exec_1 = require_exec(), io = __importStar(require_io()), fs_1 = require("fs"), path3 = __importStar(require("path")), utils6 = __importStar(require_cacheUtils()), constants_1 = require_constants();
  function getTarPath(args, compressionMethod) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (process.platform === "win32") {
        let systemTar = `${process.env.windir}\\System32\\tar.exe`;
        if (compressionMethod !== constants_1.CompressionMethod.Gzip)
          args.push("--force-local");
        else {
          if (fs_1.existsSync(systemTar))
            return systemTar;
          (yield utils6.isGnuTarInstalled()) && args.push("--force-local");
        }
      }
      return yield io.which("tar", !0);
    });
  }
  __name(getTarPath, "getTarPath");
  function execTar(args, compressionMethod, cwd) {
    return __awaiter2(this, void 0, void 0, function* () {
      try {
        yield exec_1.exec(`"${yield getTarPath(args, compressionMethod)}"`, args, {cwd});
      } catch (error) {
        throw new Error(`Tar failed with error: ${error == null ? void 0 : error.message}`);
      }
    });
  }
  __name(execTar, "execTar");
  function getWorkingDirectory() {
    var _a;
    return (_a = process.env.GITHUB_WORKSPACE) !== null && _a !== void 0 ? _a : process.cwd();
  }
  __name(getWorkingDirectory, "getWorkingDirectory");
  function extractTar(archivePath, compressionMethod) {
    return __awaiter2(this, void 0, void 0, function* () {
      let workingDirectory = getWorkingDirectory();
      yield io.mkdirP(workingDirectory);
      function getCompressionProgram() {
        switch (compressionMethod) {
          case constants_1.CompressionMethod.Zstd:
            return ["--use-compress-program", "zstd -d --long=30"];
          case constants_1.CompressionMethod.ZstdWithoutLong:
            return ["--use-compress-program", "zstd -d"];
          default:
            return ["-z"];
        }
      }
      __name(getCompressionProgram, "getCompressionProgram");
      let args = [
        ...getCompressionProgram(),
        "-xf",
        archivePath.replace(new RegExp(`\\${path3.sep}`, "g"), "/"),
        "-P",
        "-C",
        workingDirectory.replace(new RegExp(`\\${path3.sep}`, "g"), "/")
      ];
      yield execTar(args, compressionMethod);
    });
  }
  __name(extractTar, "extractTar");
  exports2.extractTar = extractTar;
  function createTar(archiveFolder, sourceDirectories, compressionMethod) {
    return __awaiter2(this, void 0, void 0, function* () {
      let manifestFilename = "manifest.txt", cacheFileName = utils6.getCacheFileName(compressionMethod);
      fs_1.writeFileSync(path3.join(archiveFolder, manifestFilename), sourceDirectories.join(`
`));
      let workingDirectory = getWorkingDirectory();
      function getCompressionProgram() {
        switch (compressionMethod) {
          case constants_1.CompressionMethod.Zstd:
            return ["--use-compress-program", "zstd -T0 --long=30"];
          case constants_1.CompressionMethod.ZstdWithoutLong:
            return ["--use-compress-program", "zstd -T0"];
          default:
            return ["-z"];
        }
      }
      __name(getCompressionProgram, "getCompressionProgram");
      let args = [
        "--posix",
        ...getCompressionProgram(),
        "-cf",
        cacheFileName.replace(new RegExp(`\\${path3.sep}`, "g"), "/"),
        "-P",
        "-C",
        workingDirectory.replace(new RegExp(`\\${path3.sep}`, "g"), "/"),
        "--files-from",
        manifestFilename
      ];
      yield execTar(args, compressionMethod, archiveFolder);
    });
  }
  __name(createTar, "createTar");
  exports2.createTar = createTar;
});

// ../node_modules/@actions/cache/lib/cache.js
var require_cache = __commonJS((exports2) => {
  "use strict";
  var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return __name(adopt, "adopt"), new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(fulfilled, "fulfilled");
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(rejected, "rejected");
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      __name(step, "step"), step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }, __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
    return result.default = mod, result;
  };
  Object.defineProperty(exports2, "__esModule", {value: !0});
  var core = __importStar(require_core()), path3 = __importStar(require("path")), utils6 = __importStar(require_cacheUtils()), cacheHttpClient = __importStar(require_cacheHttpClient()), tar_1 = require_tar(), ValidationError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "ValidationError", Object.setPrototypeOf(this, ValidationError.prototype);
    }
  };
  __name(ValidationError, "ValidationError");
  exports2.ValidationError = ValidationError;
  var ReserveCacheError2 = class extends Error {
    constructor(message) {
      super(message);
      this.name = "ReserveCacheError", Object.setPrototypeOf(this, ReserveCacheError2.prototype);
    }
  };
  __name(ReserveCacheError2, "ReserveCacheError");
  exports2.ReserveCacheError = ReserveCacheError2;
  function checkPaths(paths) {
    if (!paths || paths.length === 0)
      throw new ValidationError("Path Validation Error: At least one directory or file path is required");
  }
  __name(checkPaths, "checkPaths");
  function checkKey(key) {
    if (key.length > 512)
      throw new ValidationError(`Key Validation Error: ${key} cannot be larger than 512 characters.`);
    if (!/^[^,]*$/.test(key))
      throw new ValidationError(`Key Validation Error: ${key} cannot contain commas.`);
  }
  __name(checkKey, "checkKey");
  function restoreCache2(paths, primaryKey, restoreKeys, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      checkPaths(paths), restoreKeys = restoreKeys || [];
      let keys = [primaryKey, ...restoreKeys];
      if (core.debug("Resolved Keys:"), core.debug(JSON.stringify(keys)), keys.length > 10)
        throw new ValidationError("Key Validation Error: Keys are limited to a maximum of 10.");
      for (let key of keys)
        checkKey(key);
      let compressionMethod = yield utils6.getCompressionMethod(), cacheEntry = yield cacheHttpClient.getCacheEntry(keys, paths, {
        compressionMethod
      });
      if (!(cacheEntry == null ? void 0 : cacheEntry.archiveLocation))
        return;
      let archivePath = path3.join(yield utils6.createTempDirectory(), utils6.getCacheFileName(compressionMethod));
      core.debug(`Archive Path: ${archivePath}`);
      try {
        yield cacheHttpClient.downloadCache(cacheEntry.archiveLocation, archivePath, options);
        let archiveFileSize = utils6.getArchiveFileSizeIsBytes(archivePath);
        core.info(`Cache Size: ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B)`), yield tar_1.extractTar(archivePath, compressionMethod);
      } finally {
        try {
          yield utils6.unlinkFile(archivePath);
        } catch (error) {
          core.debug(`Failed to delete archive: ${error}`);
        }
      }
      return cacheEntry.cacheKey;
    });
  }
  __name(restoreCache2, "restoreCache");
  exports2.restoreCache = restoreCache2;
  function saveCache2(paths, key, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      checkPaths(paths), checkKey(key);
      let compressionMethod = yield utils6.getCompressionMethod();
      core.debug("Reserving Cache");
      let cacheId = yield cacheHttpClient.reserveCache(key, paths, {
        compressionMethod
      });
      if (cacheId === -1)
        throw new ReserveCacheError2(`Unable to reserve cache with key ${key}, another job may be creating this cache.`);
      core.debug(`Cache ID: ${cacheId}`);
      let cachePaths = yield utils6.resolvePaths(paths);
      core.debug("Cache Paths:"), core.debug(`${JSON.stringify(cachePaths)}`);
      let archiveFolder = yield utils6.createTempDirectory(), archivePath = path3.join(archiveFolder, utils6.getCacheFileName(compressionMethod));
      core.debug(`Archive Path: ${archivePath}`), yield tar_1.createTar(archiveFolder, cachePaths, compressionMethod);
      let fileSizeLimit = 5 * 1024 * 1024 * 1024, archiveFileSize = utils6.getArchiveFileSizeIsBytes(archivePath);
      if (core.debug(`File Size: ${archiveFileSize}`), archiveFileSize > fileSizeLimit)
        throw new Error(`Cache size of ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B) is over the 5GB limit, not saving cache.`);
      return core.debug(`Saving Cache (ID: ${cacheId})`), yield cacheHttpClient.saveCache(cacheId, archivePath, options), cacheId;
    });
  }
  __name(saveCache2, "saveCache");
  exports2.saveCache = saveCache2;
});

// ../node_modules/@azure/core-http/es/src/httpHeaders.js
function getHeaderKey(headerName) {
  return headerName.toLowerCase();
}
__name(getHeaderKey, "getHeaderKey");
function isHttpHeadersLike(object) {
  if (object && typeof object == "object") {
    var castObject = object;
    if (typeof castObject.rawHeaders == "function" && typeof castObject.clone == "function" && typeof castObject.get == "function" && typeof castObject.set == "function" && typeof castObject.contains == "function" && typeof castObject.remove == "function" && typeof castObject.headersArray == "function" && typeof castObject.headerValues == "function" && typeof castObject.headerNames == "function" && typeof castObject.toJson == "function")
      return !0;
  }
  return !1;
}
__name(isHttpHeadersLike, "isHttpHeadersLike");
var HttpHeaders = function() {
  function HttpHeaders2(rawHeaders) {
    if (this._headersMap = {}, rawHeaders)
      for (var headerName in rawHeaders)
        this.set(headerName, rawHeaders[headerName]);
  }
  return __name(HttpHeaders2, "HttpHeaders"), HttpHeaders2.prototype.set = function(headerName, headerValue) {
    this._headersMap[getHeaderKey(headerName)] = {
      name: headerName,
      value: headerValue.toString()
    };
  }, HttpHeaders2.prototype.get = function(headerName) {
    var header = this._headersMap[getHeaderKey(headerName)];
    return header ? header.value : void 0;
  }, HttpHeaders2.prototype.contains = function(headerName) {
    return !!this._headersMap[getHeaderKey(headerName)];
  }, HttpHeaders2.prototype.remove = function(headerName) {
    var result = this.contains(headerName);
    return delete this._headersMap[getHeaderKey(headerName)], result;
  }, HttpHeaders2.prototype.rawHeaders = function() {
    var result = {};
    for (var headerKey in this._headersMap) {
      var header = this._headersMap[headerKey];
      result[header.name.toLowerCase()] = header.value;
    }
    return result;
  }, HttpHeaders2.prototype.headersArray = function() {
    var headers = [];
    for (var headerKey in this._headersMap)
      headers.push(this._headersMap[headerKey]);
    return headers;
  }, HttpHeaders2.prototype.headerNames = function() {
    for (var headerNames = [], headers = this.headersArray(), i = 0; i < headers.length; ++i)
      headerNames.push(headers[i].name);
    return headerNames;
  }, HttpHeaders2.prototype.headerValues = function() {
    for (var headerValues = [], headers = this.headersArray(), i = 0; i < headers.length; ++i)
      headerValues.push(headers[i].value);
    return headerValues;
  }, HttpHeaders2.prototype.toJson = function() {
    return this.rawHeaders();
  }, HttpHeaders2.prototype.toString = function() {
    return JSON.stringify(this.toJson());
  }, HttpHeaders2.prototype.clone = function() {
    return new HttpHeaders2(this.rawHeaders());
  }, HttpHeaders2;
}();

// ../node_modules/tslib/tslib.es6.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = /* @__PURE__ */ __name(function(d, b) {
  return extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      Object.prototype.hasOwnProperty.call(b2, p) && (d2[p] = b2[p]);
  }, extendStatics(d, b);
}, "extendStatics");
function __extends(d, b) {
  if (typeof b != "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  __name(__, "__"), d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
__name(__extends, "__extends");
var __assign = /* @__PURE__ */ __name(function() {
  return __assign = Object.assign || /* @__PURE__ */ __name(function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
    }
    return t;
  }, "__assign"), __assign.apply(this, arguments);
}, "__assign");
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return __name(adopt, "adopt"), new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step"), step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
__name(__awaiter, "__awaiter");
function __generator(thisArg, body) {
  var _ = {label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: []}, f, y, t, g;
  return g = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    for (; _; )
      try {
        if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        switch (y = 0, t && (op = [op[0] & 2, t.value]), op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            return _.label++, {value: op[1], done: !1};
          case 5:
            _.label++, y = op[1], op = [0];
            continue;
          case 7:
            op = _.ops.pop(), _.trys.pop();
            continue;
          default:
            if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1], t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2], _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop(), _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e], y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {value: op[0] ? op[1] : void 0, done: !0};
  }
}
__name(__generator, "__generator");
function __values2(o) {
  var s = typeof Symbol == "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
__name(__values2, "__values");
function __read(o, n) {
  var m = typeof Symbol == "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    for (; (n === void 0 || n-- > 0) && !(r = i.next()).done; )
      ar.push(r.value);
  } catch (error) {
    e = {error};
  } finally {
    try {
      r && !r.done && (m = i.return) && m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
__name(__read, "__read");
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
__name(__spread, "__spread");
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
__name(__spreadArrays, "__spreadArrays");
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
__name(__await, "__await");
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    g[n] && (i[n] = function(v) {
      return new Promise(function(a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    });
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    f(v), q.shift(), q.length && resume(q[0][0], q[0][1]);
  }
}
__name(__asyncGenerator, "__asyncGenerator");
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? {value: __await(o[n](v)), done: n === "return"} : f ? f(v) : v;
    } : f;
  }
}
__name(__asyncDelegator, "__asyncDelegator");
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values2 == "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({value: v2, done: d});
    }, reject);
  }
}
__name(__asyncValues, "__asyncValues");

// ../node_modules/@azure/core-http/es/src/util/base64.js
function encodeByteArray(value) {
  var bufferValue = value instanceof Buffer ? value : Buffer.from(value.buffer);
  return bufferValue.toString("base64");
}
__name(encodeByteArray, "encodeByteArray");
function decodeString(value) {
  return Buffer.from(value, "base64");
}
__name(decodeString, "decodeString");

// ../node_modules/@azure/core-http/node_modules/uuid/dist/esm-node/rng.js
var import_crypto = __toModule(require("crypto")), rnds8Pool = new Uint8Array(256), poolPtr = rnds8Pool.length;
function rng() {
  return poolPtr > rnds8Pool.length - 16 && (import_crypto.default.randomFillSync(rnds8Pool), poolPtr = 0), rnds8Pool.slice(poolPtr, poolPtr += 16);
}
__name(rng, "rng");

// ../node_modules/@azure/core-http/node_modules/uuid/dist/esm-node/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// ../node_modules/@azure/core-http/node_modules/uuid/dist/esm-node/validate.js
function validate(uuid) {
  return typeof uuid == "string" && regex_default.test(uuid);
}
__name(validate, "validate");
var validate_default = validate;

// ../node_modules/@azure/core-http/node_modules/uuid/dist/esm-node/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i)
  byteToHex.push((i + 256).toString(16).substr(1));
function stringify(arr, offset = 0) {
  let uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid))
    throw TypeError("Stringified UUID is invalid");
  return uuid;
}
__name(stringify, "stringify");
var stringify_default = stringify;

// ../node_modules/@azure/core-http/node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  options = options || {};
  let rnds = options.random || (options.rng || rng)();
  if (rnds[6] = rnds[6] & 15 | 64, rnds[8] = rnds[8] & 63 | 128, buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i)
      buf[offset + i] = rnds[i];
    return buf;
  }
  return stringify_default(rnds);
}
__name(v4, "v4");
var v4_default = v4;

// ../node_modules/@azure/core-http/es/src/util/constants.js
var Constants = {
  coreHttpVersion: "1.2.1",
  HTTP: "http:",
  HTTPS: "https:",
  HTTP_PROXY: "HTTP_PROXY",
  HTTPS_PROXY: "HTTPS_PROXY",
  NO_PROXY: "NO_PROXY",
  ALL_PROXY: "ALL_PROXY",
  HttpConstants: {
    HttpVerbs: {
      PUT: "PUT",
      GET: "GET",
      DELETE: "DELETE",
      POST: "POST",
      MERGE: "MERGE",
      HEAD: "HEAD",
      PATCH: "PATCH"
    },
    StatusCodes: {
      TooManyRequests: 429
    }
  },
  HeaderConstants: {
    AUTHORIZATION: "authorization",
    AUTHORIZATION_SCHEME: "Bearer",
    RETRY_AFTER: "Retry-After",
    USER_AGENT: "User-Agent"
  }
};

// ../node_modules/@azure/core-http/es/src/util/serializer.common.js
var XML_ATTRKEY = "$", XML_CHARKEY = "_";

// ../node_modules/@azure/core-http/es/src/util/utils.js
var validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i, isNode = typeof process != "undefined" && !!process.version && !!process.versions && !!process.versions.node;
function isValidUuid(uuid) {
  return validUuidRegex.test(uuid);
}
__name(isValidUuid, "isValidUuid");
function generateUuid() {
  return v4_default();
}
__name(generateUuid, "generateUuid");
function delay(t, value) {
  return new Promise(function(resolve) {
    return setTimeout(function() {
      return resolve(value);
    }, t);
  });
}
__name(delay, "delay");
function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
  var _a, _b, _c;
  if (Array.isArray(obj) || (obj = [obj]), !xmlNamespaceKey || !xmlNamespace)
    return _a = {}, _a[elementName] = obj, _a;
  var result = (_b = {}, _b[elementName] = obj, _b);
  return result[XML_ATTRKEY] = (_c = {}, _c[xmlNamespaceKey] = xmlNamespace, _c), result;
}
__name(prepareXMLRootList, "prepareXMLRootList");
var validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function isDuration(value) {
  return validateISODuration.test(value);
}
__name(isDuration, "isDuration");
function replaceAll(value, searchValue, replaceValue) {
  return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || "");
}
__name(replaceAll, "replaceAll");
function isPrimitiveType(value) {
  return typeof value != "object" && typeof value != "function" || value === null;
}
__name(isPrimitiveType, "isPrimitiveType");
function getEnvironmentValue(name) {
  if (process.env[name])
    return process.env[name];
  if (process.env[name.toLowerCase()])
    return process.env[name.toLowerCase()];
}
__name(getEnvironmentValue, "getEnvironmentValue");

// ../node_modules/@azure/core-http/es/src/serializer.js
var Serializer = function() {
  function Serializer2(modelMappers, isXML) {
    modelMappers === void 0 && (modelMappers = {}), this.modelMappers = modelMappers, this.isXML = isXML;
  }
  return __name(Serializer2, "Serializer"), Serializer2.prototype.validateConstraints = function(mapper, value, objectName) {
    var failValidation = /* @__PURE__ */ __name(function(constraintName, constraintValue) {
      throw new Error('"' + objectName + '" with value "' + value + '" should satisfy the constraint "' + constraintName + '": ' + constraintValue + ".");
    }, "failValidation");
    if (mapper.constraints && value != null) {
      var valueAsNumber = value, _a = mapper.constraints, ExclusiveMaximum = _a.ExclusiveMaximum, ExclusiveMinimum = _a.ExclusiveMinimum, InclusiveMaximum = _a.InclusiveMaximum, InclusiveMinimum = _a.InclusiveMinimum, MaxItems = _a.MaxItems, MaxLength = _a.MaxLength, MinItems = _a.MinItems, MinLength = _a.MinLength, MultipleOf = _a.MultipleOf, Pattern = _a.Pattern, UniqueItems = _a.UniqueItems;
      ExclusiveMaximum != null && valueAsNumber >= ExclusiveMaximum && failValidation("ExclusiveMaximum", ExclusiveMaximum), ExclusiveMinimum != null && valueAsNumber <= ExclusiveMinimum && failValidation("ExclusiveMinimum", ExclusiveMinimum), InclusiveMaximum != null && valueAsNumber > InclusiveMaximum && failValidation("InclusiveMaximum", InclusiveMaximum), InclusiveMinimum != null && valueAsNumber < InclusiveMinimum && failValidation("InclusiveMinimum", InclusiveMinimum);
      var valueAsArray = value;
      if (MaxItems != null && valueAsArray.length > MaxItems && failValidation("MaxItems", MaxItems), MaxLength != null && valueAsArray.length > MaxLength && failValidation("MaxLength", MaxLength), MinItems != null && valueAsArray.length < MinItems && failValidation("MinItems", MinItems), MinLength != null && valueAsArray.length < MinLength && failValidation("MinLength", MinLength), MultipleOf != null && valueAsNumber % MultipleOf != 0 && failValidation("MultipleOf", MultipleOf), Pattern) {
        var pattern = typeof Pattern == "string" ? new RegExp(Pattern) : Pattern;
        (typeof value != "string" || value.match(pattern) === null) && failValidation("Pattern", Pattern);
      }
      UniqueItems && valueAsArray.some(function(item, i, ar) {
        return ar.indexOf(item) !== i;
      }) && failValidation("UniqueItems", UniqueItems);
    }
  }, Serializer2.prototype.serialize = function(mapper, object, objectName, options) {
    var _a, _b, _c;
    options === void 0 && (options = {});
    var updatedOptions = {
      rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : "",
      includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : !1,
      xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY
    }, payload = {}, mapperType = mapper.type.name;
    objectName || (objectName = mapper.serializedName), mapperType.match(/^Sequence$/i) !== null && (payload = []), mapper.isConstant && (object = mapper.defaultValue);
    var required = mapper.required, nullable = mapper.nullable;
    if (required && nullable && object === void 0)
      throw new Error(objectName + " cannot be undefined.");
    if (required && !nullable && object == null)
      throw new Error(objectName + " cannot be null or undefined.");
    if (!required && nullable === !1 && object === null)
      throw new Error(objectName + " cannot be null.");
    if (object == null)
      payload = object;
    else if (this.validateConstraints(mapper, object, objectName), mapperType.match(/^any$/i) !== null)
      payload = object;
    else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null)
      payload = serializeBasicTypes(mapperType, objectName, object);
    else if (mapperType.match(/^Enum$/i) !== null) {
      var enumMapper = mapper;
      payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);
    } else
      mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null ? payload = serializeDateTypes(mapperType, object, objectName) : mapperType.match(/^ByteArray$/i) !== null ? payload = serializeByteArrayType(objectName, object) : mapperType.match(/^Base64Url$/i) !== null ? payload = serializeBase64UrlType(objectName, object) : mapperType.match(/^Sequence$/i) !== null ? payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions) : mapperType.match(/^Dictionary$/i) !== null ? payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions) : mapperType.match(/^Composite$/i) !== null && (payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions));
    return payload;
  }, Serializer2.prototype.deserialize = function(mapper, responseBody, objectName, options) {
    var _a, _b, _c;
    options === void 0 && (options = {});
    var updatedOptions = {
      rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : "",
      includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : !1,
      xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY
    };
    if (responseBody == null)
      return this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped && (responseBody = []), mapper.defaultValue !== void 0 && (responseBody = mapper.defaultValue), responseBody;
    var payload, mapperType = mapper.type.name;
    if (objectName || (objectName = mapper.serializedName), mapperType.match(/^Composite$/i) !== null)
      payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
    else {
      if (this.isXML) {
        var xmlCharKey = updatedOptions.xmlCharKey, castResponseBody = responseBody;
        castResponseBody[XML_ATTRKEY] != null && castResponseBody[xmlCharKey] != null && (responseBody = castResponseBody[xmlCharKey]);
      }
      mapperType.match(/^Number$/i) !== null ? (payload = parseFloat(responseBody), isNaN(payload) && (payload = responseBody)) : mapperType.match(/^Boolean$/i) !== null ? responseBody === "true" ? payload = !0 : responseBody === "false" ? payload = !1 : payload = responseBody : mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null ? payload = responseBody : mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null ? payload = new Date(responseBody) : mapperType.match(/^UnixTime$/i) !== null ? payload = unixTimeToDate(responseBody) : mapperType.match(/^ByteArray$/i) !== null ? payload = decodeString(responseBody) : mapperType.match(/^Base64Url$/i) !== null ? payload = base64UrlToByteArray(responseBody) : mapperType.match(/^Sequence$/i) !== null ? payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions) : mapperType.match(/^Dictionary$/i) !== null && (payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions));
    }
    return mapper.isConstant && (payload = mapper.defaultValue), payload;
  }, Serializer2;
}();
function trimEnd(str, ch) {
  for (var len = str.length; len - 1 >= 0 && str[len - 1] === ch; )
    --len;
  return str.substr(0, len);
}
__name(trimEnd, "trimEnd");
function bufferToBase64Url(buffer) {
  if (!!buffer) {
    if (!(buffer instanceof Uint8Array))
      throw new Error("Please provide an input of type Uint8Array for converting to Base64Url.");
    var str = encodeByteArray(buffer);
    return trimEnd(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
  }
}
__name(bufferToBase64Url, "bufferToBase64Url");
function base64UrlToByteArray(str) {
  if (!!str) {
    if (str && typeof str.valueOf() != "string")
      throw new Error("Please provide an input of type string for converting to Uint8Array");
    return str = str.replace(/-/g, "+").replace(/_/g, "/"), decodeString(str);
  }
}
__name(base64UrlToByteArray, "base64UrlToByteArray");
function splitSerializeName(prop) {
  var classes = [], partialclass = "";
  if (prop)
    for (var subwords = prop.split("."), _i = 0, subwords_1 = subwords; _i < subwords_1.length; _i++) {
      var item = subwords_1[_i];
      item.charAt(item.length - 1) === "\\" ? partialclass += item.substr(0, item.length - 1) + "." : (partialclass += item, classes.push(partialclass), partialclass = "");
    }
  return classes;
}
__name(splitSerializeName, "splitSerializeName");
function dateToUnixTime(d) {
  if (!!d)
    return typeof d.valueOf() == "string" && (d = new Date(d)), Math.floor(d.getTime() / 1e3);
}
__name(dateToUnixTime, "dateToUnixTime");
function unixTimeToDate(n) {
  if (!!n)
    return new Date(n * 1e3);
}
__name(unixTimeToDate, "unixTimeToDate");
function serializeBasicTypes(typeName, objectName, value) {
  if (value != null) {
    if (typeName.match(/^Number$/i) !== null) {
      if (typeof value != "number")
        throw new Error(objectName + " with value " + value + " must be of type number.");
    } else if (typeName.match(/^String$/i) !== null) {
      if (typeof value.valueOf() != "string")
        throw new Error(objectName + ' with value "' + value + '" must be of type string.');
    } else if (typeName.match(/^Uuid$/i) !== null) {
      if (!(typeof value.valueOf() == "string" && isValidUuid(value)))
        throw new Error(objectName + ' with value "' + value + '" must be of type string and a valid uuid.');
    } else if (typeName.match(/^Boolean$/i) !== null) {
      if (typeof value != "boolean")
        throw new Error(objectName + " with value " + value + " must be of type boolean.");
    } else if (typeName.match(/^Stream$/i) !== null) {
      var objectType = typeof value;
      if (objectType !== "string" && objectType !== "function" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && !((typeof Blob == "function" || typeof Blob == "object") && value instanceof Blob))
        throw new Error(objectName + " must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.");
    }
  }
  return value;
}
__name(serializeBasicTypes, "serializeBasicTypes");
function serializeEnumType(objectName, allowedValues, value) {
  if (!allowedValues)
    throw new Error("Please provide a set of allowedValues to validate " + objectName + " as an Enum Type.");
  var isPresent = allowedValues.some(function(item) {
    return typeof item.valueOf() == "string" ? item.toLowerCase() === value.toLowerCase() : item === value;
  });
  if (!isPresent)
    throw new Error(value + " is not a valid value for " + objectName + ". The valid values are: " + JSON.stringify(allowedValues) + ".");
  return value;
}
__name(serializeEnumType, "serializeEnumType");
function serializeByteArrayType(objectName, value) {
  var returnValue = "";
  if (value != null) {
    if (!(value instanceof Uint8Array))
      throw new Error(objectName + " must be of type Uint8Array.");
    returnValue = encodeByteArray(value);
  }
  return returnValue;
}
__name(serializeByteArrayType, "serializeByteArrayType");
function serializeBase64UrlType(objectName, value) {
  var returnValue = "";
  if (value != null) {
    if (!(value instanceof Uint8Array))
      throw new Error(objectName + " must be of type Uint8Array.");
    returnValue = bufferToBase64Url(value) || "";
  }
  return returnValue;
}
__name(serializeBase64UrlType, "serializeBase64UrlType");
function serializeDateTypes(typeName, value, objectName) {
  if (value != null) {
    if (typeName.match(/^Date$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() == "string" && !isNaN(Date.parse(value))))
        throw new Error(objectName + " must be an instanceof Date or a string in ISO8601 format.");
      value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);
    } else if (typeName.match(/^DateTime$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() == "string" && !isNaN(Date.parse(value))))
        throw new Error(objectName + " must be an instanceof Date or a string in ISO8601 format.");
      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
    } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() == "string" && !isNaN(Date.parse(value))))
        throw new Error(objectName + " must be an instanceof Date or a string in RFC-1123 format.");
      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
    } else if (typeName.match(/^UnixTime$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() == "string" && !isNaN(Date.parse(value))))
        throw new Error(objectName + " must be an instanceof Date or a string in RFC-1123/ISO8601 format for it to be serialized in UnixTime/Epoch format.");
      value = dateToUnixTime(value);
    } else if (typeName.match(/^TimeSpan$/i) !== null && !isDuration(value))
      throw new Error(objectName + ' must be a string in ISO 8601 format. Instead was "' + value + '".');
  }
  return value;
}
__name(serializeDateTypes, "serializeDateTypes");
function serializeSequenceType(serializer7, mapper, object, objectName, isXml, options) {
  var _a, _b;
  if (!Array.isArray(object))
    throw new Error(objectName + " must be of type Array.");
  var elementType = mapper.type.element;
  if (!elementType || typeof elementType != "object")
    throw new Error('element" metadata for an Array must be defined in the ' + ('mapper and it must of type "object" in ' + objectName + "."));
  for (var tempArray = [], i = 0; i < object.length; i++) {
    var serializedValue = serializer7.serialize(elementType, object[i], objectName, options);
    if (isXml && elementType.xmlNamespace) {
      var xmlnsKey = elementType.xmlNamespacePrefix ? "xmlns:" + elementType.xmlNamespacePrefix : "xmlns";
      elementType.type.name === "Composite" ? (tempArray[i] = __assign({}, serializedValue), tempArray[i][XML_ATTRKEY] = (_a = {}, _a[xmlnsKey] = elementType.xmlNamespace, _a)) : (tempArray[i] = {}, tempArray[i][options.xmlCharKey] = serializedValue, tempArray[i][XML_ATTRKEY] = (_b = {}, _b[xmlnsKey] = elementType.xmlNamespace, _b));
    } else
      tempArray[i] = serializedValue;
  }
  return tempArray;
}
__name(serializeSequenceType, "serializeSequenceType");
function serializeDictionaryType(serializer7, mapper, object, objectName, isXml, options) {
  var _a;
  if (typeof object != "object")
    throw new Error(objectName + " must be of type object.");
  var valueType = mapper.type.value;
  if (!valueType || typeof valueType != "object")
    throw new Error('"value" metadata for a Dictionary must be defined in the ' + ('mapper and it must of type "object" in ' + objectName + "."));
  for (var tempDictionary = {}, _i = 0, _b = Object.keys(object); _i < _b.length; _i++) {
    var key = _b[_i], serializedValue = serializer7.serialize(valueType, object[key], objectName, options);
    tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);
  }
  if (isXml && mapper.xmlNamespace) {
    var xmlnsKey = mapper.xmlNamespacePrefix ? "xmlns:" + mapper.xmlNamespacePrefix : "xmlns", result = tempDictionary;
    return result[XML_ATTRKEY] = (_a = {}, _a[xmlnsKey] = mapper.xmlNamespace, _a), result;
  }
  return tempDictionary;
}
__name(serializeDictionaryType, "serializeDictionaryType");
function resolveAdditionalProperties(serializer7, mapper, objectName) {
  var additionalProperties = mapper.type.additionalProperties;
  if (!additionalProperties && mapper.type.className) {
    var modelMapper = resolveReferencedMapper(serializer7, mapper, objectName);
    return modelMapper == null ? void 0 : modelMapper.type.additionalProperties;
  }
  return additionalProperties;
}
__name(resolveAdditionalProperties, "resolveAdditionalProperties");
function resolveReferencedMapper(serializer7, mapper, objectName) {
  var className = mapper.type.className;
  if (!className)
    throw new Error('Class name for model "' + objectName + '" is not provided in the mapper "' + JSON.stringify(mapper, void 0, 2) + '".');
  return serializer7.modelMappers[className];
}
__name(resolveReferencedMapper, "resolveReferencedMapper");
function resolveModelProperties(serializer7, mapper, objectName) {
  var modelProps = mapper.type.modelProperties;
  if (!modelProps) {
    var modelMapper = resolveReferencedMapper(serializer7, mapper, objectName);
    if (!modelMapper)
      throw new Error('mapper() cannot be null or undefined for model "' + mapper.type.className + '".');
    if (modelProps = modelMapper == null ? void 0 : modelMapper.type.modelProperties, !modelProps)
      throw new Error("modelProperties cannot be null or undefined in the " + ('mapper "' + JSON.stringify(modelMapper) + '" of type "' + mapper.type.className + '" for object "' + objectName + '".'));
  }
  return modelProps;
}
__name(resolveModelProperties, "resolveModelProperties");
function serializeCompositeType(serializer7, mapper, object, objectName, isXml, options) {
  var _a, _b;
  if (getPolymorphicDiscriminatorRecursively(serializer7, mapper) && (mapper = getPolymorphicMapper(serializer7, mapper, object, "clientName")), object != null) {
    for (var payload = {}, modelProps = resolveModelProperties(serializer7, mapper, objectName), _i = 0, _c = Object.keys(modelProps); _i < _c.length; _i++) {
      var key = _c[_i], propertyMapper = modelProps[key];
      if (!propertyMapper.readOnly) {
        var propName = void 0, parentObject = payload;
        if (serializer7.isXML)
          propertyMapper.xmlIsWrapped ? propName = propertyMapper.xmlName : propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
        else {
          var paths = splitSerializeName(propertyMapper.serializedName);
          propName = paths.pop();
          for (var _d = 0, paths_1 = paths; _d < paths_1.length; _d++) {
            var pathName = paths_1[_d], childObject = parentObject[pathName];
            childObject == null && (object[key] != null || propertyMapper.defaultValue !== void 0) && (parentObject[pathName] = {}), parentObject = parentObject[pathName];
          }
        }
        if (parentObject != null) {
          if (isXml && mapper.xmlNamespace) {
            var xmlnsKey = mapper.xmlNamespacePrefix ? "xmlns:" + mapper.xmlNamespacePrefix : "xmlns";
            parentObject[XML_ATTRKEY] = __assign(__assign({}, parentObject[XML_ATTRKEY]), (_a = {}, _a[xmlnsKey] = mapper.xmlNamespace, _a));
          }
          var propertyObjectName = propertyMapper.serializedName !== "" ? objectName + "." + propertyMapper.serializedName : objectName, toSerialize = object[key], polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer7, mapper);
          polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && toSerialize == null && (toSerialize = mapper.serializedName);
          var serializedValue = serializer7.serialize(propertyMapper, toSerialize, propertyObjectName, options);
          if (serializedValue !== void 0 && propName != null) {
            var value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);
            isXml && propertyMapper.xmlIsAttribute ? (parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {}, parentObject[XML_ATTRKEY][propName] = serializedValue) : isXml && propertyMapper.xmlIsWrapped ? parentObject[propName] = (_b = {}, _b[propertyMapper.xmlElementName] = value, _b) : parentObject[propName] = value;
          }
        }
      }
    }
    var additionalPropertiesMapper = resolveAdditionalProperties(serializer7, mapper, objectName);
    if (additionalPropertiesMapper) {
      var propNames = Object.keys(modelProps), _loop_1 = /* @__PURE__ */ __name(function(clientPropName2) {
        var isAdditionalProperty = propNames.every(function(pn) {
          return pn !== clientPropName2;
        });
        isAdditionalProperty && (payload[clientPropName2] = serializer7.serialize(additionalPropertiesMapper, object[clientPropName2], objectName + '["' + clientPropName2 + '"]', options));
      }, "_loop_1");
      for (var clientPropName in object)
        _loop_1(clientPropName);
    }
    return payload;
  }
  return object;
}
__name(serializeCompositeType, "serializeCompositeType");
function getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {
  var _a;
  if (!isXml || !propertyMapper.xmlNamespace)
    return serializedValue;
  var xmlnsKey = propertyMapper.xmlNamespacePrefix ? "xmlns:" + propertyMapper.xmlNamespacePrefix : "xmlns", xmlNamespace = (_a = {}, _a[xmlnsKey] = propertyMapper.xmlNamespace, _a);
  if (["Composite"].includes(propertyMapper.type.name)) {
    if (serializedValue[XML_ATTRKEY])
      return serializedValue;
    var result_1 = __assign({}, serializedValue);
    return result_1[XML_ATTRKEY] = xmlNamespace, result_1;
  }
  var result = {};
  return result[options.xmlCharKey] = serializedValue, result[XML_ATTRKEY] = xmlNamespace, result;
}
__name(getXmlObjectValue, "getXmlObjectValue");
function isSpecialXmlProperty(propertyName, options) {
  return [XML_ATTRKEY, options.xmlCharKey].includes(propertyName);
}
__name(isSpecialXmlProperty, "isSpecialXmlProperty");
function deserializeCompositeType(serializer7, mapper, responseBody, objectName, options) {
  var _a;
  getPolymorphicDiscriminatorRecursively(serializer7, mapper) && (mapper = getPolymorphicMapper(serializer7, mapper, responseBody, "serializedName"));
  for (var modelProps = resolveModelProperties(serializer7, mapper, objectName), instance = {}, handledPropertyNames = [], _i = 0, _b = Object.keys(modelProps); _i < _b.length; _i++) {
    var key = _b[_i], propertyMapper = modelProps[key], paths = splitSerializeName(modelProps[key].serializedName);
    handledPropertyNames.push(paths[0]);
    var serializedName = propertyMapper.serializedName, xmlName = propertyMapper.xmlName, xmlElementName = propertyMapper.xmlElementName, propertyObjectName = objectName;
    serializedName !== "" && serializedName !== void 0 && (propertyObjectName = objectName + "." + serializedName);
    var headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
    if (headerCollectionPrefix) {
      for (var dictionary = {}, _c = 0, _d = Object.keys(responseBody); _c < _d.length; _c++) {
        var headerKey = _d[_c];
        headerKey.startsWith(headerCollectionPrefix) && (dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer7.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options)), handledPropertyNames.push(headerKey);
      }
      instance[key] = dictionary;
    } else if (serializer7.isXML)
      if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY])
        instance[key] = serializer7.deserialize(propertyMapper, responseBody[XML_ATTRKEY][xmlName], propertyObjectName, options);
      else {
        var propertyName = xmlElementName || xmlName || serializedName;
        if (propertyMapper.xmlIsWrapped) {
          var wrapped = responseBody[xmlName], elementList = (_a = wrapped == null ? void 0 : wrapped[xmlElementName]) !== null && _a !== void 0 ? _a : [];
          instance[key] = serializer7.deserialize(propertyMapper, elementList, propertyObjectName, options);
        } else {
          var property = responseBody[propertyName];
          instance[key] = serializer7.deserialize(propertyMapper, property, propertyObjectName, options);
        }
      }
    else {
      for (var propertyInstance = void 0, res = responseBody, _e = 0, paths_2 = paths; _e < paths_2.length; _e++) {
        var item = paths_2[_e];
        if (!res)
          break;
        res = res[item];
      }
      propertyInstance = res;
      var polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
      polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && propertyInstance == null && (propertyInstance = mapper.serializedName);
      var serializedValue = void 0;
      Array.isArray(responseBody[key]) && modelProps[key].serializedName === "" ? (propertyInstance = responseBody[key], instance = serializer7.deserialize(propertyMapper, propertyInstance, propertyObjectName, options)) : (propertyInstance !== void 0 || propertyMapper.defaultValue !== void 0) && (serializedValue = serializer7.deserialize(propertyMapper, propertyInstance, propertyObjectName, options), instance[key] = serializedValue);
    }
  }
  var additionalPropertiesMapper = mapper.type.additionalProperties;
  if (additionalPropertiesMapper) {
    var isAdditionalProperty = /* @__PURE__ */ __name(function(responsePropName2) {
      for (var clientPropName in modelProps) {
        var paths2 = splitSerializeName(modelProps[clientPropName].serializedName);
        if (paths2[0] === responsePropName2)
          return !1;
      }
      return !0;
    }, "isAdditionalProperty");
    for (var responsePropName in responseBody)
      isAdditionalProperty(responsePropName) && (instance[responsePropName] = serializer7.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options));
  } else if (responseBody)
    for (var _f = 0, _g = Object.keys(responseBody); _f < _g.length; _f++) {
      var key = _g[_f];
      instance[key] === void 0 && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key, options) && (instance[key] = responseBody[key]);
    }
  return instance;
}
__name(deserializeCompositeType, "deserializeCompositeType");
function deserializeDictionaryType(serializer7, mapper, responseBody, objectName, options) {
  var value = mapper.type.value;
  if (!value || typeof value != "object")
    throw new Error('"value" metadata for a Dictionary must be defined in the ' + ('mapper and it must of type "object" in ' + objectName));
  if (responseBody) {
    for (var tempDictionary = {}, _i = 0, _a = Object.keys(responseBody); _i < _a.length; _i++) {
      var key = _a[_i];
      tempDictionary[key] = serializer7.deserialize(value, responseBody[key], objectName, options);
    }
    return tempDictionary;
  }
  return responseBody;
}
__name(deserializeDictionaryType, "deserializeDictionaryType");
function deserializeSequenceType(serializer7, mapper, responseBody, objectName, options) {
  var element = mapper.type.element;
  if (!element || typeof element != "object")
    throw new Error('element" metadata for an Array must be defined in the ' + ('mapper and it must of type "object" in ' + objectName));
  if (responseBody) {
    Array.isArray(responseBody) || (responseBody = [responseBody]);
    for (var tempArray = [], i = 0; i < responseBody.length; i++)
      tempArray[i] = serializer7.deserialize(element, responseBody[i], objectName + "[" + i + "]", options);
    return tempArray;
  }
  return responseBody;
}
__name(deserializeSequenceType, "deserializeSequenceType");
function getPolymorphicMapper(serializer7, mapper, object, polymorphicPropertyName) {
  var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer7, mapper);
  if (polymorphicDiscriminator) {
    var discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
    if (discriminatorName != null) {
      var discriminatorValue = object[discriminatorName];
      if (discriminatorValue != null) {
        var typeName = mapper.type.uberParent || mapper.type.className, indexDiscriminator = discriminatorValue === typeName ? discriminatorValue : typeName + "." + discriminatorValue, polymorphicMapper = serializer7.modelMappers.discriminators[indexDiscriminator];
        polymorphicMapper && (mapper = polymorphicMapper);
      }
    }
  }
  return mapper;
}
__name(getPolymorphicMapper, "getPolymorphicMapper");
function getPolymorphicDiscriminatorRecursively(serializer7, mapper) {
  return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer7, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer7, mapper.type.className);
}
__name(getPolymorphicDiscriminatorRecursively, "getPolymorphicDiscriminatorRecursively");
function getPolymorphicDiscriminatorSafely(serializer7, typeName) {
  return typeName && serializer7.modelMappers[typeName] && serializer7.modelMappers[typeName].type.polymorphicDiscriminator;
}
__name(getPolymorphicDiscriminatorSafely, "getPolymorphicDiscriminatorSafely");
function strEnum(o) {
  for (var result = {}, _i = 0, o_1 = o; _i < o_1.length; _i++) {
    var key = o_1[_i];
    result[key] = key;
  }
  return result;
}
__name(strEnum, "strEnum");
var MapperType = strEnum([
  "Base64Url",
  "Boolean",
  "ByteArray",
  "Composite",
  "Date",
  "DateTime",
  "DateTimeRfc1123",
  "Dictionary",
  "Enum",
  "Number",
  "Object",
  "Sequence",
  "String",
  "Stream",
  "TimeSpan",
  "UnixTime"
]);

// ../node_modules/@azure/core-http/es/src/webResource.js
function isWebResourceLike(object) {
  if (object && typeof object == "object") {
    var castObject = object;
    if (typeof castObject.url == "string" && typeof castObject.method == "string" && typeof castObject.headers == "object" && isHttpHeadersLike(castObject.headers) && typeof castObject.validateRequestProperties == "function" && typeof castObject.prepare == "function" && typeof castObject.clone == "function")
      return !0;
  }
  return !1;
}
__name(isWebResourceLike, "isWebResourceLike");
var WebResource = function() {
  function WebResource2(url2, method, body, query, headers, streamResponseBody, withCredentials, abortSignal2, timeout, onUploadProgress, onDownloadProgress, proxySettings, keepAlive, decompressResponse) {
    this.streamResponseBody = streamResponseBody, this.url = url2 || "", this.method = method || "GET", this.headers = isHttpHeadersLike(headers) ? headers : new HttpHeaders(headers), this.body = body, this.query = query, this.formData = void 0, this.withCredentials = withCredentials || !1, this.abortSignal = abortSignal2, this.timeout = timeout || 0, this.onUploadProgress = onUploadProgress, this.onDownloadProgress = onDownloadProgress, this.proxySettings = proxySettings, this.keepAlive = keepAlive, this.decompressResponse = decompressResponse, this.requestId = this.headers.get("x-ms-client-request-id") || generateUuid();
  }
  return __name(WebResource2, "WebResource"), WebResource2.prototype.validateRequestProperties = function() {
    if (!this.method)
      throw new Error("WebResource.method is required.");
    if (!this.url)
      throw new Error("WebResource.url is required.");
  }, WebResource2.prototype.prepare = function(options) {
    if (!options)
      throw new Error("options object is required");
    if (options.method === void 0 || options.method === null || typeof options.method.valueOf() != "string")
      throw new Error("options.method must be a string.");
    if (options.url && options.pathTemplate)
      throw new Error("options.url and options.pathTemplate are mutually exclusive. Please provide exactly one of them.");
    if ((options.pathTemplate === void 0 || options.pathTemplate === null || typeof options.pathTemplate.valueOf() != "string") && (options.url === void 0 || options.url === null || typeof options.url.valueOf() != "string"))
      throw new Error("Please provide exactly one of options.pathTemplate or options.url.");
    if (options.url) {
      if (typeof options.url != "string")
        throw new Error('options.url must be of type "string".');
      this.url = options.url;
    }
    if (options.method) {
      var validMethods = ["GET", "PUT", "HEAD", "DELETE", "OPTIONS", "POST", "PATCH", "TRACE"];
      if (validMethods.indexOf(options.method.toUpperCase()) === -1)
        throw new Error('The provided method "' + options.method + '" is invalid. Supported HTTP methods are: ' + JSON.stringify(validMethods));
    }
    if (this.method = options.method.toUpperCase(), options.pathTemplate) {
      var pathTemplate_1 = options.pathTemplate, pathParameters_1 = options.pathParameters;
      if (typeof pathTemplate_1 != "string")
        throw new Error('options.pathTemplate must be of type "string".');
      options.baseUrl || (options.baseUrl = "https://management.azure.com");
      var baseUrl = options.baseUrl, url_1 = baseUrl + (baseUrl.endsWith("/") ? "" : "/") + (pathTemplate_1.startsWith("/") ? pathTemplate_1.slice(1) : pathTemplate_1), segments = url_1.match(/({[\w-]*\s*[\w-]*})/gi);
      if (segments && segments.length) {
        if (!pathParameters_1)
          throw new Error("pathTemplate: " + pathTemplate_1 + " has been provided. Hence, options.pathParameters must also be provided.");
        segments.forEach(function(item) {
          var pathParamName = item.slice(1, -1), pathParam = pathParameters_1[pathParamName];
          if (pathParam == null || !(typeof pathParam == "string" || typeof pathParam == "object")) {
            var stringifiedPathParameters = JSON.stringify(pathParameters_1, void 0, 2);
            throw new Error("pathTemplate: " + pathTemplate_1 + " contains the path parameter " + pathParamName + (" however, it is not present in parameters: " + stringifiedPathParameters + ".") + ('The value of the path parameter can either be a "string" of the form { ' + pathParamName + ': "some sample value" } or ') + ('it can be an "object" of the form { "' + pathParamName + '": { value: "some sample value", skipUrlEncoding: true } }.'));
          }
          if (typeof pathParam.valueOf() == "string" && (url_1 = url_1.replace(item, encodeURIComponent(pathParam))), typeof pathParam.valueOf() == "object") {
            if (!pathParam.value)
              throw new Error("options.pathParameters[" + pathParamName + '] is of type "object" but it does not contain a "value" property.');
            pathParam.skipUrlEncoding ? url_1 = url_1.replace(item, pathParam.value) : url_1 = url_1.replace(item, encodeURIComponent(pathParam.value));
          }
        });
      }
      this.url = url_1;
    }
    if (options.queryParameters) {
      var queryParameters = options.queryParameters;
      if (typeof queryParameters != "object")
        throw new Error('options.queryParameters must be of type object. It should be a JSON object of "query-parameter-name" as the key and the "query-parameter-value" as the value. The "query-parameter-value" may be fo type "string" or an "object" of the form { value: "query-parameter-value", skipUrlEncoding: true }.');
      this.url && this.url.indexOf("?") === -1 && (this.url += "?");
      var queryParams = [];
      this.query = {};
      for (var queryParamName in queryParameters) {
        var queryParam = queryParameters[queryParamName];
        if (queryParam) {
          if (typeof queryParam == "string")
            queryParams.push(queryParamName + "=" + encodeURIComponent(queryParam)), this.query[queryParamName] = encodeURIComponent(queryParam);
          else if (typeof queryParam == "object") {
            if (!queryParam.value)
              throw new Error("options.queryParameters[" + queryParamName + '] is of type "object" but it does not contain a "value" property.');
            queryParam.skipUrlEncoding ? (queryParams.push(queryParamName + "=" + queryParam.value), this.query[queryParamName] = queryParam.value) : (queryParams.push(queryParamName + "=" + encodeURIComponent(queryParam.value)), this.query[queryParamName] = encodeURIComponent(queryParam.value));
          }
        }
      }
      this.url += queryParams.join("&");
    }
    if (options.headers)
      for (var headers = options.headers, _i = 0, _a = Object.keys(options.headers); _i < _a.length; _i++) {
        var headerName = _a[_i];
        this.headers.set(headerName, headers[headerName]);
      }
    return this.headers.get("accept-language") || this.headers.set("accept-language", "en-US"), !this.headers.get("x-ms-client-request-id") && !options.disableClientRequestId && this.headers.set("x-ms-client-request-id", this.requestId), this.headers.get("Content-Type") || this.headers.set("Content-Type", "application/json; charset=utf-8"), this.body = options.body, options.body !== void 0 && options.body !== null && (options.bodyIsStream ? (this.headers.get("Transfer-Encoding") || this.headers.set("Transfer-Encoding", "chunked"), this.headers.get("Content-Type") !== "application/octet-stream" && this.headers.set("Content-Type", "application/octet-stream")) : (options.serializationMapper && (this.body = new Serializer(options.mappers).serialize(options.serializationMapper, options.body, "requestBody")), options.disableJsonStringifyOnBody || (this.body = JSON.stringify(options.body)))), options.spanOptions && (this.spanOptions = options.spanOptions), this.abortSignal = options.abortSignal, this.onDownloadProgress = options.onDownloadProgress, this.onUploadProgress = options.onUploadProgress, this;
  }, WebResource2.prototype.clone = function() {
    var result = new WebResource2(this.url, this.method, this.body, this.query, this.headers && this.headers.clone(), this.streamResponseBody, this.withCredentials, this.abortSignal, this.timeout, this.onUploadProgress, this.onDownloadProgress, this.proxySettings, this.keepAlive, this.decompressResponse);
    return this.formData && (result.formData = this.formData), this.operationSpec && (result.operationSpec = this.operationSpec), this.shouldDeserialize && (result.shouldDeserialize = this.shouldDeserialize), this.operationResponseGetter && (result.operationResponseGetter = this.operationResponseGetter), result;
  }, WebResource2;
}();

// ../node_modules/@azure/core-http/es/src/nodeFetchHttpClient.js
var tough = __toModule(require_cookie()), http2 = __toModule(require("http")), https2 = __toModule(require("https"));

// ../node_modules/node-fetch/lib/index.mjs
var import_stream = __toModule(require("stream")), import_http = __toModule(require("http")), import_url = __toModule(require("url")), import_https = __toModule(require("https")), import_zlib = __toModule(require("zlib")), Readable = import_stream.default.Readable, BUFFER = Symbol("buffer"), TYPE = Symbol("type"), Blob2 = class {
  constructor() {
    this[TYPE] = "";
    let blobParts = arguments[0], options = arguments[1], buffers = [], size = 0;
    if (blobParts) {
      let a = blobParts, length = Number(a.length);
      for (let i = 0; i < length; i++) {
        let element = a[i], buffer;
        element instanceof Buffer ? buffer = element : ArrayBuffer.isView(element) ? buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength) : element instanceof ArrayBuffer ? buffer = Buffer.from(element) : element instanceof Blob2 ? buffer = element[BUFFER] : buffer = Buffer.from(typeof element == "string" ? element : String(element)), size += buffer.length, buffers.push(buffer);
      }
    }
    this[BUFFER] = Buffer.concat(buffers);
    let type3 = options && options.type !== void 0 && String(options.type).toLowerCase();
    type3 && !/[^\u0020-\u007E]/.test(type3) && (this[TYPE] = type3);
  }
  get size() {
    return this[BUFFER].length;
  }
  get type() {
    return this[TYPE];
  }
  text() {
    return Promise.resolve(this[BUFFER].toString());
  }
  arrayBuffer() {
    let buf = this[BUFFER], ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    return Promise.resolve(ab);
  }
  stream() {
    let readable = new Readable();
    return readable._read = function() {
    }, readable.push(this[BUFFER]), readable.push(null), readable;
  }
  toString() {
    return "[object Blob]";
  }
  slice() {
    let size = this.size, start = arguments[0], end = arguments[1], relativeStart, relativeEnd;
    start === void 0 ? relativeStart = 0 : start < 0 ? relativeStart = Math.max(size + start, 0) : relativeStart = Math.min(start, size), end === void 0 ? relativeEnd = size : end < 0 ? relativeEnd = Math.max(size + end, 0) : relativeEnd = Math.min(end, size);
    let span = Math.max(relativeEnd - relativeStart, 0), slicedBuffer = this[BUFFER].slice(relativeStart, relativeStart + span), blob = new Blob2([], {type: arguments[2]});
    return blob[BUFFER] = slicedBuffer, blob;
  }
};
__name(Blob2, "Blob");
Object.defineProperties(Blob2.prototype, {
  size: {enumerable: !0},
  type: {enumerable: !0},
  slice: {enumerable: !0}
});
Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
  value: "Blob",
  writable: !1,
  enumerable: !1,
  configurable: !0
});
function FetchError(message, type3, systemError) {
  Error.call(this, message), this.message = message, this.type = type3, systemError && (this.code = this.errno = systemError.code), Error.captureStackTrace(this, this.constructor);
}
__name(FetchError, "FetchError");
FetchError.prototype = Object.create(Error.prototype);
FetchError.prototype.constructor = FetchError;
FetchError.prototype.name = "FetchError";
var convert;
try {
  convert = require("encoding").convert;
} catch (e) {
}
var INTERNALS = Symbol("Body internals"), PassThrough = import_stream.default.PassThrough;
function Body(body) {
  var _this = this, _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
  let size = _ref$size === void 0 ? 0 : _ref$size;
  var _ref$timeout = _ref.timeout;
  let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
  body == null ? body = null : isURLSearchParams(body) ? body = Buffer.from(body.toString()) : isBlob(body) || Buffer.isBuffer(body) || (Object.prototype.toString.call(body) === "[object ArrayBuffer]" ? body = Buffer.from(body) : ArrayBuffer.isView(body) ? body = Buffer.from(body.buffer, body.byteOffset, body.byteLength) : body instanceof import_stream.default || (body = Buffer.from(String(body)))), this[INTERNALS] = {
    body,
    disturbed: !1,
    error: null
  }, this.size = size, this.timeout = timeout, body instanceof import_stream.default && body.on("error", function(err) {
    let error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
    _this[INTERNALS].error = error;
  });
}
__name(Body, "Body");
Body.prototype = {
  get body() {
    return this[INTERNALS].body;
  },
  get bodyUsed() {
    return this[INTERNALS].disturbed;
  },
  arrayBuffer() {
    return consumeBody.call(this).then(function(buf) {
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    });
  },
  blob() {
    let ct = this.headers && this.headers.get("content-type") || "";
    return consumeBody.call(this).then(function(buf) {
      return Object.assign(new Blob2([], {
        type: ct.toLowerCase()
      }), {
        [BUFFER]: buf
      });
    });
  },
  json() {
    var _this2 = this;
    return consumeBody.call(this).then(function(buffer) {
      try {
        return JSON.parse(buffer.toString());
      } catch (err) {
        return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
      }
    });
  },
  text() {
    return consumeBody.call(this).then(function(buffer) {
      return buffer.toString();
    });
  },
  buffer() {
    return consumeBody.call(this);
  },
  textConverted() {
    var _this3 = this;
    return consumeBody.call(this).then(function(buffer) {
      return convertBody(buffer, _this3.headers);
    });
  }
};
Object.defineProperties(Body.prototype, {
  body: {enumerable: !0},
  bodyUsed: {enumerable: !0},
  arrayBuffer: {enumerable: !0},
  blob: {enumerable: !0},
  json: {enumerable: !0},
  text: {enumerable: !0}
});
Body.mixIn = function(proto) {
  for (let name of Object.getOwnPropertyNames(Body.prototype))
    if (!(name in proto)) {
      let desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
      Object.defineProperty(proto, name, desc);
    }
};
function consumeBody() {
  var _this4 = this;
  if (this[INTERNALS].disturbed)
    return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
  if (this[INTERNALS].disturbed = !0, this[INTERNALS].error)
    return Body.Promise.reject(this[INTERNALS].error);
  let body = this.body;
  if (body === null)
    return Body.Promise.resolve(Buffer.alloc(0));
  if (isBlob(body) && (body = body.stream()), Buffer.isBuffer(body))
    return Body.Promise.resolve(body);
  if (!(body instanceof import_stream.default))
    return Body.Promise.resolve(Buffer.alloc(0));
  let accum = [], accumBytes = 0, abort = !1;
  return new Body.Promise(function(resolve, reject) {
    let resTimeout;
    _this4.timeout && (resTimeout = setTimeout(function() {
      abort = !0, reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
    }, _this4.timeout)), body.on("error", function(err) {
      err.name === "AbortError" ? (abort = !0, reject(err)) : reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
    }), body.on("data", function(chunk) {
      if (!(abort || chunk === null)) {
        if (_this4.size && accumBytes + chunk.length > _this4.size) {
          abort = !0, reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
          return;
        }
        accumBytes += chunk.length, accum.push(chunk);
      }
    }), body.on("end", function() {
      if (!abort) {
        clearTimeout(resTimeout);
        try {
          resolve(Buffer.concat(accum, accumBytes));
        } catch (err) {
          reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
        }
      }
    });
  });
}
__name(consumeBody, "consumeBody");
function convertBody(buffer, headers) {
  if (typeof convert != "function")
    throw new Error("The package `encoding` must be installed to use the textConverted() function");
  let ct = headers.get("content-type"), charset = "utf-8", res, str;
  return ct && (res = /charset=([^;]*)/i.exec(ct)), str = buffer.slice(0, 1024).toString(), !res && str && (res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str)), !res && str && (res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str), res || (res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str), res && res.pop()), res && (res = /charset=(.*)/i.exec(res.pop()))), !res && str && (res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str)), res && (charset = res.pop(), (charset === "gb2312" || charset === "gbk") && (charset = "gb18030")), convert(buffer, "UTF-8", charset).toString();
}
__name(convertBody, "convertBody");
function isURLSearchParams(obj) {
  return typeof obj != "object" || typeof obj.append != "function" || typeof obj.delete != "function" || typeof obj.get != "function" || typeof obj.getAll != "function" || typeof obj.has != "function" || typeof obj.set != "function" ? !1 : obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort == "function";
}
__name(isURLSearchParams, "isURLSearchParams");
function isBlob(obj) {
  return typeof obj == "object" && typeof obj.arrayBuffer == "function" && typeof obj.type == "string" && typeof obj.stream == "function" && typeof obj.constructor == "function" && typeof obj.constructor.name == "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}
__name(isBlob, "isBlob");
function clone(instance) {
  let p1, p2, body = instance.body;
  if (instance.bodyUsed)
    throw new Error("cannot clone body after it is used");
  return body instanceof import_stream.default && typeof body.getBoundary != "function" && (p1 = new PassThrough(), p2 = new PassThrough(), body.pipe(p1), body.pipe(p2), instance[INTERNALS].body = p1, body = p2), body;
}
__name(clone, "clone");
function extractContentType(body) {
  return body === null ? null : typeof body == "string" ? "text/plain;charset=UTF-8" : isURLSearchParams(body) ? "application/x-www-form-urlencoded;charset=UTF-8" : isBlob(body) ? body.type || null : Buffer.isBuffer(body) || Object.prototype.toString.call(body) === "[object ArrayBuffer]" || ArrayBuffer.isView(body) ? null : typeof body.getBoundary == "function" ? `multipart/form-data;boundary=${body.getBoundary()}` : body instanceof import_stream.default ? null : "text/plain;charset=UTF-8";
}
__name(extractContentType, "extractContentType");
function getTotalBytes(instance) {
  let body = instance.body;
  return body === null ? 0 : isBlob(body) ? body.size : Buffer.isBuffer(body) ? body.length : body && typeof body.getLengthSync == "function" && (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) ? body.getLengthSync() : null;
}
__name(getTotalBytes, "getTotalBytes");
function writeToStream(dest, instance) {
  let body = instance.body;
  body === null ? dest.end() : isBlob(body) ? body.stream().pipe(dest) : Buffer.isBuffer(body) ? (dest.write(body), dest.end()) : body.pipe(dest);
}
__name(writeToStream, "writeToStream");
Body.Promise = global.Promise;
var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/, invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
function validateName(name) {
  if (name = `${name}`, invalidTokenRegex.test(name) || name === "")
    throw new TypeError(`${name} is not a legal HTTP header name`);
}
__name(validateName, "validateName");
function validateValue(value) {
  if (value = `${value}`, invalidHeaderCharRegex.test(value))
    throw new TypeError(`${value} is not a legal HTTP header value`);
}
__name(validateValue, "validateValue");
function find(map, name) {
  name = name.toLowerCase();
  for (let key in map)
    if (key.toLowerCase() === name)
      return key;
}
__name(find, "find");
var MAP = Symbol("map"), Headers = class {
  constructor() {
    let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
    if (this[MAP] = Object.create(null), init instanceof Headers) {
      let rawHeaders = init.raw(), headerNames = Object.keys(rawHeaders);
      for (let headerName of headerNames)
        for (let value of rawHeaders[headerName])
          this.append(headerName, value);
      return;
    }
    if (init != null)
      if (typeof init == "object") {
        let method = init[Symbol.iterator];
        if (method != null) {
          if (typeof method != "function")
            throw new TypeError("Header pairs must be iterable");
          let pairs = [];
          for (let pair of init) {
            if (typeof pair != "object" || typeof pair[Symbol.iterator] != "function")
              throw new TypeError("Each header pair must be iterable");
            pairs.push(Array.from(pair));
          }
          for (let pair of pairs) {
            if (pair.length !== 2)
              throw new TypeError("Each header pair must be a name/value tuple");
            this.append(pair[0], pair[1]);
          }
        } else
          for (let key of Object.keys(init)) {
            let value = init[key];
            this.append(key, value);
          }
      } else
        throw new TypeError("Provided initializer must be an object");
  }
  get(name) {
    name = `${name}`, validateName(name);
    let key = find(this[MAP], name);
    return key === void 0 ? null : this[MAP][key].join(", ");
  }
  forEach(callback) {
    let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0, pairs = getHeaders(this), i = 0;
    for (; i < pairs.length; ) {
      var _pairs$i = pairs[i];
      let name = _pairs$i[0], value = _pairs$i[1];
      callback.call(thisArg, value, name, this), pairs = getHeaders(this), i++;
    }
  }
  set(name, value) {
    name = `${name}`, value = `${value}`, validateName(name), validateValue(value);
    let key = find(this[MAP], name);
    this[MAP][key !== void 0 ? key : name] = [value];
  }
  append(name, value) {
    name = `${name}`, value = `${value}`, validateName(name), validateValue(value);
    let key = find(this[MAP], name);
    key !== void 0 ? this[MAP][key].push(value) : this[MAP][name] = [value];
  }
  has(name) {
    return name = `${name}`, validateName(name), find(this[MAP], name) !== void 0;
  }
  delete(name) {
    name = `${name}`, validateName(name);
    let key = find(this[MAP], name);
    key !== void 0 && delete this[MAP][key];
  }
  raw() {
    return this[MAP];
  }
  keys() {
    return createHeadersIterator(this, "key");
  }
  values() {
    return createHeadersIterator(this, "value");
  }
  [Symbol.iterator]() {
    return createHeadersIterator(this, "key+value");
  }
};
__name(Headers, "Headers");
Headers.prototype.entries = Headers.prototype[Symbol.iterator];
Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
  value: "Headers",
  writable: !1,
  enumerable: !1,
  configurable: !0
});
Object.defineProperties(Headers.prototype, {
  get: {enumerable: !0},
  forEach: {enumerable: !0},
  set: {enumerable: !0},
  append: {enumerable: !0},
  has: {enumerable: !0},
  delete: {enumerable: !0},
  keys: {enumerable: !0},
  values: {enumerable: !0},
  entries: {enumerable: !0}
});
function getHeaders(headers) {
  let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
  return Object.keys(headers[MAP]).sort().map(kind === "key" ? function(k) {
    return k.toLowerCase();
  } : kind === "value" ? function(k) {
    return headers[MAP][k].join(", ");
  } : function(k) {
    return [k.toLowerCase(), headers[MAP][k].join(", ")];
  });
}
__name(getHeaders, "getHeaders");
var INTERNAL = Symbol("internal");
function createHeadersIterator(target, kind) {
  let iterator = Object.create(HeadersIteratorPrototype);
  return iterator[INTERNAL] = {
    target,
    kind,
    index: 0
  }, iterator;
}
__name(createHeadersIterator, "createHeadersIterator");
var HeadersIteratorPrototype = Object.setPrototypeOf({
  next() {
    if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype)
      throw new TypeError("Value of `this` is not a HeadersIterator");
    var _INTERNAL = this[INTERNAL];
    let target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index, values = getHeaders(target, kind), len = values.length;
    return index >= len ? {
      value: void 0,
      done: !0
    } : (this[INTERNAL].index = index + 1, {
      value: values[index],
      done: !1
    });
  }
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
  value: "HeadersIterator",
  writable: !1,
  enumerable: !1,
  configurable: !0
});
function exportNodeCompatibleHeaders(headers) {
  let obj = Object.assign({__proto__: null}, headers[MAP]), hostHeaderKey = find(headers[MAP], "Host");
  return hostHeaderKey !== void 0 && (obj[hostHeaderKey] = obj[hostHeaderKey][0]), obj;
}
__name(exportNodeCompatibleHeaders, "exportNodeCompatibleHeaders");
function createHeadersLenient(obj) {
  let headers = new Headers();
  for (let name of Object.keys(obj))
    if (!invalidTokenRegex.test(name))
      if (Array.isArray(obj[name]))
        for (let val of obj[name])
          invalidHeaderCharRegex.test(val) || (headers[MAP][name] === void 0 ? headers[MAP][name] = [val] : headers[MAP][name].push(val));
      else
        invalidHeaderCharRegex.test(obj[name]) || (headers[MAP][name] = [obj[name]]);
  return headers;
}
__name(createHeadersLenient, "createHeadersLenient");
var INTERNALS$1 = Symbol("Response internals"), STATUS_CODES = import_http.default.STATUS_CODES, Response = class {
  constructor() {
    let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Body.call(this, body, opts);
    let status = opts.status || 200, headers = new Headers(opts.headers);
    if (body != null && !headers.has("Content-Type")) {
      let contentType2 = extractContentType(body);
      contentType2 && headers.append("Content-Type", contentType2);
    }
    this[INTERNALS$1] = {
      url: opts.url,
      status,
      statusText: opts.statusText || STATUS_CODES[status],
      headers,
      counter: opts.counter
    };
  }
  get url() {
    return this[INTERNALS$1].url || "";
  }
  get status() {
    return this[INTERNALS$1].status;
  }
  get ok() {
    return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
  }
  get redirected() {
    return this[INTERNALS$1].counter > 0;
  }
  get statusText() {
    return this[INTERNALS$1].statusText;
  }
  get headers() {
    return this[INTERNALS$1].headers;
  }
  clone() {
    return new Response(clone(this), {
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected
    });
  }
};
__name(Response, "Response");
Body.mixIn(Response.prototype);
Object.defineProperties(Response.prototype, {
  url: {enumerable: !0},
  status: {enumerable: !0},
  ok: {enumerable: !0},
  redirected: {enumerable: !0},
  statusText: {enumerable: !0},
  headers: {enumerable: !0},
  clone: {enumerable: !0}
});
Object.defineProperty(Response.prototype, Symbol.toStringTag, {
  value: "Response",
  writable: !1,
  enumerable: !1,
  configurable: !0
});
var INTERNALS$2 = Symbol("Request internals"), parse_url = import_url.default.parse, format_url = import_url.default.format, streamDestructionSupported = "destroy" in import_stream.default.Readable.prototype;
function isRequest(input) {
  return typeof input == "object" && typeof input[INTERNALS$2] == "object";
}
__name(isRequest, "isRequest");
function isAbortSignal(signal) {
  let proto = signal && typeof signal == "object" && Object.getPrototypeOf(signal);
  return !!(proto && proto.constructor.name === "AbortSignal");
}
__name(isAbortSignal, "isAbortSignal");
var Request = class {
  constructor(input) {
    let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, parsedURL;
    isRequest(input) ? parsedURL = parse_url(input.url) : (input && input.href ? parsedURL = parse_url(input.href) : parsedURL = parse_url(`${input}`), input = {});
    let method = init.method || input.method || "GET";
    if (method = method.toUpperCase(), (init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD"))
      throw new TypeError("Request with GET/HEAD method cannot have body");
    let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
    Body.call(this, inputBody, {
      timeout: init.timeout || input.timeout || 0,
      size: init.size || input.size || 0
    });
    let headers = new Headers(init.headers || input.headers || {});
    if (inputBody != null && !headers.has("Content-Type")) {
      let contentType2 = extractContentType(inputBody);
      contentType2 && headers.append("Content-Type", contentType2);
    }
    let signal = isRequest(input) ? input.signal : null;
    if ("signal" in init && (signal = init.signal), signal != null && !isAbortSignal(signal))
      throw new TypeError("Expected signal to be an instanceof AbortSignal");
    this[INTERNALS$2] = {
      method,
      redirect: init.redirect || input.redirect || "follow",
      headers,
      parsedURL,
      signal
    }, this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20, this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : !0, this.counter = init.counter || input.counter || 0, this.agent = init.agent || input.agent;
  }
  get method() {
    return this[INTERNALS$2].method;
  }
  get url() {
    return format_url(this[INTERNALS$2].parsedURL);
  }
  get headers() {
    return this[INTERNALS$2].headers;
  }
  get redirect() {
    return this[INTERNALS$2].redirect;
  }
  get signal() {
    return this[INTERNALS$2].signal;
  }
  clone() {
    return new Request(this);
  }
};
__name(Request, "Request");
Body.mixIn(Request.prototype);
Object.defineProperty(Request.prototype, Symbol.toStringTag, {
  value: "Request",
  writable: !1,
  enumerable: !1,
  configurable: !0
});
Object.defineProperties(Request.prototype, {
  method: {enumerable: !0},
  url: {enumerable: !0},
  headers: {enumerable: !0},
  redirect: {enumerable: !0},
  clone: {enumerable: !0},
  signal: {enumerable: !0}
});
function getNodeRequestOptions(request) {
  let parsedURL = request[INTERNALS$2].parsedURL, headers = new Headers(request[INTERNALS$2].headers);
  if (headers.has("Accept") || headers.set("Accept", "*/*"), !parsedURL.protocol || !parsedURL.hostname)
    throw new TypeError("Only absolute URLs are supported");
  if (!/^https?:$/.test(parsedURL.protocol))
    throw new TypeError("Only HTTP(S) protocols are supported");
  if (request.signal && request.body instanceof import_stream.default.Readable && !streamDestructionSupported)
    throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
  let contentLengthValue = null;
  if (request.body == null && /^(POST|PUT)$/i.test(request.method) && (contentLengthValue = "0"), request.body != null) {
    let totalBytes = getTotalBytes(request);
    typeof totalBytes == "number" && (contentLengthValue = String(totalBytes));
  }
  contentLengthValue && headers.set("Content-Length", contentLengthValue), headers.has("User-Agent") || headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)"), request.compress && !headers.has("Accept-Encoding") && headers.set("Accept-Encoding", "gzip,deflate");
  let agent = request.agent;
  return typeof agent == "function" && (agent = agent(parsedURL)), !headers.has("Connection") && !agent && headers.set("Connection", "close"), Object.assign({}, parsedURL, {
    method: request.method,
    headers: exportNodeCompatibleHeaders(headers),
    agent
  });
}
__name(getNodeRequestOptions, "getNodeRequestOptions");
function AbortError(message) {
  Error.call(this, message), this.type = "aborted", this.message = message, Error.captureStackTrace(this, this.constructor);
}
__name(AbortError, "AbortError");
AbortError.prototype = Object.create(Error.prototype);
AbortError.prototype.constructor = AbortError;
AbortError.prototype.name = "AbortError";
var PassThrough$1 = import_stream.default.PassThrough, resolve_url = import_url.default.resolve;
function fetch(url2, opts) {
  if (!fetch.Promise)
    throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
  return Body.Promise = fetch.Promise, new fetch.Promise(function(resolve, reject) {
    let request = new Request(url2, opts), options = getNodeRequestOptions(request), send = (options.protocol === "https:" ? import_https.default : import_http.default).request, signal = request.signal, response = null, abort = /* @__PURE__ */ __name(function() {
      let error = new AbortError("The user aborted a request.");
      reject(error), request.body && request.body instanceof import_stream.default.Readable && request.body.destroy(error), !(!response || !response.body) && response.body.emit("error", error);
    }, "abort");
    if (signal && signal.aborted) {
      abort();
      return;
    }
    let abortAndFinalize = /* @__PURE__ */ __name(function() {
      abort(), finalize();
    }, "abortAndFinalize"), req = send(options), reqTimeout;
    signal && signal.addEventListener("abort", abortAndFinalize);
    function finalize() {
      req.abort(), signal && signal.removeEventListener("abort", abortAndFinalize), clearTimeout(reqTimeout);
    }
    __name(finalize, "finalize"), request.timeout && req.once("socket", function(socket) {
      reqTimeout = setTimeout(function() {
        reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout")), finalize();
      }, request.timeout);
    }), req.on("error", function(err) {
      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err)), finalize();
    }), req.on("response", function(res) {
      clearTimeout(reqTimeout);
      let headers = createHeadersLenient(res.headers);
      if (fetch.isRedirect(res.statusCode)) {
        let location = headers.get("Location"), locationURL = location === null ? null : resolve_url(request.url, location);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect")), finalize();
            return;
          case "manual":
            if (locationURL !== null)
              try {
                headers.set("Location", locationURL);
              } catch (err) {
                reject(err);
              }
            break;
          case "follow":
            if (locationURL === null)
              break;
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect")), finalize();
              return;
            }
            let requestOpts = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              timeout: request.timeout,
              size: request.size
            };
            if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect")), finalize();
              return;
            }
            (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") && (requestOpts.method = "GET", requestOpts.body = void 0, requestOpts.headers.delete("content-length")), resolve(fetch(new Request(locationURL, requestOpts))), finalize();
            return;
        }
      }
      res.once("end", function() {
        signal && signal.removeEventListener("abort", abortAndFinalize);
      });
      let body = res.pipe(new PassThrough$1()), response_options = {
        url: request.url,
        status: res.statusCode,
        statusText: res.statusMessage,
        headers,
        size: request.size,
        timeout: request.timeout,
        counter: request.counter
      }, codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
        response = new Response(body, response_options), resolve(response);
        return;
      }
      let zlibOptions = {
        flush: import_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_zlib.default.Z_SYNC_FLUSH
      };
      if (codings == "gzip" || codings == "x-gzip") {
        body = body.pipe(import_zlib.default.createGunzip(zlibOptions)), response = new Response(body, response_options), resolve(response);
        return;
      }
      if (codings == "deflate" || codings == "x-deflate") {
        res.pipe(new PassThrough$1()).once("data", function(chunk) {
          (chunk[0] & 15) == 8 ? body = body.pipe(import_zlib.default.createInflate()) : body = body.pipe(import_zlib.default.createInflateRaw()), response = new Response(body, response_options), resolve(response);
        });
        return;
      }
      if (codings == "br" && typeof import_zlib.default.createBrotliDecompress == "function") {
        body = body.pipe(import_zlib.default.createBrotliDecompress()), response = new Response(body, response_options), resolve(response);
        return;
      }
      response = new Response(body, response_options), resolve(response);
    }), writeToStream(req, request);
  });
}
__name(fetch, "fetch");
fetch.isRedirect = function(code) {
  return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
};
fetch.Promise = global.Promise;
var lib_default = fetch;

// ../node_modules/@azure/abort-controller/dist-esm/src/AbortSignal.js
var listenersMap = new WeakMap(), abortedMap = new WeakMap(), AbortSignal = function() {
  function AbortSignal2() {
    this.onabort = null, listenersMap.set(this, []), abortedMap.set(this, !1);
  }
  return __name(AbortSignal2, "AbortSignal"), Object.defineProperty(AbortSignal2.prototype, "aborted", {
    get: function() {
      if (!abortedMap.has(this))
        throw new TypeError("Expected `this` to be an instance of AbortSignal.");
      return abortedMap.get(this);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(AbortSignal2, "none", {
    get: function() {
      return new AbortSignal2();
    },
    enumerable: !1,
    configurable: !0
  }), AbortSignal2.prototype.addEventListener = function(_type, listener) {
    if (!listenersMap.has(this))
      throw new TypeError("Expected `this` to be an instance of AbortSignal.");
    var listeners = listenersMap.get(this);
    listeners.push(listener);
  }, AbortSignal2.prototype.removeEventListener = function(_type, listener) {
    if (!listenersMap.has(this))
      throw new TypeError("Expected `this` to be an instance of AbortSignal.");
    var listeners = listenersMap.get(this), index = listeners.indexOf(listener);
    index > -1 && listeners.splice(index, 1);
  }, AbortSignal2.prototype.dispatchEvent = function(_event) {
    throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
  }, AbortSignal2;
}();
function abortSignal(signal) {
  if (!signal.aborted) {
    signal.onabort && signal.onabort.call(signal);
    var listeners = listenersMap.get(signal);
    listeners && listeners.forEach(function(listener) {
      listener.call(signal, {type: "abort"});
    }), abortedMap.set(signal, !0);
  }
}
__name(abortSignal, "abortSignal");

// ../node_modules/@azure/abort-controller/dist-esm/src/AbortController.js
var AbortError2 = function(_super) {
  __extends(AbortError3, _super);
  function AbortError3(message) {
    var _this = _super.call(this, message) || this;
    return _this.name = "AbortError", _this;
  }
  return __name(AbortError3, "AbortError"), AbortError3;
}(Error);
var AbortController = function() {
  function AbortController2(parentSignals) {
    var _this = this;
    if (this._signal = new AbortSignal(), !!parentSignals) {
      Array.isArray(parentSignals) || (parentSignals = arguments);
      for (var _i = 0, parentSignals_1 = parentSignals; _i < parentSignals_1.length; _i++) {
        var parentSignal = parentSignals_1[_i];
        parentSignal.aborted ? this.abort() : parentSignal.addEventListener("abort", function() {
          _this.abort();
        });
      }
    }
  }
  return __name(AbortController2, "AbortController"), Object.defineProperty(AbortController2.prototype, "signal", {
    get: function() {
      return this._signal;
    },
    enumerable: !1,
    configurable: !0
  }), AbortController2.prototype.abort = function() {
    abortSignal(this._signal);
  }, AbortController2.timeout = function(ms) {
    var signal = new AbortSignal(), timer = setTimeout(abortSignal, ms, signal);
    return typeof timer.unref == "function" && timer.unref(), signal;
  }, AbortController2;
}();

// ../node_modules/@azure/core-http/es/src/fetchHttpClient.js
var import_form_data = __toModule(require_form_data());

// ../node_modules/@azure/core-http/es/src/util/inspect.js
var import_util = __toModule(require("util")), custom = import_util.inspect.custom;

// ../node_modules/@azure/core-http/es/src/util/url.js
var import_url2 = __toModule(require("url"));

// ../node_modules/@azure/core-http/es/src/url.js
var URLQuery = function() {
  function URLQuery2() {
    this._rawQuery = {};
  }
  return __name(URLQuery2, "URLQuery"), URLQuery2.prototype.any = function() {
    return Object.keys(this._rawQuery).length > 0;
  }, URLQuery2.prototype.keys = function() {
    return Object.keys(this._rawQuery);
  }, URLQuery2.prototype.set = function(parameterName, parameterValue) {
    var caseParameterValue = parameterValue;
    if (parameterName)
      if (caseParameterValue != null) {
        var newValue = Array.isArray(caseParameterValue) ? caseParameterValue : caseParameterValue.toString();
        this._rawQuery[parameterName] = newValue;
      } else
        delete this._rawQuery[parameterName];
  }, URLQuery2.prototype.get = function(parameterName) {
    return parameterName ? this._rawQuery[parameterName] : void 0;
  }, URLQuery2.prototype.toString = function() {
    var result = "";
    for (var parameterName in this._rawQuery) {
      result && (result += "&");
      var parameterValue = this._rawQuery[parameterName];
      if (Array.isArray(parameterValue)) {
        for (var parameterStrings = [], _i = 0, parameterValue_1 = parameterValue; _i < parameterValue_1.length; _i++) {
          var parameterValueElement = parameterValue_1[_i];
          parameterStrings.push(parameterName + "=" + parameterValueElement);
        }
        result += parameterStrings.join("&");
      } else
        result += parameterName + "=" + parameterValue;
    }
    return result;
  }, URLQuery2.parse = function(text) {
    var result = new URLQuery2();
    if (text) {
      text.startsWith("?") && (text = text.substring(1));
      for (var currentState = "ParameterName", parameterName = "", parameterValue = "", i = 0; i < text.length; ++i) {
        var currentCharacter = text[i];
        switch (currentState) {
          case "ParameterName":
            switch (currentCharacter) {
              case "=":
                currentState = "ParameterValue";
                break;
              case "&":
                parameterName = "", parameterValue = "";
                break;
              default:
                parameterName += currentCharacter;
                break;
            }
            break;
          case "ParameterValue":
            switch (currentCharacter) {
              case "&":
                result.set(parameterName, parameterValue), parameterName = "", parameterValue = "", currentState = "ParameterName";
                break;
              default:
                parameterValue += currentCharacter;
                break;
            }
            break;
          default:
            throw new Error("Unrecognized URLQuery parse state: " + currentState);
        }
      }
      currentState === "ParameterValue" && result.set(parameterName, parameterValue);
    }
    return result;
  }, URLQuery2;
}();
var URLBuilder = function() {
  function URLBuilder2() {
  }
  return __name(URLBuilder2, "URLBuilder"), URLBuilder2.prototype.setScheme = function(scheme) {
    scheme ? this.set(scheme, "SCHEME") : this._scheme = void 0;
  }, URLBuilder2.prototype.getScheme = function() {
    return this._scheme;
  }, URLBuilder2.prototype.setHost = function(host) {
    host ? this.set(host, "SCHEME_OR_HOST") : this._host = void 0;
  }, URLBuilder2.prototype.getHost = function() {
    return this._host;
  }, URLBuilder2.prototype.setPort = function(port) {
    port == null || port === "" ? this._port = void 0 : this.set(port.toString(), "PORT");
  }, URLBuilder2.prototype.getPort = function() {
    return this._port;
  }, URLBuilder2.prototype.setPath = function(path3) {
    if (!path3)
      this._path = void 0;
    else {
      var schemeIndex = path3.indexOf("://");
      if (schemeIndex !== -1) {
        var schemeStart = path3.lastIndexOf("/", schemeIndex);
        this.set(schemeStart === -1 ? path3 : path3.substr(schemeStart + 1), "SCHEME");
      } else
        this.set(path3, "PATH");
    }
  }, URLBuilder2.prototype.appendPath = function(path3) {
    if (path3) {
      var currentPath = this.getPath();
      currentPath && (currentPath.endsWith("/") || (currentPath += "/"), path3.startsWith("/") && (path3 = path3.substring(1)), path3 = currentPath + path3), this.set(path3, "PATH");
    }
  }, URLBuilder2.prototype.getPath = function() {
    return this._path;
  }, URLBuilder2.prototype.setQuery = function(query) {
    query ? this._query = URLQuery.parse(query) : this._query = void 0;
  }, URLBuilder2.prototype.setQueryParameter = function(queryParameterName, queryParameterValue) {
    queryParameterName && (this._query || (this._query = new URLQuery()), this._query.set(queryParameterName, queryParameterValue));
  }, URLBuilder2.prototype.getQueryParameterValue = function(queryParameterName) {
    return this._query ? this._query.get(queryParameterName) : void 0;
  }, URLBuilder2.prototype.getQuery = function() {
    return this._query ? this._query.toString() : void 0;
  }, URLBuilder2.prototype.set = function(text, startState) {
    for (var tokenizer = new URLTokenizer(text, startState); tokenizer.next(); ) {
      var token = tokenizer.current(), tokenPath = void 0;
      if (token)
        switch (token.type) {
          case "SCHEME":
            this._scheme = token.text || void 0;
            break;
          case "HOST":
            this._host = token.text || void 0;
            break;
          case "PORT":
            this._port = token.text || void 0;
            break;
          case "PATH":
            tokenPath = token.text || void 0, (!this._path || this._path === "/" || tokenPath !== "/") && (this._path = tokenPath);
            break;
          case "QUERY":
            this._query = URLQuery.parse(token.text);
            break;
          default:
            throw new Error("Unrecognized URLTokenType: " + token.type);
        }
    }
  }, URLBuilder2.prototype.toString = function() {
    var result = "";
    return this._scheme && (result += this._scheme + "://"), this._host && (result += this._host), this._port && (result += ":" + this._port), this._path && (this._path.startsWith("/") || (result += "/"), result += this._path), this._query && this._query.any() && (result += "?" + this._query.toString()), result;
  }, URLBuilder2.prototype.replaceAll = function(searchValue, replaceValue) {
    searchValue && (this.setScheme(replaceAll(this.getScheme(), searchValue, replaceValue)), this.setHost(replaceAll(this.getHost(), searchValue, replaceValue)), this.setPort(replaceAll(this.getPort(), searchValue, replaceValue)), this.setPath(replaceAll(this.getPath(), searchValue, replaceValue)), this.setQuery(replaceAll(this.getQuery(), searchValue, replaceValue)));
  }, URLBuilder2.parse = function(text) {
    var result = new URLBuilder2();
    return result.set(text, "SCHEME_OR_HOST"), result;
  }, URLBuilder2;
}();
var URLToken = function() {
  function URLToken2(text, type3) {
    this.text = text, this.type = type3;
  }
  return __name(URLToken2, "URLToken"), URLToken2.scheme = function(text) {
    return new URLToken2(text, "SCHEME");
  }, URLToken2.host = function(text) {
    return new URLToken2(text, "HOST");
  }, URLToken2.port = function(text) {
    return new URLToken2(text, "PORT");
  }, URLToken2.path = function(text) {
    return new URLToken2(text, "PATH");
  }, URLToken2.query = function(text) {
    return new URLToken2(text, "QUERY");
  }, URLToken2;
}();
function isAlphaNumericCharacter(character) {
  var characterCode = character.charCodeAt(0);
  return 48 <= characterCode && characterCode <= 57 || 65 <= characterCode && characterCode <= 90 || 97 <= characterCode && characterCode <= 122;
}
__name(isAlphaNumericCharacter, "isAlphaNumericCharacter");
var URLTokenizer = function() {
  function URLTokenizer2(_text, state) {
    this._text = _text, this._textLength = _text ? _text.length : 0, this._currentState = state != null ? state : "SCHEME_OR_HOST", this._currentIndex = 0;
  }
  return __name(URLTokenizer2, "URLTokenizer"), URLTokenizer2.prototype.current = function() {
    return this._currentToken;
  }, URLTokenizer2.prototype.next = function() {
    if (!hasCurrentCharacter(this))
      this._currentToken = void 0;
    else
      switch (this._currentState) {
        case "SCHEME":
          nextScheme(this);
          break;
        case "SCHEME_OR_HOST":
          nextSchemeOrHost(this);
          break;
        case "HOST":
          nextHost(this);
          break;
        case "PORT":
          nextPort(this);
          break;
        case "PATH":
          nextPath(this);
          break;
        case "QUERY":
          nextQuery(this);
          break;
        default:
          throw new Error("Unrecognized URLTokenizerState: " + this._currentState);
      }
    return !!this._currentToken;
  }, URLTokenizer2;
}();
function readRemaining(tokenizer) {
  var result = "";
  return tokenizer._currentIndex < tokenizer._textLength && (result = tokenizer._text.substring(tokenizer._currentIndex), tokenizer._currentIndex = tokenizer._textLength), result;
}
__name(readRemaining, "readRemaining");
function hasCurrentCharacter(tokenizer) {
  return tokenizer._currentIndex < tokenizer._textLength;
}
__name(hasCurrentCharacter, "hasCurrentCharacter");
function getCurrentCharacter(tokenizer) {
  return tokenizer._text[tokenizer._currentIndex];
}
__name(getCurrentCharacter, "getCurrentCharacter");
function nextCharacter(tokenizer, step) {
  hasCurrentCharacter(tokenizer) && (step || (step = 1), tokenizer._currentIndex += step);
}
__name(nextCharacter, "nextCharacter");
function peekCharacters(tokenizer, charactersToPeek) {
  var endIndex = tokenizer._currentIndex + charactersToPeek;
  return tokenizer._textLength < endIndex && (endIndex = tokenizer._textLength), tokenizer._text.substring(tokenizer._currentIndex, endIndex);
}
__name(peekCharacters, "peekCharacters");
function readWhile(tokenizer, condition) {
  for (var result = ""; hasCurrentCharacter(tokenizer); ) {
    var currentCharacter = getCurrentCharacter(tokenizer);
    if (condition(currentCharacter))
      result += currentCharacter, nextCharacter(tokenizer);
    else
      break;
  }
  return result;
}
__name(readWhile, "readWhile");
function readWhileLetterOrDigit(tokenizer) {
  return readWhile(tokenizer, function(character) {
    return isAlphaNumericCharacter(character);
  });
}
__name(readWhileLetterOrDigit, "readWhileLetterOrDigit");
function readUntilCharacter(tokenizer) {
  for (var terminatingCharacters = [], _i = 1; _i < arguments.length; _i++)
    terminatingCharacters[_i - 1] = arguments[_i];
  return readWhile(tokenizer, function(character) {
    return terminatingCharacters.indexOf(character) === -1;
  });
}
__name(readUntilCharacter, "readUntilCharacter");
function nextScheme(tokenizer) {
  var scheme = readWhileLetterOrDigit(tokenizer);
  tokenizer._currentToken = URLToken.scheme(scheme), hasCurrentCharacter(tokenizer) ? tokenizer._currentState = "HOST" : tokenizer._currentState = "DONE";
}
__name(nextScheme, "nextScheme");
function nextSchemeOrHost(tokenizer) {
  var schemeOrHost = readUntilCharacter(tokenizer, ":", "/", "?");
  hasCurrentCharacter(tokenizer) ? getCurrentCharacter(tokenizer) === ":" ? peekCharacters(tokenizer, 3) === "://" ? (tokenizer._currentToken = URLToken.scheme(schemeOrHost), tokenizer._currentState = "HOST") : (tokenizer._currentToken = URLToken.host(schemeOrHost), tokenizer._currentState = "PORT") : (tokenizer._currentToken = URLToken.host(schemeOrHost), getCurrentCharacter(tokenizer) === "/" ? tokenizer._currentState = "PATH" : tokenizer._currentState = "QUERY") : (tokenizer._currentToken = URLToken.host(schemeOrHost), tokenizer._currentState = "DONE");
}
__name(nextSchemeOrHost, "nextSchemeOrHost");
function nextHost(tokenizer) {
  peekCharacters(tokenizer, 3) === "://" && nextCharacter(tokenizer, 3);
  var host = readUntilCharacter(tokenizer, ":", "/", "?");
  tokenizer._currentToken = URLToken.host(host), hasCurrentCharacter(tokenizer) ? getCurrentCharacter(tokenizer) === ":" ? tokenizer._currentState = "PORT" : getCurrentCharacter(tokenizer) === "/" ? tokenizer._currentState = "PATH" : tokenizer._currentState = "QUERY" : tokenizer._currentState = "DONE";
}
__name(nextHost, "nextHost");
function nextPort(tokenizer) {
  getCurrentCharacter(tokenizer) === ":" && nextCharacter(tokenizer);
  var port = readUntilCharacter(tokenizer, "/", "?");
  tokenizer._currentToken = URLToken.port(port), hasCurrentCharacter(tokenizer) ? getCurrentCharacter(tokenizer) === "/" ? tokenizer._currentState = "PATH" : tokenizer._currentState = "QUERY" : tokenizer._currentState = "DONE";
}
__name(nextPort, "nextPort");
function nextPath(tokenizer) {
  var path3 = readUntilCharacter(tokenizer, "?");
  tokenizer._currentToken = URLToken.path(path3), hasCurrentCharacter(tokenizer) ? tokenizer._currentState = "QUERY" : tokenizer._currentState = "DONE";
}
__name(nextPath, "nextPath");
function nextQuery(tokenizer) {
  getCurrentCharacter(tokenizer) === "?" && nextCharacter(tokenizer);
  var query = readRemaining(tokenizer);
  tokenizer._currentToken = URLToken.query(query), tokenizer._currentState = "DONE";
}
__name(nextQuery, "nextQuery");

// ../node_modules/@azure/core-http/es/src/util/sanitizer.js
var RedactedString = "REDACTED", defaultAllowedHeaderNames = [
  "x-ms-client-request-id",
  "x-ms-return-client-request-id",
  "x-ms-useragent",
  "x-ms-correlation-request-id",
  "x-ms-request-id",
  "client-request-id",
  "return-client-request-id",
  "traceparent",
  "Access-Control-Allow-Credentials",
  "Access-Control-Allow-Headers",
  "Access-Control-Allow-Methods",
  "Access-Control-Allow-Origin",
  "Access-Control-Expose-Headers",
  "Access-Control-Max-Age",
  "Access-Control-Request-Headers",
  "Access-Control-Request-Method",
  "Origin",
  "Accept",
  "Cache-Control",
  "Connection",
  "Content-Length",
  "Content-Type",
  "Date",
  "ETag",
  "Expires",
  "If-Match",
  "If-Modified-Since",
  "If-None-Match",
  "If-Unmodified-Since",
  "Last-Modified",
  "Pragma",
  "Request-Id",
  "Retry-After",
  "Server",
  "Transfer-Encoding",
  "User-Agent"
], defaultAllowedQueryParameters = ["api-version"], Sanitizer = function() {
  function Sanitizer2(_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.allowedHeaderNames, allowedHeaderNames = _c === void 0 ? [] : _c, _d = _b.allowedQueryParameters, allowedQueryParameters = _d === void 0 ? [] : _d;
    allowedHeaderNames = Array.isArray(allowedHeaderNames) ? defaultAllowedHeaderNames.concat(allowedHeaderNames) : defaultAllowedHeaderNames, allowedQueryParameters = Array.isArray(allowedQueryParameters) ? defaultAllowedQueryParameters.concat(allowedQueryParameters) : defaultAllowedQueryParameters, this.allowedHeaderNames = new Set(allowedHeaderNames.map(function(n) {
      return n.toLowerCase();
    })), this.allowedQueryParameters = new Set(allowedQueryParameters.map(function(p) {
      return p.toLowerCase();
    }));
  }
  return __name(Sanitizer2, "Sanitizer"), Sanitizer2.prototype.sanitize = function(obj) {
    return JSON.stringify(obj, this.replacer.bind(this), 2);
  }, Sanitizer2.prototype.replacer = function(key, value) {
    return value instanceof Error ? __assign(__assign({}, value), {name: value.name, message: value.message}) : key === "_headersMap" ? this.sanitizeHeaders(key, value) : key === "url" ? this.sanitizeUrl(value) : key === "query" ? this.sanitizeQuery(value) : key === "body" || key === "response" || key === "operationSpec" ? void 0 : value;
  }, Sanitizer2.prototype.sanitizeHeaders = function(_, value) {
    return this.sanitizeObject(value, this.allowedHeaderNames, function(v, k) {
      return v[k].value;
    });
  }, Sanitizer2.prototype.sanitizeQuery = function(value) {
    return this.sanitizeObject(value, this.allowedQueryParameters, function(v, k) {
      return v[k];
    });
  }, Sanitizer2.prototype.sanitizeObject = function(value, allowedKeys, accessor) {
    if (typeof value != "object" || value === null)
      return value;
    for (var sanitized = {}, _i = 0, _a = Object.keys(value); _i < _a.length; _i++) {
      var k = _a[_i];
      allowedKeys.has(k.toLowerCase()) ? sanitized[k] = accessor(value, k) : sanitized[k] = RedactedString;
    }
    return sanitized;
  }, Sanitizer2.prototype.sanitizeUrl = function(value) {
    if (typeof value != "string" || value === null)
      return value;
    var urlBuilder = URLBuilder.parse(value), queryString = urlBuilder.getQuery();
    if (!queryString)
      return value;
    for (var query = URLQuery.parse(queryString), _i = 0, _a = query.keys(); _i < _a.length; _i++) {
      var k = _a[_i];
      this.allowedQueryParameters.has(k.toLowerCase()) || query.set(k, RedactedString);
    }
    return urlBuilder.setQuery(query.toString()), urlBuilder.toString();
  }, Sanitizer2;
}();

// ../node_modules/@azure/core-http/es/src/restError.js
var errorSanitizer = new Sanitizer(), RestError = function(_super) {
  __extends(RestError2, _super);
  function RestError2(message, code, statusCode, request, response) {
    var _this = _super.call(this, message) || this;
    return _this.name = "RestError", _this.code = code, _this.statusCode = statusCode, _this.request = request, _this.response = response, Object.setPrototypeOf(_this, RestError2.prototype), _this;
  }
  return __name(RestError2, "RestError"), RestError2.prototype[custom] = function() {
    return "RestError: " + this.message + ` 
 ` + errorSanitizer.sanitize(this);
  }, RestError2.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR", RestError2.PARSE_ERROR = "PARSE_ERROR", RestError2;
}(Error);

// ../node_modules/@azure/core-http/es/src/fetchHttpClient.js
var import_stream2 = __toModule(require("stream")), ReportTransform = function(_super) {
  __extends(ReportTransform2, _super);
  function ReportTransform2(progressCallback) {
    var _this = _super.call(this) || this;
    return _this.progressCallback = progressCallback, _this.loadedBytes = 0, _this;
  }
  return __name(ReportTransform2, "ReportTransform"), ReportTransform2.prototype._transform = function(chunk, _encoding, callback) {
    this.push(chunk), this.loadedBytes += chunk.length, this.progressCallback({loadedBytes: this.loadedBytes}), callback(void 0);
  }, ReportTransform2;
}(import_stream2.Transform);
var FetchHttpClient = function() {
  function FetchHttpClient2() {
  }
  return __name(FetchHttpClient2, "FetchHttpClient"), FetchHttpClient2.prototype.sendRequest = function(httpRequest) {
    return __awaiter(this, void 0, void 0, function() {
      var abortController, abortListener, formData, requestForm_1, appendFormValue, _i, _a, formKey, formValue, j, contentType2, body, onUploadProgress, uploadReportStream, platformSpecificRequestInit, requestInit, response, headers, operationResponse, _b, onDownloadProgress, responseBody, downloadReportStream, length_1, error_1, fetchError, _c;
      return __generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            if (!httpRequest && typeof httpRequest != "object")
              throw new Error("'httpRequest' (WebResourceLike) cannot be null or undefined and must be of type object.");
            if (abortController = new AbortController(), httpRequest.abortSignal) {
              if (httpRequest.abortSignal.aborted)
                throw new AbortError2("The operation was aborted.");
              abortListener = /* @__PURE__ */ __name(function(event) {
                event.type === "abort" && abortController.abort();
              }, "abortListener"), httpRequest.abortSignal.addEventListener("abort", abortListener);
            }
            if (httpRequest.timeout && setTimeout(function() {
              abortController.abort();
            }, httpRequest.timeout), httpRequest.formData) {
              for (formData = httpRequest.formData, requestForm_1 = new import_form_data.default(), appendFormValue = /* @__PURE__ */ __name(function(key, value) {
                typeof value == "function" && (value = value()), value && Object.prototype.hasOwnProperty.call(value, "value") && Object.prototype.hasOwnProperty.call(value, "options") ? requestForm_1.append(key, value.value, value.options) : requestForm_1.append(key, value);
              }, "appendFormValue"), _i = 0, _a = Object.keys(formData); _i < _a.length; _i++)
                if (formKey = _a[_i], formValue = formData[formKey], Array.isArray(formValue))
                  for (j = 0; j < formValue.length; j++)
                    appendFormValue(formKey, formValue[j]);
                else
                  appendFormValue(formKey, formValue);
              httpRequest.body = requestForm_1, httpRequest.formData = void 0, contentType2 = httpRequest.headers.get("Content-Type"), contentType2 && contentType2.indexOf("multipart/form-data") !== -1 && (typeof requestForm_1.getBoundary == "function" ? httpRequest.headers.set("Content-Type", "multipart/form-data; boundary=" + requestForm_1.getBoundary()) : httpRequest.headers.remove("Content-Type"));
            }
            return body = httpRequest.body ? typeof httpRequest.body == "function" ? httpRequest.body() : httpRequest.body : void 0, httpRequest.onUploadProgress && httpRequest.body && (onUploadProgress = httpRequest.onUploadProgress, uploadReportStream = new ReportTransform(onUploadProgress), isReadableStream(body) ? body.pipe(uploadReportStream) : uploadReportStream.end(body), body = uploadReportStream), [4, this.prepareRequest(httpRequest)];
          case 1:
            platformSpecificRequestInit = _d.sent(), requestInit = __assign({body, headers: httpRequest.headers.rawHeaders(), method: httpRequest.method, signal: abortController.signal, redirect: "manual"}, platformSpecificRequestInit), _d.label = 2;
          case 2:
            return _d.trys.push([2, 8, 9, 10]), [4, this.fetch(httpRequest.url, requestInit)];
          case 3:
            return response = _d.sent(), headers = parseHeaders(response.headers), _c = {
              headers,
              request: httpRequest,
              status: response.status,
              readableStreamBody: httpRequest.streamResponseBody ? response.body : void 0
            }, httpRequest.streamResponseBody ? [3, 5] : [4, response.text()];
          case 4:
            return _b = _d.sent(), [3, 6];
          case 5:
            _b = void 0, _d.label = 6;
          case 6:
            return operationResponse = (_c.bodyAsText = _b, _c), onDownloadProgress = httpRequest.onDownloadProgress, onDownloadProgress && (responseBody = response.body || void 0, isReadableStream(responseBody) ? (downloadReportStream = new ReportTransform(onDownloadProgress), responseBody.pipe(downloadReportStream), operationResponse.readableStreamBody = downloadReportStream) : (length_1 = parseInt(headers.get("Content-Length")) || void 0, length_1 && onDownloadProgress({loadedBytes: length_1}))), [4, this.processRequest(operationResponse)];
          case 7:
            return _d.sent(), [2, operationResponse];
          case 8:
            throw error_1 = _d.sent(), fetchError = error_1, fetchError.code === "ENOTFOUND" ? new RestError(fetchError.message, RestError.REQUEST_SEND_ERROR, void 0, httpRequest) : fetchError.type === "aborted" ? new AbortError2("The operation was aborted.") : fetchError;
          case 9:
            return httpRequest.abortSignal && abortListener && httpRequest.abortSignal.removeEventListener("abort", abortListener), [7];
          case 10:
            return [2];
        }
      });
    });
  }, FetchHttpClient2;
}();
function isReadableStream(body) {
  return body && typeof body.pipe == "function";
}
__name(isReadableStream, "isReadableStream");
function parseHeaders(headers) {
  var httpHeaders = new HttpHeaders();
  return headers.forEach(function(value, key) {
    httpHeaders.set(key, value);
  }), httpHeaders;
}
__name(parseHeaders, "parseHeaders");

// ../node_modules/@azure/core-http/es/src/proxyAgent.js
var tunnel = __toModule(require_tunnel2());
function createProxyAgent(requestUrl, proxySettings, headers) {
  var host = URLBuilder.parse(proxySettings.host).getHost();
  if (!host)
    throw new Error("Expecting a non-empty host in proxy settings.");
  if (!isValidPort(proxySettings.port))
    throw new Error("Expecting a valid port number in the range of [0, 65535] in proxy settings.");
  var tunnelOptions = {
    proxy: {
      host,
      port: proxySettings.port,
      headers: headers && headers.rawHeaders() || {}
    }
  };
  proxySettings.username && proxySettings.password && (tunnelOptions.proxy.proxyAuth = proxySettings.username + ":" + proxySettings.password);
  var isRequestHttps = isUrlHttps(requestUrl), isProxyHttps = isUrlHttps(proxySettings.host), proxyAgent = {
    isHttps: isRequestHttps,
    agent: createTunnel(isRequestHttps, isProxyHttps, tunnelOptions)
  };
  return proxyAgent;
}
__name(createProxyAgent, "createProxyAgent");
function isUrlHttps(url2) {
  var urlScheme = URLBuilder.parse(url2).getScheme() || "";
  return urlScheme.toLowerCase() === "https";
}
__name(isUrlHttps, "isUrlHttps");
function createTunnel(isRequestHttps, isProxyHttps, tunnelOptions) {
  return isRequestHttps && isProxyHttps ? tunnel.httpsOverHttps(tunnelOptions) : isRequestHttps && !isProxyHttps ? tunnel.httpsOverHttp(tunnelOptions) : !isRequestHttps && isProxyHttps ? tunnel.httpOverHttps(tunnelOptions) : tunnel.httpOverHttp(tunnelOptions);
}
__name(createTunnel, "createTunnel");
function isValidPort(port) {
  return 0 <= port && port <= 65535;
}
__name(isValidPort, "isValidPort");

// ../node_modules/@azure/core-http/es/src/nodeFetchHttpClient.js
function getCachedAgent(isHttps, agentCache) {
  return isHttps ? agentCache.httpsAgent : agentCache.httpAgent;
}
__name(getCachedAgent, "getCachedAgent");
var NodeFetchHttpClient = function(_super) {
  __extends(NodeFetchHttpClient2, _super);
  function NodeFetchHttpClient2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    return _this.proxyAgents = {}, _this.keepAliveAgents = {}, _this.cookieJar = new tough.CookieJar(void 0, {looseMode: !0}), _this;
  }
  return __name(NodeFetchHttpClient2, "NodeFetchHttpClient"), NodeFetchHttpClient2.prototype.getOrCreateAgent = function(httpRequest) {
    var isHttps = isUrlHttps(httpRequest.url);
    if (httpRequest.proxySettings) {
      var agent = getCachedAgent(isHttps, this.proxyAgents);
      if (agent)
        return agent;
      var tunnel2 = createProxyAgent(httpRequest.url, httpRequest.proxySettings, httpRequest.headers);
      return agent = tunnel2.agent, tunnel2.isHttps ? this.proxyAgents.httpsAgent = tunnel2.agent : this.proxyAgents.httpAgent = tunnel2.agent, agent;
    } else if (httpRequest.keepAlive) {
      var agent = getCachedAgent(isHttps, this.keepAliveAgents);
      if (agent)
        return agent;
      var agentOptions = {
        keepAlive: httpRequest.keepAlive
      };
      return isHttps ? agent = this.keepAliveAgents.httpsAgent = new https2.Agent(agentOptions) : agent = this.keepAliveAgents.httpAgent = new http2.Agent(agentOptions), agent;
    } else
      return isHttps ? https2.globalAgent : http2.globalAgent;
  }, NodeFetchHttpClient2.prototype.fetch = function(input, init) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        return [2, lib_default(input, init)];
      });
    });
  }, NodeFetchHttpClient2.prototype.prepareRequest = function(httpRequest) {
    return __awaiter(this, void 0, void 0, function() {
      var requestInit, cookieString, _this = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return requestInit = {}, this.cookieJar && !httpRequest.headers.get("Cookie") ? [4, new Promise(function(resolve, reject) {
              _this.cookieJar.getCookieString(httpRequest.url, function(err, cookie) {
                err ? reject(err) : resolve(cookie);
              });
            })] : [3, 2];
          case 1:
            cookieString = _a.sent(), httpRequest.headers.set("Cookie", cookieString), _a.label = 2;
          case 2:
            return requestInit.agent = this.getOrCreateAgent(httpRequest), requestInit.compress = httpRequest.decompressResponse, [2, requestInit];
        }
      });
    });
  }, NodeFetchHttpClient2.prototype.processRequest = function(operationResponse) {
    return __awaiter(this, void 0, void 0, function() {
      var setCookieHeader_1, _this = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return this.cookieJar ? (setCookieHeader_1 = operationResponse.headers.get("Set-Cookie"), setCookieHeader_1 === void 0 ? [3, 2] : [4, new Promise(function(resolve, reject) {
              _this.cookieJar.setCookie(setCookieHeader_1, operationResponse.request.url, {ignoreError: !0}, function(err) {
                err ? reject(err) : resolve();
              });
            })]) : [3, 2];
          case 1:
            _a.sent(), _a.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, NodeFetchHttpClient2;
}(FetchHttpClient);

// ../node_modules/@azure/core-http/es/src/httpPipelineLogLevel.js
var HttpPipelineLogLevel;
(function(HttpPipelineLogLevel2) {
  HttpPipelineLogLevel2[HttpPipelineLogLevel2.OFF = 0] = "OFF", HttpPipelineLogLevel2[HttpPipelineLogLevel2.ERROR = 1] = "ERROR", HttpPipelineLogLevel2[HttpPipelineLogLevel2.WARNING = 2] = "WARNING", HttpPipelineLogLevel2[HttpPipelineLogLevel2.INFO = 3] = "INFO";
})(HttpPipelineLogLevel || (HttpPipelineLogLevel = {}));

// ../node_modules/@azure/core-auth/dist-esm/src/tokenCredential.js
function isTokenCredential(credential) {
  var castCredential = credential;
  return castCredential && typeof castCredential.getToken == "function" && (castCredential.signRequest === void 0 || castCredential.getToken.length > 0);
}
__name(isTokenCredential, "isTokenCredential");

// ../node_modules/@azure/core-http/es/src/policies/requestPolicy.js
var BaseRequestPolicy = function() {
  function BaseRequestPolicy2(_nextPolicy, _options) {
    this._nextPolicy = _nextPolicy, this._options = _options;
  }
  return __name(BaseRequestPolicy2, "BaseRequestPolicy"), BaseRequestPolicy2.prototype.shouldLog = function(logLevel) {
    return this._options.shouldLog(logLevel);
  }, BaseRequestPolicy2.prototype.log = function(logLevel, message) {
    this._options.log(logLevel, message);
  }, BaseRequestPolicy2;
}();
var RequestPolicyOptions = function() {
  function RequestPolicyOptions2(_logger) {
    this._logger = _logger;
  }
  return __name(RequestPolicyOptions2, "RequestPolicyOptions"), RequestPolicyOptions2.prototype.shouldLog = function(logLevel) {
    return !!this._logger && logLevel !== HttpPipelineLogLevel.OFF && logLevel <= this._logger.minimumLogLevel;
  }, RequestPolicyOptions2.prototype.log = function(logLevel, message) {
    this._logger && this.shouldLog(logLevel) && this._logger.log(logLevel, message);
  }, RequestPolicyOptions2;
}();

// ../node_modules/@azure/logger/dist-esm/src/log.js
var import_util2 = __toModule(require("util")), import_os = __toModule(require("os"));
function log(message) {
  for (var args = [], _i = 1; _i < arguments.length; _i++)
    args[_i - 1] = arguments[_i];
  process.stderr.write("" + import_util2.default.format.apply(import_util2.default, __spread([message], args)) + import_os.EOL);
}
__name(log, "log");

// ../node_modules/@azure/logger/dist-esm/src/debug.js
var debugEnvVariable = typeof process != "undefined" && process.env && process.env.DEBUG || void 0, enabledString, enabledNamespaces = [], skippedNamespaces = [], debuggers = [];
debugEnvVariable && enable(debugEnvVariable);
var debugObj = Object.assign(function(namespace) {
  return createDebugger(namespace);
}, {
  enable,
  enabled,
  disable,
  log
});
function enable(namespaces) {
  var e_1, _a, e_2, _b;
  enabledString = namespaces, enabledNamespaces = [], skippedNamespaces = [];
  var wildcard = /\*/g, namespaceList = namespaces.split(",").map(function(ns2) {
    return ns2.trim().replace(wildcard, ".*?");
  });
  try {
    for (var namespaceList_1 = __values2(namespaceList), namespaceList_1_1 = namespaceList_1.next(); !namespaceList_1_1.done; namespaceList_1_1 = namespaceList_1.next()) {
      var ns = namespaceList_1_1.value;
      ns.startsWith("-") ? skippedNamespaces.push(new RegExp("^" + ns.substr(1) + "$")) : enabledNamespaces.push(new RegExp("^" + ns + "$"));
    }
  } catch (e_1_1) {
    e_1 = {error: e_1_1};
  } finally {
    try {
      namespaceList_1_1 && !namespaceList_1_1.done && (_a = namespaceList_1.return) && _a.call(namespaceList_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  try {
    for (var debuggers_1 = __values2(debuggers), debuggers_1_1 = debuggers_1.next(); !debuggers_1_1.done; debuggers_1_1 = debuggers_1.next()) {
      var instance = debuggers_1_1.value;
      instance.enabled = enabled(instance.namespace);
    }
  } catch (e_2_1) {
    e_2 = {error: e_2_1};
  } finally {
    try {
      debuggers_1_1 && !debuggers_1_1.done && (_b = debuggers_1.return) && _b.call(debuggers_1);
    } finally {
      if (e_2)
        throw e_2.error;
    }
  }
}
__name(enable, "enable");
function enabled(namespace) {
  var e_3, _a, e_4, _b;
  if (namespace.endsWith("*"))
    return !0;
  try {
    for (var skippedNamespaces_1 = __values2(skippedNamespaces), skippedNamespaces_1_1 = skippedNamespaces_1.next(); !skippedNamespaces_1_1.done; skippedNamespaces_1_1 = skippedNamespaces_1.next()) {
      var skipped = skippedNamespaces_1_1.value;
      if (skipped.test(namespace))
        return !1;
    }
  } catch (e_3_1) {
    e_3 = {error: e_3_1};
  } finally {
    try {
      skippedNamespaces_1_1 && !skippedNamespaces_1_1.done && (_a = skippedNamespaces_1.return) && _a.call(skippedNamespaces_1);
    } finally {
      if (e_3)
        throw e_3.error;
    }
  }
  try {
    for (var enabledNamespaces_1 = __values2(enabledNamespaces), enabledNamespaces_1_1 = enabledNamespaces_1.next(); !enabledNamespaces_1_1.done; enabledNamespaces_1_1 = enabledNamespaces_1.next()) {
      var enabledNamespace = enabledNamespaces_1_1.value;
      if (enabledNamespace.test(namespace))
        return !0;
    }
  } catch (e_4_1) {
    e_4 = {error: e_4_1};
  } finally {
    try {
      enabledNamespaces_1_1 && !enabledNamespaces_1_1.done && (_b = enabledNamespaces_1.return) && _b.call(enabledNamespaces_1);
    } finally {
      if (e_4)
        throw e_4.error;
    }
  }
  return !1;
}
__name(enabled, "enabled");
function disable() {
  var result = enabledString || "";
  return enable(""), result;
}
__name(disable, "disable");
function createDebugger(namespace) {
  var newDebugger = Object.assign(debug, {
    enabled: enabled(namespace),
    destroy,
    log: debugObj.log,
    namespace,
    extend
  });
  function debug() {
    for (var args = [], _i = 0; _i < arguments.length; _i++)
      args[_i] = arguments[_i];
    !newDebugger.enabled || (args.length > 0 && (args[0] = namespace + " " + args[0]), newDebugger.log.apply(newDebugger, __spread(args)));
  }
  return __name(debug, "debug"), debuggers.push(newDebugger), newDebugger;
}
__name(createDebugger, "createDebugger");
function destroy() {
  var index = debuggers.indexOf(this);
  return index >= 0 ? (debuggers.splice(index, 1), !0) : !1;
}
__name(destroy, "destroy");
function extend(namespace) {
  var newDebugger = createDebugger(this.namespace + ":" + namespace);
  return newDebugger.log = this.log, newDebugger;
}
__name(extend, "extend");
var debug_default = debugObj;

// ../node_modules/@azure/logger/dist-esm/src/index.js
var registeredLoggers = new Set(), logLevelFromEnv = typeof process != "undefined" && process.env && process.env.AZURE_LOG_LEVEL || void 0, azureLogLevel, AzureLogger = debug_default("azure");
AzureLogger.log = function() {
  for (var args = [], _i = 0; _i < arguments.length; _i++)
    args[_i] = arguments[_i];
  debug_default.log.apply(debug_default, __spread(args));
};
var AZURE_LOG_LEVELS = ["verbose", "info", "warning", "error"];
logLevelFromEnv && (isAzureLogLevel(logLevelFromEnv) ? setLogLevel(logLevelFromEnv) : console.error("AZURE_LOG_LEVEL set to unknown log level '" + logLevelFromEnv + "'; logging is not enabled. Acceptable values: " + AZURE_LOG_LEVELS.join(", ") + "."));
function setLogLevel(level) {
  var e_1, _a;
  if (level && !isAzureLogLevel(level))
    throw new Error("Unknown log level '" + level + "'. Acceptable values: " + AZURE_LOG_LEVELS.join(","));
  azureLogLevel = level;
  var enabledNamespaces2 = [];
  try {
    for (var registeredLoggers_1 = __values2(registeredLoggers), registeredLoggers_1_1 = registeredLoggers_1.next(); !registeredLoggers_1_1.done; registeredLoggers_1_1 = registeredLoggers_1.next()) {
      var logger3 = registeredLoggers_1_1.value;
      shouldEnable(logger3) && enabledNamespaces2.push(logger3.namespace);
    }
  } catch (e_1_1) {
    e_1 = {error: e_1_1};
  } finally {
    try {
      registeredLoggers_1_1 && !registeredLoggers_1_1.done && (_a = registeredLoggers_1.return) && _a.call(registeredLoggers_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  debug_default.enable(enabledNamespaces2.join(","));
}
__name(setLogLevel, "setLogLevel");
var levelMap = {
  verbose: 400,
  info: 300,
  warning: 200,
  error: 100
};
function createClientLogger(namespace) {
  var clientRootLogger = AzureLogger.extend(namespace);
  return patchLogMethod(AzureLogger, clientRootLogger), {
    error: createLogger(clientRootLogger, "error"),
    warning: createLogger(clientRootLogger, "warning"),
    info: createLogger(clientRootLogger, "info"),
    verbose: createLogger(clientRootLogger, "verbose")
  };
}
__name(createClientLogger, "createClientLogger");
function patchLogMethod(parent, child) {
  child.log = function() {
    for (var args = [], _i = 0; _i < arguments.length; _i++)
      args[_i] = arguments[_i];
    parent.log.apply(parent, __spread(args));
  };
}
__name(patchLogMethod, "patchLogMethod");
function createLogger(parent, level) {
  var logger3 = Object.assign(parent.extend(level), {
    level
  });
  if (patchLogMethod(parent, logger3), shouldEnable(logger3)) {
    var enabledNamespaces2 = debug_default.disable();
    debug_default.enable(enabledNamespaces2 + "," + logger3.namespace);
  }
  return registeredLoggers.add(logger3), logger3;
}
__name(createLogger, "createLogger");
function shouldEnable(logger3) {
  return !!(azureLogLevel && levelMap[logger3.level] <= levelMap[azureLogLevel]);
}
__name(shouldEnable, "shouldEnable");
function isAzureLogLevel(logLevel) {
  return AZURE_LOG_LEVELS.includes(logLevel);
}
__name(isAzureLogLevel, "isAzureLogLevel");

// ../node_modules/@azure/core-http/es/src/log.js
var logger = createClientLogger("core-http");

// ../node_modules/@azure/core-http/es/src/policies/logPolicy.js
function logPolicy(loggingOptions) {
  return loggingOptions === void 0 && (loggingOptions = {}), {
    create: function(nextPolicy, options) {
      return new LogPolicy(nextPolicy, options, loggingOptions);
    }
  };
}
__name(logPolicy, "logPolicy");
var LogPolicy = function(_super) {
  __extends(LogPolicy2, _super);
  function LogPolicy2(nextPolicy, options, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.logger, logger3 = _c === void 0 ? logger.info : _c, _d = _b.allowedHeaderNames, allowedHeaderNames = _d === void 0 ? [] : _d, _e = _b.allowedQueryParameters, allowedQueryParameters = _e === void 0 ? [] : _e, _this = _super.call(this, nextPolicy, options) || this;
    return _this.logger = logger3, _this.sanitizer = new Sanitizer({allowedHeaderNames, allowedQueryParameters}), _this;
  }
  return __name(LogPolicy2, "LogPolicy"), Object.defineProperty(LogPolicy2.prototype, "allowedHeaderNames", {
    get: function() {
      return this.sanitizer.allowedHeaderNames;
    },
    set: function(allowedHeaderNames) {
      this.sanitizer.allowedHeaderNames = allowedHeaderNames;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(LogPolicy2.prototype, "allowedQueryParameters", {
    get: function() {
      return this.sanitizer.allowedQueryParameters;
    },
    set: function(allowedQueryParameters) {
      this.sanitizer.allowedQueryParameters = allowedQueryParameters;
    },
    enumerable: !1,
    configurable: !0
  }), LogPolicy2.prototype.sendRequest = function(request) {
    var _this = this;
    return this.logger.enabled ? (this.logRequest(request), this._nextPolicy.sendRequest(request).then(function(response) {
      return _this.logResponse(response);
    })) : this._nextPolicy.sendRequest(request);
  }, LogPolicy2.prototype.logRequest = function(request) {
    this.logger("Request: " + this.sanitizer.sanitize(request));
  }, LogPolicy2.prototype.logResponse = function(response) {
    return this.logger("Response status code: " + response.status), this.logger("Headers: " + this.sanitizer.sanitize(response.headers)), response;
  }, LogPolicy2;
}(BaseRequestPolicy);

// ../node_modules/@azure/core-http/es/src/operationParameter.js
function getPathStringFromParameter(parameter) {
  return getPathStringFromParameterPath(parameter.parameterPath, parameter.mapper);
}
__name(getPathStringFromParameter, "getPathStringFromParameter");
function getPathStringFromParameterPath(parameterPath, mapper) {
  var result;
  return typeof parameterPath == "string" ? result = parameterPath : Array.isArray(parameterPath) ? result = parameterPath.join(".") : result = mapper.serializedName, result;
}
__name(getPathStringFromParameterPath, "getPathStringFromParameterPath");

// ../node_modules/@azure/core-http/es/src/operationSpec.js
function isStreamOperation(operationSpec) {
  var result = !1;
  for (var statusCode in operationSpec.responses) {
    var operationResponse = operationSpec.responses[statusCode];
    if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === MapperType.Stream) {
      result = !0;
      break;
    }
  }
  return result;
}
__name(isStreamOperation, "isStreamOperation");

// ../node_modules/@azure/core-http/es/src/util/xml.js
var xml2js = __toModule(require_xml2js());
var xml2jsDefaultOptionsV2 = {
  explicitCharkey: !1,
  trim: !1,
  normalize: !1,
  normalizeTags: !1,
  attrkey: XML_ATTRKEY,
  explicitArray: !0,
  ignoreAttrs: !1,
  mergeAttrs: !1,
  explicitRoot: !0,
  validator: void 0,
  xmlns: !1,
  explicitChildren: !1,
  preserveChildrenOrder: !1,
  childkey: "$$",
  charsAsChildren: !1,
  includeWhiteChars: !1,
  async: !1,
  strict: !0,
  attrNameProcessors: void 0,
  attrValueProcessors: void 0,
  tagNameProcessors: void 0,
  valueProcessors: void 0,
  rootName: "root",
  xmldec: {
    version: "1.0",
    encoding: "UTF-8",
    standalone: !0
  },
  doctype: void 0,
  renderOpts: {
    pretty: !0,
    indent: "  ",
    newline: `
`
  },
  headless: !1,
  chunkSize: 1e4,
  emptyTag: "",
  cdata: !1
}, xml2jsParserSettings = Object.assign({}, xml2jsDefaultOptionsV2);
xml2jsParserSettings.explicitArray = !1;
var xml2jsBuilderSettings = Object.assign({}, xml2jsDefaultOptionsV2);
xml2jsBuilderSettings.explicitArray = !1;
xml2jsBuilderSettings.renderOpts = {
  pretty: !1
};
function stringifyXML(obj, opts) {
  var _a;
  opts === void 0 && (opts = {}), xml2jsBuilderSettings.rootName = opts.rootName, xml2jsBuilderSettings.charkey = (_a = opts.xmlCharKey) !== null && _a !== void 0 ? _a : XML_CHARKEY;
  var builder = new xml2js.Builder(xml2jsBuilderSettings);
  return builder.buildObject(obj);
}
__name(stringifyXML, "stringifyXML");
function parseXML(str, opts) {
  var _a;
  opts === void 0 && (opts = {}), xml2jsParserSettings.explicitRoot = !!opts.includeRoot, xml2jsParserSettings.charkey = (_a = opts.xmlCharKey) !== null && _a !== void 0 ? _a : XML_CHARKEY;
  var xmlParser = new xml2js.Parser(xml2jsParserSettings);
  return new Promise(function(resolve, reject) {
    str ? xmlParser.parseString(str, function(err, res) {
      err ? reject(err) : resolve(res);
    }) : reject(new Error("Document is empty"));
  });
}
__name(parseXML, "parseXML");

// ../node_modules/@azure/core-http/es/src/policies/deserializationPolicy.js
function deserializationPolicy(deserializationContentTypes, parsingOptions) {
  return {
    create: function(nextPolicy, options) {
      return new DeserializationPolicy(nextPolicy, options, deserializationContentTypes, parsingOptions);
    }
  };
}
__name(deserializationPolicy, "deserializationPolicy");
var defaultJsonContentTypes = ["application/json", "text/json"], defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
var DeserializationPolicy = function(_super) {
  __extends(DeserializationPolicy2, _super);
  function DeserializationPolicy2(nextPolicy, requestPolicyOptions, deserializationContentTypes, parsingOptions) {
    parsingOptions === void 0 && (parsingOptions = {});
    var _a, _this = _super.call(this, nextPolicy, requestPolicyOptions) || this;
    return _this.jsonContentTypes = deserializationContentTypes && deserializationContentTypes.json || defaultJsonContentTypes, _this.xmlContentTypes = deserializationContentTypes && deserializationContentTypes.xml || defaultXmlContentTypes, _this.xmlCharKey = (_a = parsingOptions.xmlCharKey) !== null && _a !== void 0 ? _a : XML_CHARKEY, _this;
  }
  return __name(DeserializationPolicy2, "DeserializationPolicy"), DeserializationPolicy2.prototype.sendRequest = function(request) {
    return __awaiter(this, void 0, void 0, function() {
      var _this = this;
      return __generator(this, function(_a) {
        return [2, this._nextPolicy.sendRequest(request).then(function(response) {
          return deserializeResponseBody(_this.jsonContentTypes, _this.xmlContentTypes, response, {
            xmlCharKey: _this.xmlCharKey
          });
        })];
      });
    });
  }, DeserializationPolicy2;
}(BaseRequestPolicy);
function getOperationResponse(parsedResponse) {
  var result, request = parsedResponse.request, operationSpec = request.operationSpec;
  if (operationSpec) {
    var operationResponseGetter = request.operationResponseGetter;
    operationResponseGetter ? result = operationResponseGetter(operationSpec, parsedResponse) : result = operationSpec.responses[parsedResponse.status];
  }
  return result;
}
__name(getOperationResponse, "getOperationResponse");
function shouldDeserializeResponse(parsedResponse) {
  var shouldDeserialize = parsedResponse.request.shouldDeserialize, result;
  return shouldDeserialize === void 0 ? result = !0 : typeof shouldDeserialize == "boolean" ? result = shouldDeserialize : result = shouldDeserialize(parsedResponse), result;
}
__name(shouldDeserializeResponse, "shouldDeserializeResponse");
function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options) {
  var _a, _b, _c;
  options === void 0 && (options = {});
  var updatedOptions = {
    rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : "",
    includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : !1,
    xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY
  };
  return parse(jsonContentTypes, xmlContentTypes, response, updatedOptions).then(function(parsedResponse) {
    if (!shouldDeserializeResponse(parsedResponse))
      return parsedResponse;
    var operationSpec = parsedResponse.request.operationSpec;
    if (!operationSpec || !operationSpec.responses)
      return parsedResponse;
    var responseSpec = getOperationResponse(parsedResponse), _a2 = handleErrorResponse(parsedResponse, operationSpec, responseSpec), error = _a2.error, shouldReturnResponse = _a2.shouldReturnResponse;
    if (error)
      throw error;
    if (shouldReturnResponse)
      return parsedResponse;
    if (responseSpec) {
      if (responseSpec.bodyMapper) {
        var valueToDeserialize = parsedResponse.parsedBody;
        operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperType.Sequence && (valueToDeserialize = typeof valueToDeserialize == "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : []);
        try {
          parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
        } catch (innerError) {
          var restError = new RestError("Error " + innerError + " occurred in deserializing the responseBody - " + parsedResponse.bodyAsText, void 0, parsedResponse.status, parsedResponse.request, parsedResponse);
          throw restError;
        }
      } else
        operationSpec.httpMethod === "HEAD" && (parsedResponse.parsedBody = response.status >= 200 && response.status < 300);
      responseSpec.headersMapper && (parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.rawHeaders(), "operationRes.parsedHeaders", options));
    }
    return parsedResponse;
  });
}
__name(deserializeResponseBody, "deserializeResponseBody");
function isOperationSpecEmpty(operationSpec) {
  var expectedStatusCodes = Object.keys(operationSpec.responses);
  return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
}
__name(isOperationSpecEmpty, "isOperationSpecEmpty");
function handleErrorResponse(parsedResponse, operationSpec, responseSpec) {
  var isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300, isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;
  if (isExpectedStatusCode)
    if (responseSpec) {
      if (!responseSpec.isError)
        return {error: null, shouldReturnResponse: !1};
    } else
      return {error: null, shouldReturnResponse: !1};
  var errorResponseSpec = responseSpec != null ? responseSpec : operationSpec.responses.default, initialErrorMessage = isStreamOperation(operationSpec) ? "Unexpected status code: " + parsedResponse.status : parsedResponse.bodyAsText, error = new RestError(initialErrorMessage, void 0, parsedResponse.status, parsedResponse.request, parsedResponse);
  if (!errorResponseSpec)
    throw error;
  var defaultBodyMapper = errorResponseSpec.bodyMapper, defaultHeadersMapper = errorResponseSpec.headersMapper;
  try {
    if (parsedResponse.parsedBody) {
      var parsedBody = parsedResponse.parsedBody, parsedError = void 0;
      if (defaultBodyMapper) {
        var valueToDeserialize = parsedBody;
        operationSpec.isXML && defaultBodyMapper.type.name === MapperType.Sequence && (valueToDeserialize = typeof parsedBody == "object" ? parsedBody[defaultBodyMapper.xmlElementName] : []), parsedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody");
      }
      var internalError = parsedBody.error || parsedError || parsedBody;
      error.code = internalError.code, internalError.message && (error.message = internalError.message), defaultBodyMapper && (error.response.parsedBody = parsedError);
    }
    parsedResponse.headers && defaultHeadersMapper && (error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.rawHeaders(), "operationRes.parsedHeaders"));
  } catch (defaultError) {
    error.message = 'Error "' + defaultError.message + '" occurred in deserializing the responseBody - "' + parsedResponse.bodyAsText + '" for the default response.';
  }
  return {error, shouldReturnResponse: !1};
}
__name(handleErrorResponse, "handleErrorResponse");
function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts) {
  var errorHandler = /* @__PURE__ */ __name(function(err) {
    var msg = 'Error "' + err + '" occurred while parsing the response body - ' + operationResponse.bodyAsText + ".", errCode = err.code || RestError.PARSE_ERROR, e = new RestError(msg, errCode, operationResponse.status, operationResponse.request, operationResponse);
    return Promise.reject(e);
  }, "errorHandler");
  if (!operationResponse.request.streamResponseBody && operationResponse.bodyAsText) {
    var text_1 = operationResponse.bodyAsText, contentType2 = operationResponse.headers.get("Content-Type") || "", contentComponents = contentType2 ? contentType2.split(";").map(function(component) {
      return component.toLowerCase();
    }) : [];
    if (contentComponents.length === 0 || contentComponents.some(function(component) {
      return jsonContentTypes.indexOf(component) !== -1;
    }))
      return new Promise(function(resolve) {
        operationResponse.parsedBody = JSON.parse(text_1), resolve(operationResponse);
      }).catch(errorHandler);
    if (contentComponents.some(function(component) {
      return xmlContentTypes.indexOf(component) !== -1;
    }))
      return parseXML(text_1, opts).then(function(body) {
        return operationResponse.parsedBody = body, operationResponse;
      }).catch(errorHandler);
  }
  return Promise.resolve(operationResponse);
}
__name(parse, "parse");

// ../node_modules/@azure/core-http/es/src/util/exponentialBackoffStrategy.js
var DEFAULT_CLIENT_RETRY_COUNT = 3, DEFAULT_CLIENT_RETRY_INTERVAL = 1e3 * 30, DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1e3 * 90, DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1e3 * 3;
function isNumber(n) {
  return typeof n == "number";
}
__name(isNumber, "isNumber");
function shouldRetry(retryLimit, predicate, retryData, response, error) {
  return predicate(response, error) ? retryData.retryCount < retryLimit : !1;
}
__name(shouldRetry, "shouldRetry");
function updateRetryData(retryOptions, retryData, err) {
  retryData === void 0 && (retryData = {retryCount: 0, retryInterval: 0}), err && (retryData.error && (err.innerError = retryData.error), retryData.error = err), retryData.retryCount++;
  var incrementDelta = Math.pow(2, retryData.retryCount - 1) - 1, boundedRandDelta = retryOptions.retryInterval * 0.8 + Math.floor(Math.random() * (retryOptions.retryInterval * 0.4));
  return incrementDelta *= boundedRandDelta, retryData.retryInterval = Math.min(retryOptions.minRetryInterval + incrementDelta, retryOptions.maxRetryInterval), retryData;
}
__name(updateRetryData, "updateRetryData");

// ../node_modules/@azure/core-http/es/src/policies/exponentialRetryPolicy.js
function exponentialRetryPolicy(retryCount, retryInterval, maxRetryInterval) {
  return {
    create: function(nextPolicy, options) {
      return new ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, maxRetryInterval);
    }
  };
}
__name(exponentialRetryPolicy, "exponentialRetryPolicy");
var RetryMode;
(function(RetryMode2) {
  RetryMode2[RetryMode2.Exponential = 0] = "Exponential";
})(RetryMode || (RetryMode = {}));
var ExponentialRetryPolicy = function(_super) {
  __extends(ExponentialRetryPolicy2, _super);
  function ExponentialRetryPolicy2(nextPolicy, options, retryCount, retryInterval, maxRetryInterval) {
    var _this = _super.call(this, nextPolicy, options) || this;
    return _this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT, _this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL, _this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : DEFAULT_CLIENT_MAX_RETRY_INTERVAL, _this;
  }
  return __name(ExponentialRetryPolicy2, "ExponentialRetryPolicy"), ExponentialRetryPolicy2.prototype.sendRequest = function(request) {
    var _this = this;
    return this._nextPolicy.sendRequest(request.clone()).then(function(response) {
      return retry(_this, request, response);
    }).catch(function(error) {
      return retry(_this, request, error.response, void 0, error);
    });
  }, ExponentialRetryPolicy2;
}(BaseRequestPolicy);
function retry(policy, request, response, retryData, requestError) {
  return __awaiter(this, void 0, void 0, function() {
    function shouldPolicyRetry(responseParam) {
      var statusCode = responseParam == null ? void 0 : responseParam.status;
      return !(statusCode === void 0 || statusCode < 500 && statusCode !== 408 || statusCode === 501 || statusCode === 505);
    }
    __name(shouldPolicyRetry, "shouldPolicyRetry");
    var isAborted, res, err_1, err;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          if (retryData = updateRetryData({
            retryInterval: policy.retryInterval,
            minRetryInterval: 0,
            maxRetryInterval: policy.maxRetryInterval
          }, retryData, requestError), isAborted = request.abortSignal && request.abortSignal.aborted, !(!isAborted && shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, response)))
            return [3, 6];
          logger.info("Retrying request in " + retryData.retryInterval), _a.label = 1;
        case 1:
          return _a.trys.push([1, 4, , 5]), [4, delay(retryData.retryInterval)];
        case 2:
          return _a.sent(), [4, policy._nextPolicy.sendRequest(request.clone())];
        case 3:
          return res = _a.sent(), [2, retry(policy, request, res, retryData)];
        case 4:
          return err_1 = _a.sent(), [2, retry(policy, request, response, retryData, err_1)];
        case 5:
          return [3, 7];
        case 6:
          if (isAborted || requestError || !response)
            throw err = retryData.error || new RestError("Failed to send the request.", RestError.REQUEST_SEND_ERROR, response && response.status, response && response.request, response), err;
          return [2, response];
          _a.label = 7;
        case 7:
          return [2];
      }
    });
  });
}
__name(retry, "retry");

// ../node_modules/@azure/core-http/es/src/policies/generateClientRequestIdPolicy.js
function generateClientRequestIdPolicy(requestIdHeaderName) {
  return requestIdHeaderName === void 0 && (requestIdHeaderName = "x-ms-client-request-id"), {
    create: function(nextPolicy, options) {
      return new GenerateClientRequestIdPolicy(nextPolicy, options, requestIdHeaderName);
    }
  };
}
__name(generateClientRequestIdPolicy, "generateClientRequestIdPolicy");
var GenerateClientRequestIdPolicy = function(_super) {
  __extends(GenerateClientRequestIdPolicy2, _super);
  function GenerateClientRequestIdPolicy2(nextPolicy, options, _requestIdHeaderName) {
    var _this = _super.call(this, nextPolicy, options) || this;
    return _this._requestIdHeaderName = _requestIdHeaderName, _this;
  }
  return __name(GenerateClientRequestIdPolicy2, "GenerateClientRequestIdPolicy"), GenerateClientRequestIdPolicy2.prototype.sendRequest = function(request) {
    return request.headers.contains(this._requestIdHeaderName) || request.headers.set(this._requestIdHeaderName, request.requestId), this._nextPolicy.sendRequest(request);
  }, GenerateClientRequestIdPolicy2;
}(BaseRequestPolicy);

// ../node_modules/@azure/core-http/es/src/policies/msRestUserAgentPolicy.js
var os = __toModule(require("os"));
function getDefaultUserAgentKey() {
  return Constants.HeaderConstants.USER_AGENT;
}
__name(getDefaultUserAgentKey, "getDefaultUserAgentKey");
function getPlatformSpecificData() {
  var runtimeInfo = {
    key: "Node",
    value: process.version
  }, osInfo = {
    key: "OS",
    value: "(" + os.arch() + "-" + os.type() + "-" + os.release() + ")"
  };
  return [runtimeInfo, osInfo];
}
__name(getPlatformSpecificData, "getPlatformSpecificData");

// ../node_modules/@azure/core-http/es/src/policies/userAgentPolicy.js
function getRuntimeInfo() {
  var msRestRuntime = {
    key: "core-http",
    value: Constants.coreHttpVersion
  };
  return [msRestRuntime];
}
__name(getRuntimeInfo, "getRuntimeInfo");
function getUserAgentString(telemetryInfo, keySeparator, valueSeparator) {
  return keySeparator === void 0 && (keySeparator = " "), valueSeparator === void 0 && (valueSeparator = "/"), telemetryInfo.map(function(info2) {
    var value = info2.value ? "" + valueSeparator + info2.value : "";
    return "" + info2.key + value;
  }).join(keySeparator);
}
__name(getUserAgentString, "getUserAgentString");
var getDefaultUserAgentHeaderName = getDefaultUserAgentKey;
function getDefaultUserAgentValue() {
  var runtimeInfo = getRuntimeInfo(), platformSpecificData = getPlatformSpecificData(), userAgent = getUserAgentString(runtimeInfo.concat(platformSpecificData));
  return userAgent;
}
__name(getDefaultUserAgentValue, "getDefaultUserAgentValue");
function userAgentPolicy(userAgentData) {
  var key = !userAgentData || userAgentData.key === void 0 || userAgentData.key === null ? getDefaultUserAgentKey() : userAgentData.key, value = !userAgentData || userAgentData.value === void 0 || userAgentData.value === null ? getDefaultUserAgentValue() : userAgentData.value;
  return {
    create: function(nextPolicy, options) {
      return new UserAgentPolicy(nextPolicy, options, key, value);
    }
  };
}
__name(userAgentPolicy, "userAgentPolicy");
var UserAgentPolicy = function(_super) {
  __extends(UserAgentPolicy2, _super);
  function UserAgentPolicy2(_nextPolicy, _options, headerKey, headerValue) {
    var _this = _super.call(this, _nextPolicy, _options) || this;
    return _this._nextPolicy = _nextPolicy, _this._options = _options, _this.headerKey = headerKey, _this.headerValue = headerValue, _this;
  }
  return __name(UserAgentPolicy2, "UserAgentPolicy"), UserAgentPolicy2.prototype.sendRequest = function(request) {
    return this.addUserAgentHeader(request), this._nextPolicy.sendRequest(request);
  }, UserAgentPolicy2.prototype.addUserAgentHeader = function(request) {
    request.headers || (request.headers = new HttpHeaders()), !request.headers.get(this.headerKey) && this.headerValue && request.headers.set(this.headerKey, this.headerValue);
  }, UserAgentPolicy2;
}(BaseRequestPolicy);

// ../node_modules/@azure/core-http/es/src/policies/redirectPolicy.js
var allowedRedirect = ["GET", "HEAD"];
function redirectPolicy(maximumRetries) {
  return maximumRetries === void 0 && (maximumRetries = 20), {
    create: function(nextPolicy, options) {
      return new RedirectPolicy(nextPolicy, options, maximumRetries);
    }
  };
}
__name(redirectPolicy, "redirectPolicy");
var RedirectPolicy = function(_super) {
  __extends(RedirectPolicy2, _super);
  function RedirectPolicy2(nextPolicy, options, maxRetries) {
    maxRetries === void 0 && (maxRetries = 20);
    var _this = _super.call(this, nextPolicy, options) || this;
    return _this.maxRetries = maxRetries, _this;
  }
  return __name(RedirectPolicy2, "RedirectPolicy"), RedirectPolicy2.prototype.sendRequest = function(request) {
    var _this = this;
    return this._nextPolicy.sendRequest(request).then(function(response) {
      return handleRedirect(_this, response, 0);
    });
  }, RedirectPolicy2;
}(BaseRequestPolicy);
function handleRedirect(policy, response, currentRetries) {
  var request = response.request, status = response.status, locationHeader = response.headers.get("location");
  if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request.method) || status === 302 && allowedRedirect.includes(request.method) || status === 303 && request.method === "POST" || status === 307) && (!policy.maxRetries || currentRetries < policy.maxRetries)) {
    var builder = URLBuilder.parse(request.url);
    return builder.setPath(locationHeader), request.url = builder.toString(), status === 303 && (request.method = "GET", delete request.body), policy._nextPolicy.sendRequest(request).then(function(res) {
      return handleRedirect(policy, res, currentRetries + 1);
    });
  }
  return Promise.resolve(response);
}
__name(handleRedirect, "handleRedirect");

// ../node_modules/@azure/core-http/es/src/policies/rpRegistrationPolicy.js
function rpRegistrationPolicy(retryTimeout) {
  return retryTimeout === void 0 && (retryTimeout = 30), {
    create: function(nextPolicy, options) {
      return new RPRegistrationPolicy(nextPolicy, options, retryTimeout);
    }
  };
}
__name(rpRegistrationPolicy, "rpRegistrationPolicy");
var RPRegistrationPolicy = function(_super) {
  __extends(RPRegistrationPolicy2, _super);
  function RPRegistrationPolicy2(nextPolicy, options, _retryTimeout) {
    _retryTimeout === void 0 && (_retryTimeout = 30);
    var _this = _super.call(this, nextPolicy, options) || this;
    return _this._retryTimeout = _retryTimeout, _this;
  }
  return __name(RPRegistrationPolicy2, "RPRegistrationPolicy"), RPRegistrationPolicy2.prototype.sendRequest = function(request) {
    var _this = this;
    return this._nextPolicy.sendRequest(request.clone()).then(function(response) {
      return registerIfNeeded(_this, request, response);
    });
  }, RPRegistrationPolicy2;
}(BaseRequestPolicy);
function registerIfNeeded(policy, request, response) {
  if (response.status === 409) {
    var rpName = checkRPNotRegisteredError(response.bodyAsText);
    if (rpName) {
      var urlPrefix = extractSubscriptionUrl(request.url);
      return registerRP(policy, urlPrefix, rpName, request).catch(function() {
        return !1;
      }).then(function(registrationStatus) {
        return registrationStatus ? (request.headers.set("x-ms-client-request-id", generateUuid()), policy._nextPolicy.sendRequest(request.clone())) : response;
      });
    }
  }
  return Promise.resolve(response);
}
__name(registerIfNeeded, "registerIfNeeded");
function getRequestEssentials(originalRequest, reuseUrlToo) {
  reuseUrlToo === void 0 && (reuseUrlToo = !1);
  var reqOptions = originalRequest.clone();
  return reuseUrlToo && (reqOptions.url = originalRequest.url), reqOptions.headers.set("x-ms-client-request-id", generateUuid()), reqOptions.headers.set("Content-Type", "application/json; charset=utf-8"), reqOptions;
}
__name(getRequestEssentials, "getRequestEssentials");
function checkRPNotRegisteredError(body) {
  var result, responseBody;
  if (body) {
    try {
      responseBody = JSON.parse(body);
    } catch (err) {
    }
    if (responseBody && responseBody.error && responseBody.error.message && responseBody.error.code && responseBody.error.code === "MissingSubscriptionRegistration") {
      var matchRes = responseBody.error.message.match(/.*'(.*)'/i);
      matchRes && (result = matchRes.pop());
    }
  }
  return result;
}
__name(checkRPNotRegisteredError, "checkRPNotRegisteredError");
function extractSubscriptionUrl(url2) {
  var result, matchRes = url2.match(/.*\/subscriptions\/[a-f0-9-]+\//gi);
  if (matchRes && matchRes[0])
    result = matchRes[0];
  else
    throw new Error("Unable to extract subscriptionId from the given url - " + url2 + ".");
  return result;
}
__name(extractSubscriptionUrl, "extractSubscriptionUrl");
function registerRP(policy, urlPrefix, provider, originalRequest) {
  var postUrl = urlPrefix + "providers/" + provider + "/register?api-version=2016-02-01", getUrl = urlPrefix + "providers/" + provider + "?api-version=2016-02-01", reqOptions = getRequestEssentials(originalRequest);
  return reqOptions.method = "POST", reqOptions.url = postUrl, policy._nextPolicy.sendRequest(reqOptions).then(function(response) {
    if (response.status !== 200)
      throw new Error("Autoregistration of " + provider + " failed. Please try registering manually.");
    return getRegistrationStatus(policy, getUrl, originalRequest);
  });
}
__name(registerRP, "registerRP");
function getRegistrationStatus(policy, url2, originalRequest) {
  var reqOptions = getRequestEssentials(originalRequest);
  return reqOptions.url = url2, reqOptions.method = "GET", policy._nextPolicy.sendRequest(reqOptions).then(function(res) {
    var obj = res.parsedBody;
    return res.parsedBody && obj.registrationState && obj.registrationState === "Registered" ? !0 : delay(policy._retryTimeout * 1e3).then(function() {
      return getRegistrationStatus(policy, url2, originalRequest);
    });
  });
}
__name(getRegistrationStatus, "getRegistrationStatus");

// ../node_modules/@azure/core-http/es/src/credentials/accessTokenCache.js
var TokenRefreshBufferMs = 2 * 60 * 1e3, ExpiringAccessTokenCache = function() {
  function ExpiringAccessTokenCache2(tokenRefreshBufferMs) {
    tokenRefreshBufferMs === void 0 && (tokenRefreshBufferMs = TokenRefreshBufferMs), this.cachedToken = void 0, this.tokenRefreshBufferMs = tokenRefreshBufferMs;
  }
  return __name(ExpiringAccessTokenCache2, "ExpiringAccessTokenCache"), ExpiringAccessTokenCache2.prototype.setCachedToken = function(accessToken) {
    this.cachedToken = accessToken;
  }, ExpiringAccessTokenCache2.prototype.getCachedToken = function() {
    return this.cachedToken && Date.now() + this.tokenRefreshBufferMs >= this.cachedToken.expiresOnTimestamp && (this.cachedToken = void 0), this.cachedToken;
  }, ExpiringAccessTokenCache2;
}();

// ../node_modules/@azure/core-http/es/src/credentials/accessTokenRefresher.js
var AccessTokenRefresher = function() {
  function AccessTokenRefresher2(credential, scopes, requiredMillisecondsBeforeNewRefresh) {
    requiredMillisecondsBeforeNewRefresh === void 0 && (requiredMillisecondsBeforeNewRefresh = 3e4), this.credential = credential, this.scopes = scopes, this.requiredMillisecondsBeforeNewRefresh = requiredMillisecondsBeforeNewRefresh, this.lastCalled = 0;
  }
  return __name(AccessTokenRefresher2, "AccessTokenRefresher"), AccessTokenRefresher2.prototype.isReady = function() {
    return !this.lastCalled || Date.now() - this.lastCalled > this.requiredMillisecondsBeforeNewRefresh;
  }, AccessTokenRefresher2.prototype.getToken = function(options) {
    return __awaiter(this, void 0, void 0, function() {
      var token;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return this.lastCalled = Date.now(), [4, this.credential.getToken(this.scopes, options)];
          case 1:
            return token = _a.sent(), this.promise = void 0, [2, token || void 0];
        }
      });
    });
  }, AccessTokenRefresher2.prototype.refresh = function(options) {
    return this.promise || (this.promise = this.getToken(options)), this.promise;
  }, AccessTokenRefresher2;
}();

// ../node_modules/@azure/core-http/es/src/policies/bearerTokenAuthenticationPolicy.js
var timeBetweenRefreshAttemptsInMs = 3e4;
function bearerTokenAuthenticationPolicy(credential, scopes) {
  var tokenCache = new ExpiringAccessTokenCache(), tokenRefresher = new AccessTokenRefresher(credential, scopes, timeBetweenRefreshAttemptsInMs);
  return {
    create: function(nextPolicy, options) {
      return new BearerTokenAuthenticationPolicy(nextPolicy, options, tokenCache, tokenRefresher);
    }
  };
}
__name(bearerTokenAuthenticationPolicy, "bearerTokenAuthenticationPolicy");
var BearerTokenAuthenticationPolicy = function(_super) {
  __extends(BearerTokenAuthenticationPolicy2, _super);
  function BearerTokenAuthenticationPolicy2(nextPolicy, options, tokenCache, tokenRefresher) {
    var _this = _super.call(this, nextPolicy, options) || this;
    return _this.tokenCache = tokenCache, _this.tokenRefresher = tokenRefresher, _this;
  }
  return __name(BearerTokenAuthenticationPolicy2, "BearerTokenAuthenticationPolicy"), BearerTokenAuthenticationPolicy2.prototype.sendRequest = function(webResource) {
    return __awaiter(this, void 0, void 0, function() {
      var token;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return webResource.headers || (webResource.headers = new HttpHeaders()), [4, this.getToken({
              abortSignal: webResource.abortSignal,
              tracingOptions: {
                spanOptions: webResource.spanOptions
              }
            })];
          case 1:
            return token = _a.sent(), webResource.headers.set(Constants.HeaderConstants.AUTHORIZATION, "Bearer " + token), [2, this._nextPolicy.sendRequest(webResource)];
        }
      });
    });
  }, BearerTokenAuthenticationPolicy2.prototype.updateTokenIfNeeded = function(options) {
    return __awaiter(this, void 0, void 0, function() {
      var accessToken;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return this.tokenRefresher.isReady() ? [4, this.tokenRefresher.refresh(options)] : [3, 2];
          case 1:
            accessToken = _a.sent(), this.tokenCache.setCachedToken(accessToken), _a.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, BearerTokenAuthenticationPolicy2.prototype.getToken = function(options) {
    return __awaiter(this, void 0, void 0, function() {
      var accessToken;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return accessToken = this.tokenCache.getCachedToken(), accessToken !== void 0 ? [3, 2] : [4, this.tokenRefresher.refresh(options)];
          case 1:
            return accessToken = _a.sent(), this.tokenCache.setCachedToken(accessToken), [3, 3];
          case 2:
            this.updateTokenIfNeeded(options), _a.label = 3;
          case 3:
            return [2, accessToken ? accessToken.token : void 0];
        }
      });
    });
  }, BearerTokenAuthenticationPolicy2;
}(BaseRequestPolicy);

// ../node_modules/@azure/core-http/es/src/policies/systemErrorRetryPolicy.js
function systemErrorRetryPolicy(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {
  return {
    create: function(nextPolicy, options) {
      return new SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval);
    }
  };
}
__name(systemErrorRetryPolicy, "systemErrorRetryPolicy");
var SystemErrorRetryPolicy = function(_super) {
  __extends(SystemErrorRetryPolicy2, _super);
  function SystemErrorRetryPolicy2(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval) {
    var _this = _super.call(this, nextPolicy, options) || this;
    return _this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT, _this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL, _this.minRetryInterval = isNumber(minRetryInterval) ? minRetryInterval : DEFAULT_CLIENT_MIN_RETRY_INTERVAL, _this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : DEFAULT_CLIENT_MAX_RETRY_INTERVAL, _this;
  }
  return __name(SystemErrorRetryPolicy2, "SystemErrorRetryPolicy"), SystemErrorRetryPolicy2.prototype.sendRequest = function(request) {
    var _this = this;
    return this._nextPolicy.sendRequest(request.clone()).catch(function(error) {
      return retry2(_this, request, error.response, error);
    });
  }, SystemErrorRetryPolicy2;
}(BaseRequestPolicy);
function retry2(policy, request, operationResponse, err, retryData) {
  return __awaiter(this, void 0, void 0, function() {
    function shouldPolicyRetry(_response, error) {
      return !!(error && error.code && (error.code === "ETIMEDOUT" || error.code === "ESOCKETTIMEDOUT" || error.code === "ECONNREFUSED" || error.code === "ECONNRESET" || error.code === "ENOENT"));
    }
    __name(shouldPolicyRetry, "shouldPolicyRetry");
    var nestedErr_1;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          if (retryData = updateRetryData(policy, retryData, err), !shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, operationResponse, err))
            return [3, 5];
          _a.label = 1;
        case 1:
          return _a.trys.push([1, 3, , 4]), [4, delay(retryData.retryInterval)];
        case 2:
          return _a.sent(), [2, policy._nextPolicy.sendRequest(request.clone())];
        case 3:
          return nestedErr_1 = _a.sent(), [2, retry2(policy, request, operationResponse, nestedErr_1, retryData)];
        case 4:
          return [3, 6];
        case 5:
          return err ? [2, Promise.reject(retryData.error)] : [2, operationResponse];
        case 6:
          return [2];
      }
    });
  });
}
__name(retry2, "retry");

// ../node_modules/@azure/core-http/es/src/queryCollectionFormat.js
var QueryCollectionFormat;
(function(QueryCollectionFormat2) {
  QueryCollectionFormat2.Csv = ",", QueryCollectionFormat2.Ssv = " ", QueryCollectionFormat2.Tsv = "	", QueryCollectionFormat2.Pipes = "|", QueryCollectionFormat2.Multi = "Multi";
})(QueryCollectionFormat || (QueryCollectionFormat = {}));

// ../node_modules/@azure/core-http/es/src/policies/proxyPolicy.js
var noProxyList = [], isNoProxyInitalized = !1, byPassedList = new Map();
function loadEnvironmentProxyValue() {
  if (!!process) {
    var httpsProxy = getEnvironmentValue(Constants.HTTPS_PROXY), allProxy = getEnvironmentValue(Constants.ALL_PROXY), httpProxy = getEnvironmentValue(Constants.HTTP_PROXY);
    return httpsProxy || allProxy || httpProxy;
  }
}
__name(loadEnvironmentProxyValue, "loadEnvironmentProxyValue");
function isBypassed(uri) {
  if (byPassedList.has(uri))
    return byPassedList.get(uri);
  loadNoProxy();
  for (var isBypassedFlag = !1, host = URLBuilder.parse(uri).getHost(), _i = 0, noProxyList_1 = noProxyList; _i < noProxyList_1.length; _i++) {
    var proxyString = noProxyList_1[_i];
    proxyString[0] === "." ? (uri.endsWith(proxyString) || host === proxyString.slice(1) && host.length === proxyString.length - 1) && (isBypassedFlag = !0) : host === proxyString && (isBypassedFlag = !0);
  }
  return byPassedList.set(uri, isBypassedFlag), isBypassedFlag;
}
__name(isBypassed, "isBypassed");
function loadNoProxy() {
  if (!isNoProxyInitalized) {
    var noProxy = getEnvironmentValue(Constants.NO_PROXY);
    if (noProxy) {
      var list = noProxy.split(",");
      noProxyList = list.map(function(item) {
        return item.trim();
      }).filter(function(item) {
        return item.length;
      });
    }
    isNoProxyInitalized = !0;
  }
}
__name(loadNoProxy, "loadNoProxy");
function getDefaultProxySettings(proxyUrl) {
  if (!(!proxyUrl && (proxyUrl = loadEnvironmentProxyValue(), !proxyUrl))) {
    var _a = extractAuthFromUrl(proxyUrl), username = _a.username, password = _a.password, urlWithoutAuth = _a.urlWithoutAuth, parsedUrl = URLBuilder.parse(urlWithoutAuth), schema = parsedUrl.getScheme() ? parsedUrl.getScheme() + "://" : "";
    return {
      host: schema + parsedUrl.getHost(),
      port: Number.parseInt(parsedUrl.getPort() || "80"),
      username,
      password
    };
  }
}
__name(getDefaultProxySettings, "getDefaultProxySettings");
function proxyPolicy(proxySettings) {
  return proxySettings || (proxySettings = getDefaultProxySettings()), {
    create: function(nextPolicy, options) {
      return new ProxyPolicy(nextPolicy, options, proxySettings);
    }
  };
}
__name(proxyPolicy, "proxyPolicy");
function extractAuthFromUrl(url2) {
  var atIndex = url2.indexOf("@");
  if (atIndex === -1)
    return {urlWithoutAuth: url2};
  var schemeIndex = url2.indexOf("://"), authStart = schemeIndex !== -1 ? schemeIndex + 3 : 0, auth = url2.substring(authStart, atIndex), colonIndex = auth.indexOf(":"), hasPassword = colonIndex !== -1, username = hasPassword ? auth.substring(0, colonIndex) : auth, password = hasPassword ? auth.substring(colonIndex + 1) : void 0, urlWithoutAuth = url2.substring(0, authStart) + url2.substring(atIndex + 1);
  return {
    username,
    password,
    urlWithoutAuth
  };
}
__name(extractAuthFromUrl, "extractAuthFromUrl");
var ProxyPolicy = function(_super) {
  __extends(ProxyPolicy2, _super);
  function ProxyPolicy2(nextPolicy, options, proxySettings) {
    var _this = _super.call(this, nextPolicy, options) || this;
    return _this.proxySettings = proxySettings, _this;
  }
  return __name(ProxyPolicy2, "ProxyPolicy"), ProxyPolicy2.prototype.sendRequest = function(request) {
    return !request.proxySettings && !isBypassed(request.url) && (request.proxySettings = this.proxySettings), this._nextPolicy.sendRequest(request);
  }, ProxyPolicy2;
}(BaseRequestPolicy);

// ../node_modules/@azure/core-http/es/src/policies/throttlingRetryPolicy.js
var StatusCodes = Constants.HttpConstants.StatusCodes;
function throttlingRetryPolicy() {
  return {
    create: function(nextPolicy, options) {
      return new ThrottlingRetryPolicy(nextPolicy, options);
    }
  };
}
__name(throttlingRetryPolicy, "throttlingRetryPolicy");
var ThrottlingRetryPolicy = function(_super) {
  __extends(ThrottlingRetryPolicy2, _super);
  function ThrottlingRetryPolicy2(nextPolicy, options, _handleResponse) {
    var _this = _super.call(this, nextPolicy, options) || this;
    return _this._handleResponse = _handleResponse || _this._defaultResponseHandler, _this;
  }
  return __name(ThrottlingRetryPolicy2, "ThrottlingRetryPolicy"), ThrottlingRetryPolicy2.prototype.sendRequest = function(httpRequest) {
    return __awaiter(this, void 0, void 0, function() {
      var _this = this;
      return __generator(this, function(_a) {
        return [2, this._nextPolicy.sendRequest(httpRequest.clone()).then(function(response) {
          return response.status !== StatusCodes.TooManyRequests ? response : _this._handleResponse(httpRequest, response);
        })];
      });
    });
  }, ThrottlingRetryPolicy2.prototype._defaultResponseHandler = function(httpRequest, httpResponse) {
    return __awaiter(this, void 0, void 0, function() {
      var retryAfterHeader, delayInMs, _this = this;
      return __generator(this, function(_a) {
        return retryAfterHeader = httpResponse.headers.get(Constants.HeaderConstants.RETRY_AFTER), retryAfterHeader && (delayInMs = ThrottlingRetryPolicy2.parseRetryAfterHeader(retryAfterHeader), delayInMs) ? [2, delay(delayInMs).then(function(_) {
          return _this._nextPolicy.sendRequest(httpRequest);
        })] : [2, httpResponse];
      });
    });
  }, ThrottlingRetryPolicy2.parseRetryAfterHeader = function(headerValue) {
    var retryAfterInSeconds = Number(headerValue);
    return Number.isNaN(retryAfterInSeconds) ? ThrottlingRetryPolicy2.parseDateRetryAfterHeader(headerValue) : retryAfterInSeconds * 1e3;
  }, ThrottlingRetryPolicy2.parseDateRetryAfterHeader = function(headerValue) {
    try {
      var now = Date.now(), date = Date.parse(headerValue), diff = date - now;
      return Number.isNaN(diff) ? void 0 : diff;
    } catch (error) {
      return;
    }
  }, ThrottlingRetryPolicy2;
}(BaseRequestPolicy);

// ../node_modules/@azure/core-http/es/src/policies/signingPolicy.js
function signingPolicy(authenticationProvider) {
  return {
    create: function(nextPolicy, options) {
      return new SigningPolicy(nextPolicy, options, authenticationProvider);
    }
  };
}
__name(signingPolicy, "signingPolicy");
var SigningPolicy = function(_super) {
  __extends(SigningPolicy2, _super);
  function SigningPolicy2(nextPolicy, options, authenticationProvider) {
    var _this = _super.call(this, nextPolicy, options) || this;
    return _this.authenticationProvider = authenticationProvider, _this;
  }
  return __name(SigningPolicy2, "SigningPolicy"), SigningPolicy2.prototype.signRequest = function(request) {
    return this.authenticationProvider.signRequest(request);
  }, SigningPolicy2.prototype.sendRequest = function(request) {
    var _this = this;
    return this.signRequest(request).then(function(nextRequest) {
      return _this._nextPolicy.sendRequest(nextRequest);
    });
  }, SigningPolicy2;
}(BaseRequestPolicy);

// ../node_modules/@azure/core-http/es/src/policies/keepAlivePolicy.js
var DefaultKeepAliveOptions = {
  enable: !0
};
function keepAlivePolicy(keepAliveOptions) {
  return {
    create: function(nextPolicy, options) {
      return new KeepAlivePolicy(nextPolicy, options, keepAliveOptions || DefaultKeepAliveOptions);
    }
  };
}
__name(keepAlivePolicy, "keepAlivePolicy");
var KeepAlivePolicy = function(_super) {
  __extends(KeepAlivePolicy2, _super);
  function KeepAlivePolicy2(nextPolicy, options, keepAliveOptions) {
    var _this = _super.call(this, nextPolicy, options) || this;
    return _this.keepAliveOptions = keepAliveOptions, _this;
  }
  return __name(KeepAlivePolicy2, "KeepAlivePolicy"), KeepAlivePolicy2.prototype.sendRequest = function(request) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        return request.keepAlive = this.keepAliveOptions.enable, [2, this._nextPolicy.sendRequest(request)];
      });
    });
  }, KeepAlivePolicy2;
}(BaseRequestPolicy);

// ../node_modules/@azure/core-tracing/dist-esm/src/tracers/noop/noOpSpan.js
var import_api = __toModule(require_src2()), NoOpSpan = function() {
  function NoOpSpan2() {
  }
  return __name(NoOpSpan2, "NoOpSpan"), NoOpSpan2.prototype.context = function() {
    return {
      spanId: "",
      traceId: "",
      traceFlags: import_api.TraceFlags.NONE
    };
  }, NoOpSpan2.prototype.end = function(_endTime) {
  }, NoOpSpan2.prototype.setAttribute = function(_key, _value) {
    return this;
  }, NoOpSpan2.prototype.setAttributes = function(_attributes) {
    return this;
  }, NoOpSpan2.prototype.addEvent = function(_name, _attributes) {
    return this;
  }, NoOpSpan2.prototype.setStatus = function(_status) {
    return this;
  }, NoOpSpan2.prototype.updateName = function(_name) {
    return this;
  }, NoOpSpan2.prototype.isRecording = function() {
    return !1;
  }, NoOpSpan2;
}();

// ../node_modules/@azure/core-tracing/dist-esm/src/tracers/noop/noOpTracer.js
var NoOpTracer = function() {
  function NoOpTracer2() {
  }
  return __name(NoOpTracer2, "NoOpTracer"), NoOpTracer2.prototype.startSpan = function(_name, _options) {
    return new NoOpSpan();
  }, NoOpTracer2.prototype.getCurrentSpan = function() {
    return new NoOpSpan();
  }, NoOpTracer2.prototype.withSpan = function(_span, fn) {
    return fn();
  }, NoOpTracer2.prototype.bind = function(target, _span) {
    return target;
  }, NoOpTracer2;
}();

// ../node_modules/@azure/core-tracing/dist-esm/src/utils/global.js
function getGlobalObject() {
  return global;
}
__name(getGlobalObject, "getGlobalObject");

// ../node_modules/@azure/core-tracing/dist-esm/src/utils/cache.js
var GLOBAL_TRACER_VERSION = 3, GLOBAL_TRACER_SYMBOL = Symbol.for("@azure/core-tracing.tracerCache2"), cache;
function loadTracerCache() {
  var globalObj = getGlobalObject(), existingCache = globalObj[GLOBAL_TRACER_SYMBOL], setGlobalCache = !0;
  if (existingCache) {
    if (existingCache.version === GLOBAL_TRACER_VERSION)
      cache = existingCache;
    else if (setGlobalCache = !1, existingCache.tracer)
      throw new Error(`Two incompatible versions of @azure/core-tracing have been loaded.
          This library is ` + GLOBAL_TRACER_VERSION + ", existing is " + existingCache.version + ".");
  }
  cache || (cache = {
    tracer: void 0,
    version: GLOBAL_TRACER_VERSION
  }), setGlobalCache && (globalObj[GLOBAL_TRACER_SYMBOL] = cache);
}
__name(loadTracerCache, "loadTracerCache");
function getCache() {
  return cache || loadTracerCache(), cache;
}
__name(getCache, "getCache");

// ../node_modules/@azure/core-tracing/dist-esm/src/tracerProxy.js
var defaultTracer;
function getDefaultTracer() {
  return defaultTracer || (defaultTracer = new NoOpTracer()), defaultTracer;
}
__name(getDefaultTracer, "getDefaultTracer");
function getTracer() {
  var cache2 = getCache();
  return cache2.tracer ? cache2.tracer : getDefaultTracer();
}
__name(getTracer, "getTracer");

// ../node_modules/@azure/core-tracing/dist-esm/src/utils/traceParentHeader.js
var VERSION = "00";
function getTraceParentHeader(spanContext) {
  var missingFields = [];
  if (spanContext.traceId || missingFields.push("traceId"), spanContext.spanId || missingFields.push("spanId"), !missingFields.length) {
    var flags = spanContext.traceFlags || 0, hexFlags = flags.toString(16), traceFlags = hexFlags.length === 1 ? "0" + hexFlags : hexFlags;
    return VERSION + "-" + spanContext.traceId + "-" + spanContext.spanId + "-" + traceFlags;
  }
}
__name(getTraceParentHeader, "getTraceParentHeader");

// ../node_modules/@azure/core-http/es/src/policies/tracingPolicy.js
var import_api2 = __toModule(require_src2());
function tracingPolicy(tracingOptions) {
  return tracingOptions === void 0 && (tracingOptions = {}), {
    create: function(nextPolicy, options) {
      return new TracingPolicy(nextPolicy, options, tracingOptions);
    }
  };
}
__name(tracingPolicy, "tracingPolicy");
var TracingPolicy = function(_super) {
  __extends(TracingPolicy2, _super);
  function TracingPolicy2(nextPolicy, options, tracingOptions) {
    var _this = _super.call(this, nextPolicy, options) || this;
    return _this.userAgent = tracingOptions.userAgent, _this;
  }
  return __name(TracingPolicy2, "TracingPolicy"), TracingPolicy2.prototype.sendRequest = function(request) {
    return __awaiter(this, void 0, void 0, function() {
      var tracer, spanOptions, path3, span, spanContext, traceParentHeader, traceState, response, serviceRequestId, err_1;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!request.spanOptions || !request.spanOptions.parent)
              return [2, this._nextPolicy.sendRequest(request)];
            tracer = getTracer(), spanOptions = __assign(__assign({}, request.spanOptions), {kind: import_api2.SpanKind.CLIENT}), path3 = URLBuilder.parse(request.url).getPath() || "/", span = tracer.startSpan(path3, spanOptions), span.setAttributes({
              "http.method": request.method,
              "http.url": request.url,
              requestId: request.requestId
            }), this.userAgent && span.setAttribute("http.user_agent", this.userAgent), _a.label = 1;
          case 1:
            return _a.trys.push([1, 3, , 4]), spanContext = span.context(), traceParentHeader = getTraceParentHeader(spanContext), traceParentHeader && (request.headers.set("traceparent", traceParentHeader), traceState = spanContext.traceState && spanContext.traceState.serialize(), traceState && request.headers.set("tracestate", traceState)), [4, this._nextPolicy.sendRequest(request)];
          case 2:
            return response = _a.sent(), span.setAttribute("http.status_code", response.status), serviceRequestId = response.headers.get("x-ms-request-id"), serviceRequestId && span.setAttribute("serviceRequestId", serviceRequestId), span.end(), [2, response];
          case 3:
            throw err_1 = _a.sent(), span.end(), err_1;
          case 4:
            return [2];
        }
      });
    });
  }, TracingPolicy2;
}(BaseRequestPolicy);

// ../node_modules/@azure/core-http/es/src/policies/disableResponseDecompressionPolicy.js
function disableResponseDecompressionPolicy() {
  return {
    create: function(nextPolicy, options) {
      return new DisableResponseDecompressionPolicy(nextPolicy, options);
    }
  };
}
__name(disableResponseDecompressionPolicy, "disableResponseDecompressionPolicy");
var DisableResponseDecompressionPolicy = function(_super) {
  __extends(DisableResponseDecompressionPolicy2, _super);
  function DisableResponseDecompressionPolicy2(nextPolicy, options) {
    return _super.call(this, nextPolicy, options) || this;
  }
  return __name(DisableResponseDecompressionPolicy2, "DisableResponseDecompressionPolicy"), DisableResponseDecompressionPolicy2.prototype.sendRequest = function(request) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        return request.decompressResponse = !1, [2, this._nextPolicy.sendRequest(request)];
      });
    });
  }, DisableResponseDecompressionPolicy2;
}(BaseRequestPolicy);

// ../node_modules/@azure/core-http/es/src/httpClientCache.js
var cachedHttpClient;
function getCachedDefaultHttpClient() {
  return cachedHttpClient || (cachedHttpClient = new NodeFetchHttpClient()), cachedHttpClient;
}
__name(getCachedDefaultHttpClient, "getCachedDefaultHttpClient");

// ../node_modules/@azure/core-http/es/src/serviceClient.js
var ServiceClient = function() {
  function ServiceClient2(credentials, options) {
    var _this = this;
    options || (options = {}), this._withCredentials = options.withCredentials || !1, this._httpClient = options.httpClient || getCachedDefaultHttpClient(), this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);
    var requestPolicyFactories;
    if (Array.isArray(options.requestPolicyFactories))
      logger.info("ServiceClient: using custom request policies"), requestPolicyFactories = options.requestPolicyFactories;
    else {
      var authPolicyFactory = void 0;
      if (isTokenCredential(credentials)) {
        logger.info("ServiceClient: creating bearer token authentication policy from provided credentials");
        var wrappedPolicyFactory = /* @__PURE__ */ __name(function() {
          var bearerTokenPolicyFactory = void 0, serviceClient = _this, serviceClientOptions = options;
          return {
            create: function(nextPolicy, createOptions) {
              var credentialScopes = getCredentialScopes(serviceClientOptions, serviceClient.baseUri);
              if (!credentialScopes)
                throw new Error("When using credential, the ServiceClient must contain a baseUri or a credentialScopes in ServiceClientOptions. Unable to create a bearerTokenAuthenticationPolicy");
              return bearerTokenPolicyFactory == null && (bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(credentials, credentialScopes)), bearerTokenPolicyFactory.create(nextPolicy, createOptions);
            }
          };
        }, "wrappedPolicyFactory");
        authPolicyFactory = wrappedPolicyFactory();
      } else if (credentials && typeof credentials.signRequest == "function")
        logger.info("ServiceClient: creating signing policy from provided credentials"), authPolicyFactory = signingPolicy(credentials);
      else if (credentials != null)
        throw new Error("The credentials argument must implement the TokenCredential interface");
      if (logger.info("ServiceClient: using default request policies"), requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options), options.requestPolicyFactories) {
        var newRequestPolicyFactories = options.requestPolicyFactories(requestPolicyFactories);
        newRequestPolicyFactories && (requestPolicyFactories = newRequestPolicyFactories);
      }
    }
    this._requestPolicyFactories = requestPolicyFactories;
  }
  return __name(ServiceClient2, "ServiceClient"), ServiceClient2.prototype.sendRequest = function(options) {
    if (options == null || typeof options != "object")
      throw new Error("options cannot be null or undefined and it must be of type object.");
    var httpRequest;
    try {
      isWebResourceLike(options) ? (options.validateRequestProperties(), httpRequest = options) : (httpRequest = new WebResource(), httpRequest = httpRequest.prepare(options));
    } catch (error) {
      return Promise.reject(error);
    }
    var httpPipeline = this._httpClient;
    if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0)
      for (var i = this._requestPolicyFactories.length - 1; i >= 0; --i)
        httpPipeline = this._requestPolicyFactories[i].create(httpPipeline, this._requestPolicyOptions);
    return httpPipeline.sendRequest(httpRequest);
  }, ServiceClient2.prototype.sendOperationRequest = function(operationArguments, operationSpec, callback) {
    var _a;
    return __awaiter(this, void 0, void 0, function() {
      var serializerOptions, httpRequest, result, baseUri, requestUrl, _i, _b, urlParameter, urlParameterValue, _c, _d, queryParameter, queryParameterValue, index, item, index, contentType2, _e, _f, headerParameter, headerValue, headerCollectionPrefix, _g, _h, key, options, customHeaderName, rawResponse, sendRequestError, error_1, error_2, cb;
      return __generator(this, function(_j) {
        switch (_j.label) {
          case 0:
            typeof operationArguments.options == "function" && (callback = operationArguments.options, operationArguments.options = void 0), serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions, httpRequest = new WebResource(), _j.label = 1;
          case 1:
            if (_j.trys.push([1, 6, , 7]), baseUri = operationSpec.baseUrl || this.baseUri, !baseUri)
              throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.");
            if (httpRequest.method = operationSpec.httpMethod, httpRequest.operationSpec = operationSpec, requestUrl = URLBuilder.parse(baseUri), operationSpec.path && requestUrl.appendPath(operationSpec.path), operationSpec.urlParameters && operationSpec.urlParameters.length > 0)
              for (_i = 0, _b = operationSpec.urlParameters; _i < _b.length; _i++)
                urlParameter = _b[_i], urlParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, urlParameter, operationSpec.serializer), urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, getPathStringFromParameter(urlParameter), serializerOptions), urlParameter.skipEncoding || (urlParameterValue = encodeURIComponent(urlParameterValue)), requestUrl.replaceAll("{" + (urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter)) + "}", urlParameterValue);
            if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) {
              for (_c = 0, _d = operationSpec.queryParameters; _c < _d.length; _c++)
                if (queryParameter = _d[_c], queryParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, queryParameter, operationSpec.serializer), queryParameterValue != null) {
                  if (queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter), serializerOptions), queryParameter.collectionFormat !== void 0 && queryParameter.collectionFormat !== null)
                    if (queryParameter.collectionFormat === QueryCollectionFormat.Multi) {
                      if (queryParameterValue.length === 0)
                        continue;
                      for (index in queryParameterValue)
                        item = queryParameterValue[index], queryParameterValue[index] = item == null ? "" : item.toString();
                    } else
                      (queryParameter.collectionFormat === QueryCollectionFormat.Ssv || queryParameter.collectionFormat === QueryCollectionFormat.Tsv) && (queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat));
                  if (!queryParameter.skipEncoding)
                    if (Array.isArray(queryParameterValue))
                      for (index in queryParameterValue)
                        queryParameterValue[index] !== void 0 && queryParameterValue[index] !== null && (queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]));
                    else
                      queryParameterValue = encodeURIComponent(queryParameterValue);
                  queryParameter.collectionFormat !== void 0 && queryParameter.collectionFormat !== null && queryParameter.collectionFormat !== QueryCollectionFormat.Multi && queryParameter.collectionFormat !== QueryCollectionFormat.Ssv && queryParameter.collectionFormat !== QueryCollectionFormat.Tsv && (queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat)), requestUrl.setQueryParameter(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);
                }
            }
            if (httpRequest.url = requestUrl.toString(), contentType2 = operationSpec.contentType || this.requestContentType, contentType2 && httpRequest.headers.set("Content-Type", contentType2), operationSpec.headerParameters) {
              for (_e = 0, _f = operationSpec.headerParameters; _e < _f.length; _e++)
                if (headerParameter = _f[_e], headerValue = getOperationArgumentValueFromParameter(this, operationArguments, headerParameter, operationSpec.serializer), headerValue != null)
                  if (headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter), serializerOptions), headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix, headerCollectionPrefix)
                    for (_g = 0, _h = Object.keys(headerValue); _g < _h.length; _g++)
                      key = _h[_g], httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);
                  else
                    httpRequest.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);
            }
            if (options = operationArguments.options, options) {
              if (options.customHeaders)
                for (customHeaderName in options.customHeaders)
                  httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);
              options.abortSignal && (httpRequest.abortSignal = options.abortSignal), options.timeout && (httpRequest.timeout = options.timeout), options.onUploadProgress && (httpRequest.onUploadProgress = options.onUploadProgress), options.onDownloadProgress && (httpRequest.onDownloadProgress = options.onDownloadProgress), options.spanOptions && (httpRequest.spanOptions = options.spanOptions), options.shouldDeserialize !== void 0 && options.shouldDeserialize !== null && (httpRequest.shouldDeserialize = options.shouldDeserialize);
            }
            httpRequest.withCredentials = this._withCredentials, serializeRequestBody(this, httpRequest, operationArguments, operationSpec), (httpRequest.streamResponseBody === void 0 || httpRequest.streamResponseBody === null) && (httpRequest.streamResponseBody = isStreamOperation(operationSpec)), rawResponse = void 0, sendRequestError = void 0, _j.label = 2;
          case 2:
            return _j.trys.push([2, 4, , 5]), [4, this.sendRequest(httpRequest)];
          case 3:
            return rawResponse = _j.sent(), [3, 5];
          case 4:
            return error_1 = _j.sent(), sendRequestError = error_1, [3, 5];
          case 5:
            return sendRequestError ? (sendRequestError.response && (sendRequestError.details = flattenResponse(sendRequestError.response, operationSpec.responses[sendRequestError.statusCode] || operationSpec.responses.default)), result = Promise.reject(sendRequestError)) : result = Promise.resolve(flattenResponse(rawResponse, operationSpec.responses[rawResponse.status])), [3, 7];
          case 6:
            return error_2 = _j.sent(), result = Promise.reject(error_2), [3, 7];
          case 7:
            return cb = callback, cb && result.then(function(res) {
              return cb(null, res._response.parsedBody, res._response.request, res._response);
            }).catch(function(err) {
              return cb(err);
            }), [2, result];
        }
      });
    });
  }, ServiceClient2;
}();
function serializeRequestBody(serviceClient, httpRequest, operationArguments, operationSpec) {
  var _a, _b, _c, _d, _e, _f, serializerOptions = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions) !== null && _b !== void 0 ? _b : {}, updatedOptions = {
    rootName: (_c = serializerOptions.rootName) !== null && _c !== void 0 ? _c : "",
    includeRoot: (_d = serializerOptions.includeRoot) !== null && _d !== void 0 ? _d : !1,
    xmlCharKey: (_e = serializerOptions.xmlCharKey) !== null && _e !== void 0 ? _e : XML_CHARKEY
  }, xmlCharKey = serializerOptions.xmlCharKey;
  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
    httpRequest.body = getOperationArgumentValueFromParameter(serviceClient, operationArguments, operationSpec.requestBody, operationSpec.serializer);
    var bodyMapper = operationSpec.requestBody.mapper, required = bodyMapper.required, xmlName = bodyMapper.xmlName, xmlElementName = bodyMapper.xmlElementName, serializedName = bodyMapper.serializedName, xmlNamespace = bodyMapper.xmlNamespace, xmlNamespacePrefix = bodyMapper.xmlNamespacePrefix, typeName = bodyMapper.type.name;
    try {
      if (httpRequest.body !== void 0 && httpRequest.body !== null || required) {
        var requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);
        httpRequest.body = operationSpec.serializer.serialize(bodyMapper, httpRequest.body, requestBodyParameterPathString, updatedOptions);
        var isStream = typeName === MapperType.Stream;
        if (operationSpec.isXML) {
          var xmlnsKey = xmlNamespacePrefix ? "xmlns:" + xmlNamespacePrefix : "xmlns", value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, httpRequest.body, updatedOptions);
          typeName === MapperType.Sequence ? httpRequest.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {
            rootName: xmlName || serializedName,
            xmlCharKey
          }) : isStream || (httpRequest.body = stringifyXML(value, {
            rootName: xmlName || serializedName,
            xmlCharKey
          }));
        } else {
          if (typeName === MapperType.String && (((_f = operationSpec.contentType) === null || _f === void 0 ? void 0 : _f.match("text/plain")) || operationSpec.mediaType === "text"))
            return;
          isStream || (httpRequest.body = JSON.stringify(httpRequest.body));
        }
      }
    } catch (error) {
      throw new Error('Error "' + error.message + '" occurred in serializing the payload - ' + JSON.stringify(serializedName, void 0, "  ") + ".");
    }
  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
    httpRequest.formData = {};
    for (var _i = 0, _g = operationSpec.formDataParameters; _i < _g.length; _i++) {
      var formDataParameter = _g[_i], formDataParameterValue = getOperationArgumentValueFromParameter(serviceClient, operationArguments, formDataParameter, operationSpec.serializer);
      if (formDataParameterValue != null) {
        var formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);
        httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);
      }
    }
  }
}
__name(serializeRequestBody, "serializeRequestBody");
function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
  var _a;
  if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
    var result = {};
    return result[options.xmlCharKey] = serializedValue, result[XML_ATTRKEY] = (_a = {}, _a[xmlnsKey] = xmlNamespace, _a), result;
  }
  return serializedValue;
}
__name(getXmlValueWithNamespace, "getXmlValueWithNamespace");
function getValueOrFunctionResult(value, defaultValueCreator) {
  var result;
  return typeof value == "string" ? result = value : (result = defaultValueCreator(), typeof value == "function" && (result = value(result))), result;
}
__name(getValueOrFunctionResult, "getValueOrFunctionResult");
function createDefaultRequestPolicyFactories(authPolicyFactory, options) {
  var factories = [];
  options.generateClientRequestIdHeader && factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName)), authPolicyFactory && factories.push(authPolicyFactory);
  var userAgentHeaderName = getValueOrFunctionResult(options.userAgentHeaderName, getDefaultUserAgentHeaderName), userAgentHeaderValue = getValueOrFunctionResult(options.userAgent, getDefaultUserAgentValue);
  return userAgentHeaderName && userAgentHeaderValue && factories.push(userAgentPolicy({key: userAgentHeaderName, value: userAgentHeaderValue})), factories.push(redirectPolicy()), factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout)), options.noRetryPolicy || (factories.push(exponentialRetryPolicy()), factories.push(systemErrorRetryPolicy()), factories.push(throttlingRetryPolicy())), factories.push(deserializationPolicy(options.deserializationContentTypes)), isNode && factories.push(proxyPolicy(options.proxySettings)), factories.push(logPolicy({logger: logger.info})), factories;
}
__name(createDefaultRequestPolicyFactories, "createDefaultRequestPolicyFactories");
function getOperationArgumentValueFromParameter(serviceClient, operationArguments, parameter, serializer7) {
  return getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameter.parameterPath, parameter.mapper, serializer7);
}
__name(getOperationArgumentValueFromParameter, "getOperationArgumentValueFromParameter");
function getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameterPath, parameterMapper, serializer7) {
  var _a, value;
  typeof parameterPath == "string" && (parameterPath = [parameterPath]);
  var serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;
  if (Array.isArray(parameterPath)) {
    if (parameterPath.length > 0) {
      if (parameterMapper.isConstant)
        value = parameterMapper.defaultValue;
      else {
        var propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
        propertySearchResult.propertyFound || (propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath));
        var useDefaultValue = !1;
        propertySearchResult.propertyFound || (useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2), value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
      }
      var parameterPathString = getPathStringFromParameterPath(parameterPath, parameterMapper);
      serializer7.serialize(parameterMapper, value, parameterPathString, serializerOptions);
    }
  } else {
    parameterMapper.required && (value = {});
    for (var propertyName in parameterPath) {
      var propertyMapper = parameterMapper.type.modelProperties[propertyName], propertyPath = parameterPath[propertyName], propertyValue = getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, propertyPath, propertyMapper, serializer7), propertyPathString = getPathStringFromParameterPath(propertyPath, propertyMapper);
      serializer7.serialize(propertyMapper, propertyValue, propertyPathString, serializerOptions), propertyValue != null && (value || (value = {}), value[propertyName] = propertyValue);
    }
  }
  return value;
}
__name(getOperationArgumentValueFromParameterPath, "getOperationArgumentValueFromParameterPath");
function getPropertyFromParameterPath(parent, parameterPath) {
  for (var result = {propertyFound: !1}, i = 0; i < parameterPath.length; ++i) {
    var parameterPathPart = parameterPath[i];
    if (parent != null && parameterPathPart in parent)
      parent = parent[parameterPathPart];
    else
      break;
  }
  return i === parameterPath.length && (result.propertyValue = parent, result.propertyFound = !0), result;
}
__name(getPropertyFromParameterPath, "getPropertyFromParameterPath");
function flattenResponse(_response, responseSpec) {
  var parsedHeaders = _response.parsedHeaders, bodyMapper = responseSpec && responseSpec.bodyMapper, addOperationResponse = /* @__PURE__ */ __name(function(obj) {
    return Object.defineProperty(obj, "_response", {
      value: _response
    });
  }, "addOperationResponse");
  if (bodyMapper) {
    var typeName = bodyMapper.type.name;
    if (typeName === "Stream")
      return addOperationResponse(__assign(__assign({}, parsedHeaders), {blobBody: _response.blobBody, readableStreamBody: _response.readableStreamBody}));
    var modelProperties_1 = typeName === "Composite" && bodyMapper.type.modelProperties || {}, isPageableResponse = Object.keys(modelProperties_1).some(function(k) {
      return modelProperties_1[k].serializedName === "";
    });
    if (typeName === "Sequence" || isPageableResponse) {
      for (var arrayResponse = __spreadArrays(_response.parsedBody || []), _i = 0, _a = Object.keys(modelProperties_1); _i < _a.length; _i++) {
        var key = _a[_i];
        modelProperties_1[key].serializedName && (arrayResponse[key] = _response.parsedBody[key]);
      }
      if (parsedHeaders)
        for (var _b = 0, _c = Object.keys(parsedHeaders); _b < _c.length; _b++) {
          var key = _c[_b];
          arrayResponse[key] = parsedHeaders[key];
        }
      return addOperationResponse(arrayResponse), arrayResponse;
    }
    if (typeName === "Composite" || typeName === "Dictionary")
      return addOperationResponse(__assign(__assign({}, parsedHeaders), _response.parsedBody));
  }
  return bodyMapper || _response.request.method === "HEAD" || isPrimitiveType(_response.parsedBody) ? addOperationResponse(__assign(__assign({}, parsedHeaders), {body: _response.parsedBody})) : addOperationResponse(__assign(__assign({}, parsedHeaders), _response.parsedBody));
}
__name(flattenResponse, "flattenResponse");
function getCredentialScopes(options, baseUri) {
  if (options == null ? void 0 : options.credentialScopes) {
    var scopes = options.credentialScopes;
    return Array.isArray(scopes) ? scopes.map(function(scope) {
      return new import_url2.URL(scope).toString();
    }) : new import_url2.URL(scopes).toString();
  }
  if (baseUri)
    return baseUri + "/.default";
}
__name(getCredentialScopes, "getCredentialScopes");

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/BlobServiceClient.js
var import_api7 = __toModule(require_src2());

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/generated/src/models/serviceMappers.js
var serviceMappers_exports = {};
__export(serviceMappers_exports, {
  BlobServiceProperties: () => BlobServiceProperties,
  BlobServiceStatistics: () => BlobServiceStatistics,
  BlobTag: () => BlobTag,
  BlobTags: () => BlobTags,
  ContainerItem: () => ContainerItem,
  ContainerProperties: () => ContainerProperties,
  CorsRule: () => CorsRule,
  FilterBlobItem: () => FilterBlobItem,
  FilterBlobSegment: () => FilterBlobSegment,
  GeoReplication: () => GeoReplication,
  KeyInfo: () => KeyInfo,
  ListContainersSegmentResponse: () => ListContainersSegmentResponse,
  Logging: () => Logging,
  Metrics: () => Metrics,
  RetentionPolicy: () => RetentionPolicy,
  ServiceFilterBlobsHeaders: () => ServiceFilterBlobsHeaders,
  ServiceGetAccountInfoHeaders: () => ServiceGetAccountInfoHeaders,
  ServiceGetPropertiesHeaders: () => ServiceGetPropertiesHeaders,
  ServiceGetStatisticsHeaders: () => ServiceGetStatisticsHeaders,
  ServiceGetUserDelegationKeyHeaders: () => ServiceGetUserDelegationKeyHeaders,
  ServiceListContainersSegmentHeaders: () => ServiceListContainersSegmentHeaders,
  ServiceSetPropertiesHeaders: () => ServiceSetPropertiesHeaders,
  ServiceSubmitBatchHeaders: () => ServiceSubmitBatchHeaders,
  StaticWebsite: () => StaticWebsite,
  StorageError: () => StorageError,
  UserDelegationKey: () => UserDelegationKey
});

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/generated/src/models/mappers.js
var KeyInfo = {
  serializedName: "KeyInfo",
  type: {
    name: "Composite",
    className: "KeyInfo",
    modelProperties: {
      startsOn: {
        xmlName: "Start",
        required: !0,
        serializedName: "Start",
        type: {
          name: "String"
        }
      },
      expiresOn: {
        xmlName: "Expiry",
        required: !0,
        serializedName: "Expiry",
        type: {
          name: "String"
        }
      }
    }
  }
}, UserDelegationKey = {
  serializedName: "UserDelegationKey",
  type: {
    name: "Composite",
    className: "UserDelegationKey",
    modelProperties: {
      signedObjectId: {
        xmlName: "SignedOid",
        required: !0,
        serializedName: "SignedOid",
        type: {
          name: "String"
        }
      },
      signedTenantId: {
        xmlName: "SignedTid",
        required: !0,
        serializedName: "SignedTid",
        type: {
          name: "String"
        }
      },
      signedStartsOn: {
        xmlName: "SignedStart",
        required: !0,
        serializedName: "SignedStart",
        type: {
          name: "String"
        }
      },
      signedExpiresOn: {
        xmlName: "SignedExpiry",
        required: !0,
        serializedName: "SignedExpiry",
        type: {
          name: "String"
        }
      },
      signedService: {
        xmlName: "SignedService",
        required: !0,
        serializedName: "SignedService",
        type: {
          name: "String"
        }
      },
      signedVersion: {
        xmlName: "SignedVersion",
        required: !0,
        serializedName: "SignedVersion",
        type: {
          name: "String"
        }
      },
      value: {
        xmlName: "Value",
        required: !0,
        serializedName: "Value",
        type: {
          name: "String"
        }
      }
    }
  }
}, StorageError = {
  serializedName: "StorageError",
  type: {
    name: "Composite",
    className: "StorageError",
    modelProperties: {
      message: {
        xmlName: "Message",
        serializedName: "Message",
        type: {
          name: "String"
        }
      },
      code: {
        xmlName: "Code",
        serializedName: "Code",
        type: {
          name: "String"
        }
      }
    }
  }
}, DataLakeStorageErrorError = {
  serializedName: "DataLakeStorageError_error",
  type: {
    name: "Composite",
    className: "DataLakeStorageErrorError",
    modelProperties: {
      code: {
        xmlName: "Code",
        serializedName: "Code",
        type: {
          name: "String"
        }
      },
      message: {
        xmlName: "Message",
        serializedName: "Message",
        type: {
          name: "String"
        }
      }
    }
  }
}, DataLakeStorageError = {
  serializedName: "DataLakeStorageError",
  type: {
    name: "Composite",
    className: "DataLakeStorageError",
    modelProperties: {
      dataLakeStorageErrorDetails: {
        xmlName: "error",
        serializedName: "error",
        type: {
          name: "Composite",
          className: "DataLakeStorageErrorError"
        }
      }
    }
  }
}, AccessPolicy = {
  serializedName: "AccessPolicy",
  type: {
    name: "Composite",
    className: "AccessPolicy",
    modelProperties: {
      startsOn: {
        xmlName: "Start",
        serializedName: "Start",
        type: {
          name: "String"
        }
      },
      expiresOn: {
        xmlName: "Expiry",
        serializedName: "Expiry",
        type: {
          name: "String"
        }
      },
      permissions: {
        xmlName: "Permission",
        serializedName: "Permission",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobPropertiesInternal = {
  xmlName: "Properties",
  serializedName: "BlobPropertiesInternal",
  type: {
    name: "Composite",
    className: "BlobPropertiesInternal",
    modelProperties: {
      createdOn: {
        xmlName: "Creation-Time",
        serializedName: "Creation-Time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      lastModified: {
        xmlName: "Last-Modified",
        required: !0,
        serializedName: "Last-Modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      etag: {
        xmlName: "Etag",
        required: !0,
        serializedName: "Etag",
        type: {
          name: "String"
        }
      },
      contentLength: {
        xmlName: "Content-Length",
        serializedName: "Content-Length",
        type: {
          name: "Number"
        }
      },
      contentType: {
        xmlName: "Content-Type",
        serializedName: "Content-Type",
        type: {
          name: "String"
        }
      },
      contentEncoding: {
        xmlName: "Content-Encoding",
        serializedName: "Content-Encoding",
        type: {
          name: "String"
        }
      },
      contentLanguage: {
        xmlName: "Content-Language",
        serializedName: "Content-Language",
        type: {
          name: "String"
        }
      },
      contentMD5: {
        xmlName: "Content-MD5",
        serializedName: "Content-MD5",
        type: {
          name: "ByteArray"
        }
      },
      contentDisposition: {
        xmlName: "Content-Disposition",
        serializedName: "Content-Disposition",
        type: {
          name: "String"
        }
      },
      cacheControl: {
        xmlName: "Cache-Control",
        serializedName: "Cache-Control",
        type: {
          name: "String"
        }
      },
      blobSequenceNumber: {
        xmlName: "x-ms-blob-sequence-number",
        serializedName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      blobType: {
        xmlName: "BlobType",
        serializedName: "BlobType",
        type: {
          name: "Enum",
          allowedValues: [
            "BlockBlob",
            "PageBlob",
            "AppendBlob"
          ]
        }
      },
      leaseStatus: {
        xmlName: "LeaseStatus",
        serializedName: "LeaseStatus",
        type: {
          name: "Enum",
          allowedValues: [
            "locked",
            "unlocked"
          ]
        }
      },
      leaseState: {
        xmlName: "LeaseState",
        serializedName: "LeaseState",
        type: {
          name: "Enum",
          allowedValues: [
            "available",
            "leased",
            "expired",
            "breaking",
            "broken"
          ]
        }
      },
      leaseDuration: {
        xmlName: "LeaseDuration",
        serializedName: "LeaseDuration",
        type: {
          name: "Enum",
          allowedValues: [
            "infinite",
            "fixed"
          ]
        }
      },
      copyId: {
        xmlName: "CopyId",
        serializedName: "CopyId",
        type: {
          name: "String"
        }
      },
      copyStatus: {
        xmlName: "CopyStatus",
        serializedName: "CopyStatus",
        type: {
          name: "Enum",
          allowedValues: [
            "pending",
            "success",
            "aborted",
            "failed"
          ]
        }
      },
      copySource: {
        xmlName: "CopySource",
        serializedName: "CopySource",
        type: {
          name: "String"
        }
      },
      copyProgress: {
        xmlName: "CopyProgress",
        serializedName: "CopyProgress",
        type: {
          name: "String"
        }
      },
      copyCompletedOn: {
        xmlName: "CopyCompletionTime",
        serializedName: "CopyCompletionTime",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      copyStatusDescription: {
        xmlName: "CopyStatusDescription",
        serializedName: "CopyStatusDescription",
        type: {
          name: "String"
        }
      },
      serverEncrypted: {
        xmlName: "ServerEncrypted",
        serializedName: "ServerEncrypted",
        type: {
          name: "Boolean"
        }
      },
      incrementalCopy: {
        xmlName: "IncrementalCopy",
        serializedName: "IncrementalCopy",
        type: {
          name: "Boolean"
        }
      },
      destinationSnapshot: {
        xmlName: "DestinationSnapshot",
        serializedName: "DestinationSnapshot",
        type: {
          name: "String"
        }
      },
      deletedOn: {
        xmlName: "DeletedTime",
        serializedName: "DeletedTime",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      remainingRetentionDays: {
        xmlName: "RemainingRetentionDays",
        serializedName: "RemainingRetentionDays",
        type: {
          name: "Number"
        }
      },
      accessTier: {
        xmlName: "AccessTier",
        serializedName: "AccessTier",
        type: {
          name: "String"
        }
      },
      accessTierInferred: {
        xmlName: "AccessTierInferred",
        serializedName: "AccessTierInferred",
        type: {
          name: "Boolean"
        }
      },
      archiveStatus: {
        xmlName: "ArchiveStatus",
        serializedName: "ArchiveStatus",
        type: {
          name: "String"
        }
      },
      customerProvidedKeySha256: {
        xmlName: "CustomerProvidedKeySha256",
        serializedName: "CustomerProvidedKeySha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        xmlName: "EncryptionScope",
        serializedName: "EncryptionScope",
        type: {
          name: "String"
        }
      },
      accessTierChangedOn: {
        xmlName: "AccessTierChangeTime",
        serializedName: "AccessTierChangeTime",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      tagCount: {
        xmlName: "TagCount",
        serializedName: "TagCount",
        type: {
          name: "Number"
        }
      },
      expiresOn: {
        xmlName: "Expiry-Time",
        serializedName: "Expiry-Time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isSealed: {
        xmlName: "Sealed",
        serializedName: "Sealed",
        type: {
          name: "Boolean"
        }
      },
      rehydratePriority: {
        xmlName: "RehydratePriority",
        serializedName: "RehydratePriority",
        type: {
          name: "String"
        }
      },
      lastAccessedOn: {
        xmlName: "LastAccessTime",
        serializedName: "LastAccessTime",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, BlobTag = {
  xmlName: "Tag",
  serializedName: "BlobTag",
  type: {
    name: "Composite",
    className: "BlobTag",
    modelProperties: {
      key: {
        xmlName: "Key",
        required: !0,
        serializedName: "Key",
        type: {
          name: "String"
        }
      },
      value: {
        xmlName: "Value",
        required: !0,
        serializedName: "Value",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobTags = {
  xmlName: "Tags",
  serializedName: "BlobTags",
  type: {
    name: "Composite",
    className: "BlobTags",
    modelProperties: {
      blobTagSet: {
        xmlIsWrapped: !0,
        xmlName: "TagSet",
        xmlElementName: "Tag",
        required: !0,
        serializedName: "BlobTagSet",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "BlobTag"
            }
          }
        }
      }
    }
  }
}, BlobItemInternal = {
  xmlName: "Blob",
  serializedName: "BlobItemInternal",
  type: {
    name: "Composite",
    className: "BlobItemInternal",
    modelProperties: {
      name: {
        xmlName: "Name",
        required: !0,
        serializedName: "Name",
        type: {
          name: "String"
        }
      },
      deleted: {
        xmlName: "Deleted",
        required: !0,
        serializedName: "Deleted",
        type: {
          name: "Boolean"
        }
      },
      snapshot: {
        xmlName: "Snapshot",
        required: !0,
        serializedName: "Snapshot",
        type: {
          name: "String"
        }
      },
      versionId: {
        xmlName: "VersionId",
        serializedName: "VersionId",
        type: {
          name: "String"
        }
      },
      isCurrentVersion: {
        xmlName: "IsCurrentVersion",
        serializedName: "IsCurrentVersion",
        type: {
          name: "Boolean"
        }
      },
      properties: {
        xmlName: "Properties",
        required: !0,
        serializedName: "Properties",
        type: {
          name: "Composite",
          className: "BlobPropertiesInternal"
        }
      },
      metadata: {
        xmlName: "Metadata",
        serializedName: "Metadata",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "String"
            }
          }
        }
      },
      blobTags: {
        xmlName: "Tags",
        serializedName: "BlobTags",
        type: {
          name: "Composite",
          className: "BlobTags"
        }
      },
      objectReplicationMetadata: {
        xmlName: "OrMetadata",
        serializedName: "ObjectReplicationMetadata",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
}, BlobFlatListSegment = {
  xmlName: "Blobs",
  serializedName: "BlobFlatListSegment",
  type: {
    name: "Composite",
    className: "BlobFlatListSegment",
    modelProperties: {
      blobItems: {
        xmlName: "BlobItems",
        xmlElementName: "Blob",
        required: !0,
        serializedName: "BlobItems",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "BlobItemInternal"
            }
          }
        }
      }
    }
  }
}, ListBlobsFlatSegmentResponse = {
  xmlName: "EnumerationResults",
  serializedName: "ListBlobsFlatSegmentResponse",
  type: {
    name: "Composite",
    className: "ListBlobsFlatSegmentResponse",
    modelProperties: {
      serviceEndpoint: {
        xmlIsAttribute: !0,
        xmlName: "ServiceEndpoint",
        required: !0,
        serializedName: "ServiceEndpoint",
        type: {
          name: "String"
        }
      },
      containerName: {
        xmlIsAttribute: !0,
        xmlName: "ContainerName",
        required: !0,
        serializedName: "ContainerName",
        type: {
          name: "String"
        }
      },
      prefix: {
        xmlName: "Prefix",
        serializedName: "Prefix",
        type: {
          name: "String"
        }
      },
      marker: {
        xmlName: "Marker",
        serializedName: "Marker",
        type: {
          name: "String"
        }
      },
      maxPageSize: {
        xmlName: "MaxResults",
        serializedName: "MaxResults",
        type: {
          name: "Number"
        }
      },
      segment: {
        xmlName: "Blobs",
        required: !0,
        serializedName: "Segment",
        type: {
          name: "Composite",
          className: "BlobFlatListSegment"
        }
      },
      continuationToken: {
        xmlName: "NextMarker",
        serializedName: "NextMarker",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobPrefix = {
  serializedName: "BlobPrefix",
  type: {
    name: "Composite",
    className: "BlobPrefix",
    modelProperties: {
      name: {
        xmlName: "Name",
        required: !0,
        serializedName: "Name",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobHierarchyListSegment = {
  xmlName: "Blobs",
  serializedName: "BlobHierarchyListSegment",
  type: {
    name: "Composite",
    className: "BlobHierarchyListSegment",
    modelProperties: {
      blobPrefixes: {
        xmlName: "BlobPrefixes",
        xmlElementName: "BlobPrefix",
        serializedName: "BlobPrefixes",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "BlobPrefix"
            }
          }
        }
      },
      blobItems: {
        xmlName: "BlobItems",
        xmlElementName: "Blob",
        required: !0,
        serializedName: "BlobItems",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "BlobItemInternal"
            }
          }
        }
      }
    }
  }
}, ListBlobsHierarchySegmentResponse = {
  xmlName: "EnumerationResults",
  serializedName: "ListBlobsHierarchySegmentResponse",
  type: {
    name: "Composite",
    className: "ListBlobsHierarchySegmentResponse",
    modelProperties: {
      serviceEndpoint: {
        xmlIsAttribute: !0,
        xmlName: "ServiceEndpoint",
        required: !0,
        serializedName: "ServiceEndpoint",
        type: {
          name: "String"
        }
      },
      containerName: {
        xmlIsAttribute: !0,
        xmlName: "ContainerName",
        required: !0,
        serializedName: "ContainerName",
        type: {
          name: "String"
        }
      },
      prefix: {
        xmlName: "Prefix",
        serializedName: "Prefix",
        type: {
          name: "String"
        }
      },
      marker: {
        xmlName: "Marker",
        serializedName: "Marker",
        type: {
          name: "String"
        }
      },
      maxPageSize: {
        xmlName: "MaxResults",
        serializedName: "MaxResults",
        type: {
          name: "Number"
        }
      },
      delimiter: {
        xmlName: "Delimiter",
        serializedName: "Delimiter",
        type: {
          name: "String"
        }
      },
      segment: {
        xmlName: "Blobs",
        required: !0,
        serializedName: "Segment",
        type: {
          name: "Composite",
          className: "BlobHierarchyListSegment"
        }
      },
      continuationToken: {
        xmlName: "NextMarker",
        serializedName: "NextMarker",
        type: {
          name: "String"
        }
      }
    }
  }
}, Block = {
  serializedName: "Block",
  type: {
    name: "Composite",
    className: "Block",
    modelProperties: {
      name: {
        xmlName: "Name",
        required: !0,
        serializedName: "Name",
        type: {
          name: "String"
        }
      },
      size: {
        xmlName: "Size",
        required: !0,
        serializedName: "Size",
        type: {
          name: "Number"
        }
      }
    }
  }
}, BlockList = {
  serializedName: "BlockList",
  type: {
    name: "Composite",
    className: "BlockList",
    modelProperties: {
      committedBlocks: {
        xmlIsWrapped: !0,
        xmlName: "CommittedBlocks",
        xmlElementName: "Block",
        serializedName: "CommittedBlocks",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Block"
            }
          }
        }
      },
      uncommittedBlocks: {
        xmlIsWrapped: !0,
        xmlName: "UncommittedBlocks",
        xmlElementName: "Block",
        serializedName: "UncommittedBlocks",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Block"
            }
          }
        }
      }
    }
  }
}, BlockLookupList = {
  xmlName: "BlockList",
  serializedName: "BlockLookupList",
  type: {
    name: "Composite",
    className: "BlockLookupList",
    modelProperties: {
      committed: {
        xmlName: "Committed",
        xmlElementName: "Committed",
        serializedName: "Committed",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      uncommitted: {
        xmlName: "Uncommitted",
        xmlElementName: "Uncommitted",
        serializedName: "Uncommitted",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      latest: {
        xmlName: "Latest",
        xmlElementName: "Latest",
        serializedName: "Latest",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
}, ContainerProperties = {
  serializedName: "ContainerProperties",
  type: {
    name: "Composite",
    className: "ContainerProperties",
    modelProperties: {
      lastModified: {
        xmlName: "Last-Modified",
        required: !0,
        serializedName: "Last-Modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      etag: {
        xmlName: "Etag",
        required: !0,
        serializedName: "Etag",
        type: {
          name: "String"
        }
      },
      leaseStatus: {
        xmlName: "LeaseStatus",
        serializedName: "LeaseStatus",
        type: {
          name: "Enum",
          allowedValues: [
            "locked",
            "unlocked"
          ]
        }
      },
      leaseState: {
        xmlName: "LeaseState",
        serializedName: "LeaseState",
        type: {
          name: "Enum",
          allowedValues: [
            "available",
            "leased",
            "expired",
            "breaking",
            "broken"
          ]
        }
      },
      leaseDuration: {
        xmlName: "LeaseDuration",
        serializedName: "LeaseDuration",
        type: {
          name: "Enum",
          allowedValues: [
            "infinite",
            "fixed"
          ]
        }
      },
      publicAccess: {
        xmlName: "PublicAccess",
        serializedName: "PublicAccess",
        type: {
          name: "String"
        }
      },
      hasImmutabilityPolicy: {
        xmlName: "HasImmutabilityPolicy",
        serializedName: "HasImmutabilityPolicy",
        type: {
          name: "Boolean"
        }
      },
      hasLegalHold: {
        xmlName: "HasLegalHold",
        serializedName: "HasLegalHold",
        type: {
          name: "Boolean"
        }
      },
      defaultEncryptionScope: {
        xmlName: "DefaultEncryptionScope",
        serializedName: "DefaultEncryptionScope",
        type: {
          name: "String"
        }
      },
      preventEncryptionScopeOverride: {
        xmlName: "DenyEncryptionScopeOverride",
        serializedName: "DenyEncryptionScopeOverride",
        type: {
          name: "Boolean"
        }
      },
      deletedOn: {
        xmlName: "DeletedTime",
        serializedName: "DeletedTime",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      remainingRetentionDays: {
        xmlName: "RemainingRetentionDays",
        serializedName: "RemainingRetentionDays",
        type: {
          name: "Number"
        }
      }
    }
  }
}, ContainerItem = {
  xmlName: "Container",
  serializedName: "ContainerItem",
  type: {
    name: "Composite",
    className: "ContainerItem",
    modelProperties: {
      name: {
        xmlName: "Name",
        required: !0,
        serializedName: "Name",
        type: {
          name: "String"
        }
      },
      deleted: {
        xmlName: "Deleted",
        serializedName: "Deleted",
        type: {
          name: "Boolean"
        }
      },
      version: {
        xmlName: "Version",
        serializedName: "Version",
        type: {
          name: "String"
        }
      },
      properties: {
        xmlName: "Properties",
        required: !0,
        serializedName: "Properties",
        type: {
          name: "Composite",
          className: "ContainerProperties"
        }
      },
      metadata: {
        xmlName: "Metadata",
        serializedName: "Metadata",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
}, DelimitedTextConfiguration = {
  serializedName: "DelimitedTextConfiguration",
  type: {
    name: "Composite",
    className: "DelimitedTextConfiguration",
    modelProperties: {
      columnSeparator: {
        xmlName: "ColumnSeparator",
        required: !0,
        serializedName: "ColumnSeparator",
        type: {
          name: "String"
        }
      },
      fieldQuote: {
        xmlName: "FieldQuote",
        required: !0,
        serializedName: "FieldQuote",
        type: {
          name: "String"
        }
      },
      recordSeparator: {
        xmlName: "RecordSeparator",
        required: !0,
        serializedName: "RecordSeparator",
        type: {
          name: "String"
        }
      },
      escapeChar: {
        xmlName: "EscapeChar",
        required: !0,
        serializedName: "EscapeChar",
        type: {
          name: "String"
        }
      },
      headersPresent: {
        xmlName: "HasHeaders",
        required: !0,
        serializedName: "HeadersPresent",
        type: {
          name: "Boolean"
        }
      }
    }
  }
}, JsonTextConfiguration = {
  serializedName: "JsonTextConfiguration",
  type: {
    name: "Composite",
    className: "JsonTextConfiguration",
    modelProperties: {
      recordSeparator: {
        xmlName: "RecordSeparator",
        required: !0,
        serializedName: "RecordSeparator",
        type: {
          name: "String"
        }
      }
    }
  }
}, ArrowField = {
  xmlName: "Field",
  serializedName: "ArrowField",
  type: {
    name: "Composite",
    className: "ArrowField",
    modelProperties: {
      type: {
        xmlName: "Type",
        required: !0,
        serializedName: "Type",
        type: {
          name: "String"
        }
      },
      name: {
        xmlName: "Name",
        serializedName: "Name",
        type: {
          name: "String"
        }
      },
      precision: {
        xmlName: "Precision",
        serializedName: "Precision",
        type: {
          name: "Number"
        }
      },
      scale: {
        xmlName: "Scale",
        serializedName: "Scale",
        type: {
          name: "Number"
        }
      }
    }
  }
}, ArrowConfiguration = {
  serializedName: "ArrowConfiguration",
  type: {
    name: "Composite",
    className: "ArrowConfiguration",
    modelProperties: {
      schema: {
        xmlIsWrapped: !0,
        xmlName: "Schema",
        xmlElementName: "Field",
        required: !0,
        serializedName: "Schema",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ArrowField"
            }
          }
        }
      }
    }
  }
}, ListContainersSegmentResponse = {
  xmlName: "EnumerationResults",
  serializedName: "ListContainersSegmentResponse",
  type: {
    name: "Composite",
    className: "ListContainersSegmentResponse",
    modelProperties: {
      serviceEndpoint: {
        xmlIsAttribute: !0,
        xmlName: "ServiceEndpoint",
        required: !0,
        serializedName: "ServiceEndpoint",
        type: {
          name: "String"
        }
      },
      prefix: {
        xmlName: "Prefix",
        serializedName: "Prefix",
        type: {
          name: "String"
        }
      },
      marker: {
        xmlName: "Marker",
        serializedName: "Marker",
        type: {
          name: "String"
        }
      },
      maxPageSize: {
        xmlName: "MaxResults",
        serializedName: "MaxResults",
        type: {
          name: "Number"
        }
      },
      containerItems: {
        xmlIsWrapped: !0,
        xmlName: "Containers",
        xmlElementName: "Container",
        required: !0,
        serializedName: "ContainerItems",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ContainerItem"
            }
          }
        }
      },
      continuationToken: {
        xmlName: "NextMarker",
        serializedName: "NextMarker",
        type: {
          name: "String"
        }
      }
    }
  }
}, CorsRule = {
  serializedName: "CorsRule",
  type: {
    name: "Composite",
    className: "CorsRule",
    modelProperties: {
      allowedOrigins: {
        xmlName: "AllowedOrigins",
        required: !0,
        serializedName: "AllowedOrigins",
        type: {
          name: "String"
        }
      },
      allowedMethods: {
        xmlName: "AllowedMethods",
        required: !0,
        serializedName: "AllowedMethods",
        type: {
          name: "String"
        }
      },
      allowedHeaders: {
        xmlName: "AllowedHeaders",
        required: !0,
        serializedName: "AllowedHeaders",
        type: {
          name: "String"
        }
      },
      exposedHeaders: {
        xmlName: "ExposedHeaders",
        required: !0,
        serializedName: "ExposedHeaders",
        type: {
          name: "String"
        }
      },
      maxAgeInSeconds: {
        xmlName: "MaxAgeInSeconds",
        required: !0,
        serializedName: "MaxAgeInSeconds",
        constraints: {
          InclusiveMinimum: 0
        },
        type: {
          name: "Number"
        }
      }
    }
  }
}, FilterBlobItem = {
  xmlName: "Blob",
  serializedName: "FilterBlobItem",
  type: {
    name: "Composite",
    className: "FilterBlobItem",
    modelProperties: {
      name: {
        xmlName: "Name",
        required: !0,
        serializedName: "Name",
        type: {
          name: "String"
        }
      },
      containerName: {
        xmlName: "ContainerName",
        required: !0,
        serializedName: "ContainerName",
        type: {
          name: "String"
        }
      },
      tags: {
        xmlName: "Tags",
        serializedName: "Tags",
        type: {
          name: "Composite",
          className: "BlobTags"
        }
      }
    }
  }
}, FilterBlobSegment = {
  xmlName: "EnumerationResults",
  serializedName: "FilterBlobSegment",
  type: {
    name: "Composite",
    className: "FilterBlobSegment",
    modelProperties: {
      serviceEndpoint: {
        xmlIsAttribute: !0,
        xmlName: "ServiceEndpoint",
        required: !0,
        serializedName: "ServiceEndpoint",
        type: {
          name: "String"
        }
      },
      where: {
        xmlName: "Where",
        required: !0,
        serializedName: "Where",
        type: {
          name: "String"
        }
      },
      blobs: {
        xmlIsWrapped: !0,
        xmlName: "Blobs",
        xmlElementName: "Blob",
        required: !0,
        serializedName: "Blobs",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "FilterBlobItem"
            }
          }
        }
      },
      continuationToken: {
        xmlName: "NextMarker",
        serializedName: "NextMarker",
        type: {
          name: "String"
        }
      }
    }
  }
}, GeoReplication = {
  serializedName: "GeoReplication",
  type: {
    name: "Composite",
    className: "GeoReplication",
    modelProperties: {
      status: {
        xmlName: "Status",
        required: !0,
        serializedName: "Status",
        type: {
          name: "String"
        }
      },
      lastSyncOn: {
        xmlName: "LastSyncTime",
        required: !0,
        serializedName: "LastSyncTime",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, RetentionPolicy = {
  serializedName: "RetentionPolicy",
  type: {
    name: "Composite",
    className: "RetentionPolicy",
    modelProperties: {
      enabled: {
        xmlName: "Enabled",
        required: !0,
        serializedName: "Enabled",
        type: {
          name: "Boolean"
        }
      },
      days: {
        xmlName: "Days",
        serializedName: "Days",
        constraints: {
          InclusiveMinimum: 1
        },
        type: {
          name: "Number"
        }
      }
    }
  }
}, Logging = {
  serializedName: "Logging",
  type: {
    name: "Composite",
    className: "Logging",
    modelProperties: {
      version: {
        xmlName: "Version",
        required: !0,
        serializedName: "Version",
        type: {
          name: "String"
        }
      },
      deleteProperty: {
        xmlName: "Delete",
        required: !0,
        serializedName: "Delete",
        type: {
          name: "Boolean"
        }
      },
      read: {
        xmlName: "Read",
        required: !0,
        serializedName: "Read",
        type: {
          name: "Boolean"
        }
      },
      write: {
        xmlName: "Write",
        required: !0,
        serializedName: "Write",
        type: {
          name: "Boolean"
        }
      },
      retentionPolicy: {
        xmlName: "RetentionPolicy",
        required: !0,
        serializedName: "RetentionPolicy",
        type: {
          name: "Composite",
          className: "RetentionPolicy"
        }
      }
    }
  }
}, Metrics = {
  serializedName: "Metrics",
  type: {
    name: "Composite",
    className: "Metrics",
    modelProperties: {
      version: {
        xmlName: "Version",
        serializedName: "Version",
        type: {
          name: "String"
        }
      },
      enabled: {
        xmlName: "Enabled",
        required: !0,
        serializedName: "Enabled",
        type: {
          name: "Boolean"
        }
      },
      includeAPIs: {
        xmlName: "IncludeAPIs",
        serializedName: "IncludeAPIs",
        type: {
          name: "Boolean"
        }
      },
      retentionPolicy: {
        xmlName: "RetentionPolicy",
        serializedName: "RetentionPolicy",
        type: {
          name: "Composite",
          className: "RetentionPolicy"
        }
      }
    }
  }
}, PageRange = {
  serializedName: "PageRange",
  type: {
    name: "Composite",
    className: "PageRange",
    modelProperties: {
      start: {
        xmlName: "Start",
        required: !0,
        serializedName: "Start",
        type: {
          name: "Number"
        }
      },
      end: {
        xmlName: "End",
        required: !0,
        serializedName: "End",
        type: {
          name: "Number"
        }
      }
    }
  }
}, ClearRange = {
  serializedName: "ClearRange",
  type: {
    name: "Composite",
    className: "ClearRange",
    modelProperties: {
      start: {
        xmlName: "Start",
        required: !0,
        serializedName: "Start",
        type: {
          name: "Number"
        }
      },
      end: {
        xmlName: "End",
        required: !0,
        serializedName: "End",
        type: {
          name: "Number"
        }
      }
    }
  }
}, PageList = {
  serializedName: "PageList",
  type: {
    name: "Composite",
    className: "PageList",
    modelProperties: {
      pageRange: {
        xmlName: "PageRange",
        xmlElementName: "PageRange",
        serializedName: "PageRange",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "PageRange"
            }
          }
        }
      },
      clearRange: {
        xmlName: "ClearRange",
        xmlElementName: "ClearRange",
        serializedName: "ClearRange",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ClearRange"
            }
          }
        }
      }
    }
  }
}, QueryFormat = {
  serializedName: "QueryFormat",
  type: {
    name: "Composite",
    className: "QueryFormat",
    modelProperties: {
      type: {
        xmlName: "Type",
        serializedName: "Type",
        type: {
          name: "Enum",
          allowedValues: [
            "delimited",
            "json",
            "arrow"
          ]
        }
      },
      delimitedTextConfiguration: {
        xmlName: "DelimitedTextConfiguration",
        serializedName: "DelimitedTextConfiguration",
        type: {
          name: "Composite",
          className: "DelimitedTextConfiguration"
        }
      },
      jsonTextConfiguration: {
        xmlName: "JsonTextConfiguration",
        serializedName: "JsonTextConfiguration",
        type: {
          name: "Composite",
          className: "JsonTextConfiguration"
        }
      },
      arrowConfiguration: {
        xmlName: "ArrowConfiguration",
        serializedName: "ArrowConfiguration",
        type: {
          name: "Composite",
          className: "ArrowConfiguration"
        }
      }
    }
  }
}, QuerySerialization = {
  serializedName: "QuerySerialization",
  type: {
    name: "Composite",
    className: "QuerySerialization",
    modelProperties: {
      format: {
        xmlName: "Format",
        required: !0,
        serializedName: "Format",
        type: {
          name: "Composite",
          className: "QueryFormat"
        }
      }
    }
  }
}, QueryRequest = {
  serializedName: "QueryRequest",
  type: {
    name: "Composite",
    className: "QueryRequest",
    modelProperties: {
      queryType: {
        xmlName: "QueryType",
        required: !0,
        isConstant: !0,
        serializedName: "QueryType",
        defaultValue: "SQL",
        type: {
          name: "String"
        }
      },
      expression: {
        xmlName: "Expression",
        required: !0,
        serializedName: "Expression",
        type: {
          name: "String"
        }
      },
      inputSerialization: {
        xmlName: "InputSerialization",
        serializedName: "InputSerialization",
        type: {
          name: "Composite",
          className: "QuerySerialization"
        }
      },
      outputSerialization: {
        xmlName: "OutputSerialization",
        serializedName: "OutputSerialization",
        type: {
          name: "Composite",
          className: "QuerySerialization"
        }
      }
    }
  }
}, SignedIdentifier = {
  serializedName: "SignedIdentifier",
  type: {
    name: "Composite",
    className: "SignedIdentifier",
    modelProperties: {
      id: {
        xmlName: "Id",
        required: !0,
        serializedName: "Id",
        type: {
          name: "String"
        }
      },
      accessPolicy: {
        xmlName: "AccessPolicy",
        required: !0,
        serializedName: "AccessPolicy",
        type: {
          name: "Composite",
          className: "AccessPolicy"
        }
      }
    }
  }
}, StaticWebsite = {
  serializedName: "StaticWebsite",
  type: {
    name: "Composite",
    className: "StaticWebsite",
    modelProperties: {
      enabled: {
        xmlName: "Enabled",
        required: !0,
        serializedName: "Enabled",
        type: {
          name: "Boolean"
        }
      },
      indexDocument: {
        xmlName: "IndexDocument",
        serializedName: "IndexDocument",
        type: {
          name: "String"
        }
      },
      errorDocument404Path: {
        xmlName: "ErrorDocument404Path",
        serializedName: "ErrorDocument404Path",
        type: {
          name: "String"
        }
      },
      defaultIndexDocumentPath: {
        xmlName: "DefaultIndexDocumentPath",
        serializedName: "DefaultIndexDocumentPath",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobServiceProperties = {
  xmlName: "StorageServiceProperties",
  serializedName: "BlobServiceProperties",
  type: {
    name: "Composite",
    className: "BlobServiceProperties",
    modelProperties: {
      blobAnalyticsLogging: {
        xmlName: "Logging",
        serializedName: "Logging",
        type: {
          name: "Composite",
          className: "Logging"
        }
      },
      hourMetrics: {
        xmlName: "HourMetrics",
        serializedName: "HourMetrics",
        type: {
          name: "Composite",
          className: "Metrics"
        }
      },
      minuteMetrics: {
        xmlName: "MinuteMetrics",
        serializedName: "MinuteMetrics",
        type: {
          name: "Composite",
          className: "Metrics"
        }
      },
      cors: {
        xmlIsWrapped: !0,
        xmlName: "Cors",
        xmlElementName: "CorsRule",
        serializedName: "Cors",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CorsRule"
            }
          }
        }
      },
      defaultServiceVersion: {
        xmlName: "DefaultServiceVersion",
        serializedName: "DefaultServiceVersion",
        type: {
          name: "String"
        }
      },
      deleteRetentionPolicy: {
        xmlName: "DeleteRetentionPolicy",
        serializedName: "DeleteRetentionPolicy",
        type: {
          name: "Composite",
          className: "RetentionPolicy"
        }
      },
      staticWebsite: {
        xmlName: "StaticWebsite",
        serializedName: "StaticWebsite",
        type: {
          name: "Composite",
          className: "StaticWebsite"
        }
      }
    }
  }
}, BlobServiceStatistics = {
  xmlName: "StorageServiceStats",
  serializedName: "BlobServiceStatistics",
  type: {
    name: "Composite",
    className: "BlobServiceStatistics",
    modelProperties: {
      geoReplication: {
        xmlName: "GeoReplication",
        serializedName: "GeoReplication",
        type: {
          name: "Composite",
          className: "GeoReplication"
        }
      }
    }
  }
};
var ServiceSetPropertiesHeaders = {
  serializedName: "service-setproperties-headers",
  type: {
    name: "Composite",
    className: "ServiceSetPropertiesHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ServiceGetPropertiesHeaders = {
  serializedName: "service-getproperties-headers",
  type: {
    name: "Composite",
    className: "ServiceGetPropertiesHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ServiceGetStatisticsHeaders = {
  serializedName: "service-getstatistics-headers",
  type: {
    name: "Composite",
    className: "ServiceGetStatisticsHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ServiceListContainersSegmentHeaders = {
  serializedName: "service-listcontainerssegment-headers",
  type: {
    name: "Composite",
    className: "ServiceListContainersSegmentHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ServiceGetUserDelegationKeyHeaders = {
  serializedName: "service-getuserdelegationkey-headers",
  type: {
    name: "Composite",
    className: "ServiceGetUserDelegationKeyHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ServiceGetAccountInfoHeaders = {
  serializedName: "service-getaccountinfo-headers",
  type: {
    name: "Composite",
    className: "ServiceGetAccountInfoHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      skuName: {
        serializedName: "x-ms-sku-name",
        type: {
          name: "Enum",
          allowedValues: [
            "Standard_LRS",
            "Standard_GRS",
            "Standard_RAGRS",
            "Standard_ZRS",
            "Premium_LRS"
          ]
        }
      },
      accountKind: {
        serializedName: "x-ms-account-kind",
        type: {
          name: "Enum",
          allowedValues: [
            "Storage",
            "BlobStorage",
            "StorageV2",
            "FileStorage",
            "BlockBlobStorage"
          ]
        }
      },
      isHierarchicalNamespaceEnabled: {
        serializedName: "x-ms-is-hns-enabled",
        type: {
          name: "Boolean"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ServiceSubmitBatchHeaders = {
  serializedName: "service-submitbatch-headers",
  type: {
    name: "Composite",
    className: "ServiceSubmitBatchHeaders",
    modelProperties: {
      contentType: {
        serializedName: "content-type",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ServiceFilterBlobsHeaders = {
  serializedName: "service-filterblobs-headers",
  type: {
    name: "Composite",
    className: "ServiceFilterBlobsHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ContainerCreateHeaders = {
  serializedName: "container-create-headers",
  type: {
    name: "Composite",
    className: "ContainerCreateHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ContainerGetPropertiesHeaders = {
  serializedName: "container-getproperties-headers",
  type: {
    name: "Composite",
    className: "ContainerGetPropertiesHeaders",
    modelProperties: {
      metadata: {
        serializedName: "x-ms-meta",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "String"
            }
          }
        },
        headerCollectionPrefix: "x-ms-meta-"
      },
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseDuration: {
        serializedName: "x-ms-lease-duration",
        type: {
          name: "Enum",
          allowedValues: [
            "infinite",
            "fixed"
          ]
        }
      },
      leaseState: {
        serializedName: "x-ms-lease-state",
        type: {
          name: "Enum",
          allowedValues: [
            "available",
            "leased",
            "expired",
            "breaking",
            "broken"
          ]
        }
      },
      leaseStatus: {
        serializedName: "x-ms-lease-status",
        type: {
          name: "Enum",
          allowedValues: [
            "locked",
            "unlocked"
          ]
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobPublicAccess: {
        serializedName: "x-ms-blob-public-access",
        type: {
          name: "String"
        }
      },
      hasImmutabilityPolicy: {
        serializedName: "x-ms-has-immutability-policy",
        type: {
          name: "Boolean"
        }
      },
      hasLegalHold: {
        serializedName: "x-ms-has-legal-hold",
        type: {
          name: "Boolean"
        }
      },
      defaultEncryptionScope: {
        serializedName: "x-ms-default-encryption-scope",
        type: {
          name: "String"
        }
      },
      denyEncryptionScopeOverride: {
        serializedName: "x-ms-deny-encryption-scope-override",
        type: {
          name: "Boolean"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ContainerDeleteHeaders = {
  serializedName: "container-delete-headers",
  type: {
    name: "Composite",
    className: "ContainerDeleteHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ContainerSetMetadataHeaders = {
  serializedName: "container-setmetadata-headers",
  type: {
    name: "Composite",
    className: "ContainerSetMetadataHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ContainerGetAccessPolicyHeaders = {
  serializedName: "container-getaccesspolicy-headers",
  type: {
    name: "Composite",
    className: "ContainerGetAccessPolicyHeaders",
    modelProperties: {
      blobPublicAccess: {
        serializedName: "x-ms-blob-public-access",
        type: {
          name: "String"
        }
      },
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ContainerSetAccessPolicyHeaders = {
  serializedName: "container-setaccesspolicy-headers",
  type: {
    name: "Composite",
    className: "ContainerSetAccessPolicyHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ContainerRestoreHeaders = {
  serializedName: "container-restore-headers",
  type: {
    name: "Composite",
    className: "ContainerRestoreHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ContainerAcquireLeaseHeaders = {
  serializedName: "container-acquirelease-headers",
  type: {
    name: "Composite",
    className: "ContainerAcquireLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseId: {
        serializedName: "x-ms-lease-id",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ContainerReleaseLeaseHeaders = {
  serializedName: "container-releaselease-headers",
  type: {
    name: "Composite",
    className: "ContainerReleaseLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ContainerRenewLeaseHeaders = {
  serializedName: "container-renewlease-headers",
  type: {
    name: "Composite",
    className: "ContainerRenewLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseId: {
        serializedName: "x-ms-lease-id",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ContainerBreakLeaseHeaders = {
  serializedName: "container-breaklease-headers",
  type: {
    name: "Composite",
    className: "ContainerBreakLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseTime: {
        serializedName: "x-ms-lease-time",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ContainerChangeLeaseHeaders = {
  serializedName: "container-changelease-headers",
  type: {
    name: "Composite",
    className: "ContainerChangeLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseId: {
        serializedName: "x-ms-lease-id",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ContainerListBlobFlatSegmentHeaders = {
  serializedName: "container-listblobflatsegment-headers",
  type: {
    name: "Composite",
    className: "ContainerListBlobFlatSegmentHeaders",
    modelProperties: {
      contentType: {
        serializedName: "content-type",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ContainerListBlobHierarchySegmentHeaders = {
  serializedName: "container-listblobhierarchysegment-headers",
  type: {
    name: "Composite",
    className: "ContainerListBlobHierarchySegmentHeaders",
    modelProperties: {
      contentType: {
        serializedName: "content-type",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ContainerGetAccountInfoHeaders = {
  serializedName: "container-getaccountinfo-headers",
  type: {
    name: "Composite",
    className: "ContainerGetAccountInfoHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      skuName: {
        serializedName: "x-ms-sku-name",
        type: {
          name: "Enum",
          allowedValues: [
            "Standard_LRS",
            "Standard_GRS",
            "Standard_RAGRS",
            "Standard_ZRS",
            "Premium_LRS"
          ]
        }
      },
      accountKind: {
        serializedName: "x-ms-account-kind",
        type: {
          name: "Enum",
          allowedValues: [
            "Storage",
            "BlobStorage",
            "StorageV2",
            "FileStorage",
            "BlockBlobStorage"
          ]
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
};
var BlobDownloadHeaders = {
  serializedName: "blob-download-headers",
  type: {
    name: "Composite",
    className: "BlobDownloadHeaders",
    modelProperties: {
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      metadata: {
        serializedName: "x-ms-meta",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "String"
            }
          }
        },
        headerCollectionPrefix: "x-ms-meta-"
      },
      objectReplicationPolicyId: {
        serializedName: "x-ms-or-policy-id",
        type: {
          name: "String"
        }
      },
      objectReplicationRules: {
        serializedName: "x-ms-or",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "String"
            }
          }
        },
        headerCollectionPrefix: "x-ms-or-"
      },
      contentLength: {
        serializedName: "content-length",
        type: {
          name: "Number"
        }
      },
      contentType: {
        serializedName: "content-type",
        type: {
          name: "String"
        }
      },
      contentRange: {
        serializedName: "content-range",
        type: {
          name: "String"
        }
      },
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      contentEncoding: {
        serializedName: "content-encoding",
        type: {
          name: "String"
        }
      },
      cacheControl: {
        serializedName: "cache-control",
        type: {
          name: "String"
        }
      },
      contentDisposition: {
        serializedName: "content-disposition",
        type: {
          name: "String"
        }
      },
      contentLanguage: {
        serializedName: "content-language",
        type: {
          name: "String"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      blobType: {
        serializedName: "x-ms-blob-type",
        type: {
          name: "Enum",
          allowedValues: [
            "BlockBlob",
            "PageBlob",
            "AppendBlob"
          ]
        }
      },
      copyCompletedOn: {
        serializedName: "x-ms-copy-completion-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      copyStatusDescription: {
        serializedName: "x-ms-copy-status-description",
        type: {
          name: "String"
        }
      },
      copyId: {
        serializedName: "x-ms-copy-id",
        type: {
          name: "String"
        }
      },
      copyProgress: {
        serializedName: "x-ms-copy-progress",
        type: {
          name: "String"
        }
      },
      copySource: {
        serializedName: "x-ms-copy-source",
        type: {
          name: "String"
        }
      },
      copyStatus: {
        serializedName: "x-ms-copy-status",
        type: {
          name: "Enum",
          allowedValues: [
            "pending",
            "success",
            "aborted",
            "failed"
          ]
        }
      },
      leaseDuration: {
        serializedName: "x-ms-lease-duration",
        type: {
          name: "Enum",
          allowedValues: [
            "infinite",
            "fixed"
          ]
        }
      },
      leaseState: {
        serializedName: "x-ms-lease-state",
        type: {
          name: "Enum",
          allowedValues: [
            "available",
            "leased",
            "expired",
            "breaking",
            "broken"
          ]
        }
      },
      leaseStatus: {
        serializedName: "x-ms-lease-status",
        type: {
          name: "Enum",
          allowedValues: [
            "locked",
            "unlocked"
          ]
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      acceptRanges: {
        serializedName: "accept-ranges",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobCommittedBlockCount: {
        serializedName: "x-ms-blob-committed-block-count",
        type: {
          name: "Number"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      blobContentMD5: {
        serializedName: "x-ms-blob-content-md5",
        type: {
          name: "ByteArray"
        }
      },
      tagCount: {
        serializedName: "x-ms-tag-count",
        type: {
          name: "Number"
        }
      },
      isSealed: {
        serializedName: "x-ms-blob-sealed",
        type: {
          name: "Boolean"
        }
      },
      lastAccessed: {
        serializedName: "x-ms-last-access-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentCrc64: {
        serializedName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobGetPropertiesHeaders = {
  serializedName: "blob-getproperties-headers",
  type: {
    name: "Composite",
    className: "BlobGetPropertiesHeaders",
    modelProperties: {
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      createdOn: {
        serializedName: "x-ms-creation-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      metadata: {
        serializedName: "x-ms-meta",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "String"
            }
          }
        },
        headerCollectionPrefix: "x-ms-meta-"
      },
      objectReplicationPolicyId: {
        serializedName: "x-ms-or-policy-id",
        type: {
          name: "String"
        }
      },
      objectReplicationRules: {
        serializedName: "x-ms-or",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "String"
            }
          }
        },
        headerCollectionPrefix: "x-ms-or-"
      },
      blobType: {
        serializedName: "x-ms-blob-type",
        type: {
          name: "Enum",
          allowedValues: [
            "BlockBlob",
            "PageBlob",
            "AppendBlob"
          ]
        }
      },
      copyCompletedOn: {
        serializedName: "x-ms-copy-completion-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      copyStatusDescription: {
        serializedName: "x-ms-copy-status-description",
        type: {
          name: "String"
        }
      },
      copyId: {
        serializedName: "x-ms-copy-id",
        type: {
          name: "String"
        }
      },
      copyProgress: {
        serializedName: "x-ms-copy-progress",
        type: {
          name: "String"
        }
      },
      copySource: {
        serializedName: "x-ms-copy-source",
        type: {
          name: "String"
        }
      },
      copyStatus: {
        serializedName: "x-ms-copy-status",
        type: {
          name: "Enum",
          allowedValues: [
            "pending",
            "success",
            "aborted",
            "failed"
          ]
        }
      },
      isIncrementalCopy: {
        serializedName: "x-ms-incremental-copy",
        type: {
          name: "Boolean"
        }
      },
      destinationSnapshot: {
        serializedName: "x-ms-copy-destination-snapshot",
        type: {
          name: "String"
        }
      },
      leaseDuration: {
        serializedName: "x-ms-lease-duration",
        type: {
          name: "Enum",
          allowedValues: [
            "infinite",
            "fixed"
          ]
        }
      },
      leaseState: {
        serializedName: "x-ms-lease-state",
        type: {
          name: "Enum",
          allowedValues: [
            "available",
            "leased",
            "expired",
            "breaking",
            "broken"
          ]
        }
      },
      leaseStatus: {
        serializedName: "x-ms-lease-status",
        type: {
          name: "Enum",
          allowedValues: [
            "locked",
            "unlocked"
          ]
        }
      },
      contentLength: {
        serializedName: "content-length",
        type: {
          name: "Number"
        }
      },
      contentType: {
        serializedName: "content-type",
        type: {
          name: "String"
        }
      },
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      contentEncoding: {
        serializedName: "content-encoding",
        type: {
          name: "String"
        }
      },
      contentDisposition: {
        serializedName: "content-disposition",
        type: {
          name: "String"
        }
      },
      contentLanguage: {
        serializedName: "content-language",
        type: {
          name: "String"
        }
      },
      cacheControl: {
        serializedName: "cache-control",
        type: {
          name: "String"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      acceptRanges: {
        serializedName: "accept-ranges",
        type: {
          name: "String"
        }
      },
      blobCommittedBlockCount: {
        serializedName: "x-ms-blob-committed-block-count",
        type: {
          name: "Number"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      accessTier: {
        serializedName: "x-ms-access-tier",
        type: {
          name: "String"
        }
      },
      accessTierInferred: {
        serializedName: "x-ms-access-tier-inferred",
        type: {
          name: "Boolean"
        }
      },
      archiveStatus: {
        serializedName: "x-ms-archive-status",
        type: {
          name: "String"
        }
      },
      accessTierChangedOn: {
        serializedName: "x-ms-access-tier-change-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      isCurrentVersion: {
        serializedName: "x-ms-is-current-version",
        type: {
          name: "Boolean"
        }
      },
      tagCount: {
        serializedName: "x-ms-tag-count",
        type: {
          name: "Number"
        }
      },
      expiresOn: {
        serializedName: "x-ms-expiry-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isSealed: {
        serializedName: "x-ms-blob-sealed",
        type: {
          name: "Boolean"
        }
      },
      rehydratePriority: {
        serializedName: "x-ms-rehydrate-priority",
        type: {
          name: "String"
        }
      },
      lastAccessed: {
        serializedName: "x-ms-last-access-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobDeleteHeaders = {
  serializedName: "blob-delete-headers",
  type: {
    name: "Composite",
    className: "BlobDeleteHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobSetAccessControlHeaders = {
  serializedName: "blob-setaccesscontrol-headers",
  type: {
    name: "Composite",
    className: "BlobSetAccessControlHeaders",
    modelProperties: {
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobGetAccessControlHeaders = {
  serializedName: "blob-getaccesscontrol-headers",
  type: {
    name: "Composite",
    className: "BlobGetAccessControlHeaders",
    modelProperties: {
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      xMsOwner: {
        serializedName: "x-ms-owner",
        type: {
          name: "String"
        }
      },
      xMsGroup: {
        serializedName: "x-ms-group",
        type: {
          name: "String"
        }
      },
      xMsPermissions: {
        serializedName: "x-ms-permissions",
        type: {
          name: "String"
        }
      },
      xMsAcl: {
        serializedName: "x-ms-acl",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobRenameHeaders = {
  serializedName: "blob-rename-headers",
  type: {
    name: "Composite",
    className: "BlobRenameHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      contentLength: {
        serializedName: "content-length",
        type: {
          name: "Number"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, PageBlobCreateHeaders = {
  serializedName: "pageblob-create-headers",
  type: {
    name: "Composite",
    className: "PageBlobCreateHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, AppendBlobCreateHeaders = {
  serializedName: "appendblob-create-headers",
  type: {
    name: "Composite",
    className: "AppendBlobCreateHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlockBlobUploadHeaders = {
  serializedName: "blockblob-upload-headers",
  type: {
    name: "Composite",
    className: "BlockBlobUploadHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlockBlobPutBlobFromUrlHeaders = {
  serializedName: "blockblob-putblobfromurl-headers",
  type: {
    name: "Composite",
    className: "BlockBlobPutBlobFromUrlHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobUndeleteHeaders = {
  serializedName: "blob-undelete-headers",
  type: {
    name: "Composite",
    className: "BlobUndeleteHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobSetExpiryHeaders = {
  serializedName: "blob-setexpiry-headers",
  type: {
    name: "Composite",
    className: "BlobSetExpiryHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobSetHTTPHeadersHeaders = {
  serializedName: "blob-sethttpheaders-headers",
  type: {
    name: "Composite",
    className: "BlobSetHTTPHeadersHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobSetMetadataHeaders = {
  serializedName: "blob-setmetadata-headers",
  type: {
    name: "Composite",
    className: "BlobSetMetadataHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobAcquireLeaseHeaders = {
  serializedName: "blob-acquirelease-headers",
  type: {
    name: "Composite",
    className: "BlobAcquireLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseId: {
        serializedName: "x-ms-lease-id",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobReleaseLeaseHeaders = {
  serializedName: "blob-releaselease-headers",
  type: {
    name: "Composite",
    className: "BlobReleaseLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobRenewLeaseHeaders = {
  serializedName: "blob-renewlease-headers",
  type: {
    name: "Composite",
    className: "BlobRenewLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseId: {
        serializedName: "x-ms-lease-id",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobChangeLeaseHeaders = {
  serializedName: "blob-changelease-headers",
  type: {
    name: "Composite",
    className: "BlobChangeLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      leaseId: {
        serializedName: "x-ms-lease-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobBreakLeaseHeaders = {
  serializedName: "blob-breaklease-headers",
  type: {
    name: "Composite",
    className: "BlobBreakLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseTime: {
        serializedName: "x-ms-lease-time",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobCreateSnapshotHeaders = {
  serializedName: "blob-createsnapshot-headers",
  type: {
    name: "Composite",
    className: "BlobCreateSnapshotHeaders",
    modelProperties: {
      snapshot: {
        serializedName: "x-ms-snapshot",
        type: {
          name: "String"
        }
      },
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobStartCopyFromURLHeaders = {
  serializedName: "blob-startcopyfromurl-headers",
  type: {
    name: "Composite",
    className: "BlobStartCopyFromURLHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      copyId: {
        serializedName: "x-ms-copy-id",
        type: {
          name: "String"
        }
      },
      copyStatus: {
        serializedName: "x-ms-copy-status",
        type: {
          name: "Enum",
          allowedValues: [
            "pending",
            "success",
            "aborted",
            "failed"
          ]
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobCopyFromURLHeaders = {
  serializedName: "blob-copyfromurl-headers",
  type: {
    name: "Composite",
    className: "BlobCopyFromURLHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      copyId: {
        serializedName: "x-ms-copy-id",
        type: {
          name: "String"
        }
      },
      copyStatus: {
        serializedName: "x-ms-copy-status",
        type: {
          name: "Enum",
          allowedValues: [
            "success"
          ]
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobAbortCopyFromURLHeaders = {
  serializedName: "blob-abortcopyfromurl-headers",
  type: {
    name: "Composite",
    className: "BlobAbortCopyFromURLHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobSetTierHeaders = {
  serializedName: "blob-settier-headers",
  type: {
    name: "Composite",
    className: "BlobSetTierHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobGetAccountInfoHeaders = {
  serializedName: "blob-getaccountinfo-headers",
  type: {
    name: "Composite",
    className: "BlobGetAccountInfoHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      skuName: {
        serializedName: "x-ms-sku-name",
        type: {
          name: "Enum",
          allowedValues: [
            "Standard_LRS",
            "Standard_GRS",
            "Standard_RAGRS",
            "Standard_ZRS",
            "Premium_LRS"
          ]
        }
      },
      accountKind: {
        serializedName: "x-ms-account-kind",
        type: {
          name: "Enum",
          allowedValues: [
            "Storage",
            "BlobStorage",
            "StorageV2",
            "FileStorage",
            "BlockBlobStorage"
          ]
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlockBlobStageBlockHeaders = {
  serializedName: "blockblob-stageblock-headers",
  type: {
    name: "Composite",
    className: "BlockBlobStageBlockHeaders",
    modelProperties: {
      contentMD5: {
        serializedName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlockBlobStageBlockFromURLHeaders = {
  serializedName: "blockblob-stageblockfromurl-headers",
  type: {
    name: "Composite",
    className: "BlockBlobStageBlockFromURLHeaders",
    modelProperties: {
      contentMD5: {
        serializedName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlockBlobCommitBlockListHeaders = {
  serializedName: "blockblob-commitblocklist-headers",
  type: {
    name: "Composite",
    className: "BlockBlobCommitBlockListHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlockBlobGetBlockListHeaders = {
  serializedName: "blockblob-getblocklist-headers",
  type: {
    name: "Composite",
    className: "BlockBlobGetBlockListHeaders",
    modelProperties: {
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      contentType: {
        serializedName: "content-type",
        type: {
          name: "String"
        }
      },
      blobContentLength: {
        serializedName: "x-ms-blob-content-length",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, PageBlobUploadPagesHeaders = {
  serializedName: "pageblob-uploadpages-headers",
  type: {
    name: "Composite",
    className: "PageBlobUploadPagesHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, PageBlobClearPagesHeaders = {
  serializedName: "pageblob-clearpages-headers",
  type: {
    name: "Composite",
    className: "PageBlobClearPagesHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, PageBlobUploadPagesFromURLHeaders = {
  serializedName: "pageblob-uploadpagesfromurl-headers",
  type: {
    name: "Composite",
    className: "PageBlobUploadPagesFromURLHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, PageBlobGetPageRangesHeaders = {
  serializedName: "pageblob-getpageranges-headers",
  type: {
    name: "Composite",
    className: "PageBlobGetPageRangesHeaders",
    modelProperties: {
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      blobContentLength: {
        serializedName: "x-ms-blob-content-length",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, PageBlobGetPageRangesDiffHeaders = {
  serializedName: "pageblob-getpagerangesdiff-headers",
  type: {
    name: "Composite",
    className: "PageBlobGetPageRangesDiffHeaders",
    modelProperties: {
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      blobContentLength: {
        serializedName: "x-ms-blob-content-length",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, PageBlobResizeHeaders = {
  serializedName: "pageblob-resize-headers",
  type: {
    name: "Composite",
    className: "PageBlobResizeHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, PageBlobUpdateSequenceNumberHeaders = {
  serializedName: "pageblob-updatesequencenumber-headers",
  type: {
    name: "Composite",
    className: "PageBlobUpdateSequenceNumberHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, PageBlobCopyIncrementalHeaders = {
  serializedName: "pageblob-copyincremental-headers",
  type: {
    name: "Composite",
    className: "PageBlobCopyIncrementalHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      copyId: {
        serializedName: "x-ms-copy-id",
        type: {
          name: "String"
        }
      },
      copyStatus: {
        serializedName: "x-ms-copy-status",
        type: {
          name: "Enum",
          allowedValues: [
            "pending",
            "success",
            "aborted",
            "failed"
          ]
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, AppendBlobAppendBlockHeaders = {
  serializedName: "appendblob-appendblock-headers",
  type: {
    name: "Composite",
    className: "AppendBlobAppendBlockHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobAppendOffset: {
        serializedName: "x-ms-blob-append-offset",
        type: {
          name: "String"
        }
      },
      blobCommittedBlockCount: {
        serializedName: "x-ms-blob-committed-block-count",
        type: {
          name: "Number"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, AppendBlobAppendBlockFromUrlHeaders = {
  serializedName: "appendblob-appendblockfromurl-headers",
  type: {
    name: "Composite",
    className: "AppendBlobAppendBlockFromUrlHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobAppendOffset: {
        serializedName: "x-ms-blob-append-offset",
        type: {
          name: "String"
        }
      },
      blobCommittedBlockCount: {
        serializedName: "x-ms-blob-committed-block-count",
        type: {
          name: "Number"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, AppendBlobSealHeaders = {
  serializedName: "appendblob-seal-headers",
  type: {
    name: "Composite",
    className: "AppendBlobSealHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isSealed: {
        serializedName: "x-ms-blob-sealed",
        type: {
          name: "Boolean"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobQueryHeaders = {
  serializedName: "blob-query-headers",
  type: {
    name: "Composite",
    className: "BlobQueryHeaders",
    modelProperties: {
      lastModified: {
        serializedName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      metadata: {
        serializedName: "x-ms-meta",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "String"
            }
          }
        },
        headerCollectionPrefix: "x-ms-meta-"
      },
      contentLength: {
        serializedName: "content-length",
        type: {
          name: "Number"
        }
      },
      contentType: {
        serializedName: "content-type",
        type: {
          name: "String"
        }
      },
      contentRange: {
        serializedName: "content-range",
        type: {
          name: "String"
        }
      },
      etag: {
        serializedName: "etag",
        type: {
          name: "String"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      contentEncoding: {
        serializedName: "content-encoding",
        type: {
          name: "String"
        }
      },
      cacheControl: {
        serializedName: "cache-control",
        type: {
          name: "String"
        }
      },
      contentDisposition: {
        serializedName: "content-disposition",
        type: {
          name: "String"
        }
      },
      contentLanguage: {
        serializedName: "content-language",
        type: {
          name: "String"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      blobType: {
        serializedName: "x-ms-blob-type",
        type: {
          name: "Enum",
          allowedValues: [
            "BlockBlob",
            "PageBlob",
            "AppendBlob"
          ]
        }
      },
      copyCompletionTime: {
        serializedName: "x-ms-copy-completion-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      copyStatusDescription: {
        serializedName: "x-ms-copy-status-description",
        type: {
          name: "String"
        }
      },
      copyId: {
        serializedName: "x-ms-copy-id",
        type: {
          name: "String"
        }
      },
      copyProgress: {
        serializedName: "x-ms-copy-progress",
        type: {
          name: "String"
        }
      },
      copySource: {
        serializedName: "x-ms-copy-source",
        type: {
          name: "String"
        }
      },
      copyStatus: {
        serializedName: "x-ms-copy-status",
        type: {
          name: "Enum",
          allowedValues: [
            "pending",
            "success",
            "aborted",
            "failed"
          ]
        }
      },
      leaseDuration: {
        serializedName: "x-ms-lease-duration",
        type: {
          name: "Enum",
          allowedValues: [
            "infinite",
            "fixed"
          ]
        }
      },
      leaseState: {
        serializedName: "x-ms-lease-state",
        type: {
          name: "Enum",
          allowedValues: [
            "available",
            "leased",
            "expired",
            "breaking",
            "broken"
          ]
        }
      },
      leaseStatus: {
        serializedName: "x-ms-lease-status",
        type: {
          name: "Enum",
          allowedValues: [
            "locked",
            "unlocked"
          ]
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      acceptRanges: {
        serializedName: "accept-ranges",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobCommittedBlockCount: {
        serializedName: "x-ms-blob-committed-block-count",
        type: {
          name: "Number"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      blobContentMD5: {
        serializedName: "x-ms-blob-content-md5",
        type: {
          name: "ByteArray"
        }
      },
      contentCrc64: {
        serializedName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobGetTagsHeaders = {
  serializedName: "blob-gettags-headers",
  type: {
    name: "Composite",
    className: "BlobGetTagsHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BlobSetTagsHeaders = {
  serializedName: "blob-settags-headers",
  type: {
    name: "Composite",
    className: "BlobSetTagsHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
};

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/generated/src/models/parameters.js
var access = {
  parameterPath: [
    "options",
    "access"
  ],
  mapper: {
    serializedName: "x-ms-blob-public-access",
    type: {
      name: "String"
    }
  }
}, action0 = {
  parameterPath: "action",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "x-ms-lease-action",
    defaultValue: "acquire",
    type: {
      name: "String"
    }
  }
}, action1 = {
  parameterPath: "action",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "x-ms-lease-action",
    defaultValue: "release",
    type: {
      name: "String"
    }
  }
}, action2 = {
  parameterPath: "action",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "x-ms-lease-action",
    defaultValue: "renew",
    type: {
      name: "String"
    }
  }
}, action3 = {
  parameterPath: "action",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "x-ms-lease-action",
    defaultValue: "break",
    type: {
      name: "String"
    }
  }
}, action4 = {
  parameterPath: "action",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "x-ms-lease-action",
    defaultValue: "change",
    type: {
      name: "String"
    }
  }
}, action5 = {
  parameterPath: "action",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "action",
    defaultValue: "setAccessControl",
    type: {
      name: "String"
    }
  }
}, action6 = {
  parameterPath: "action",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "action",
    defaultValue: "getAccessControl",
    type: {
      name: "String"
    }
  }
}, appendPosition = {
  parameterPath: [
    "options",
    "appendPositionAccessConditions",
    "appendPosition"
  ],
  mapper: {
    serializedName: "x-ms-blob-condition-appendpos",
    type: {
      name: "Number"
    }
  }
}, blobCacheControl = {
  parameterPath: [
    "options",
    "blobHTTPHeaders",
    "blobCacheControl"
  ],
  mapper: {
    serializedName: "x-ms-blob-cache-control",
    type: {
      name: "String"
    }
  }
}, blobContentDisposition = {
  parameterPath: [
    "options",
    "blobHTTPHeaders",
    "blobContentDisposition"
  ],
  mapper: {
    serializedName: "x-ms-blob-content-disposition",
    type: {
      name: "String"
    }
  }
}, blobContentEncoding = {
  parameterPath: [
    "options",
    "blobHTTPHeaders",
    "blobContentEncoding"
  ],
  mapper: {
    serializedName: "x-ms-blob-content-encoding",
    type: {
      name: "String"
    }
  }
}, blobContentLanguage = {
  parameterPath: [
    "options",
    "blobHTTPHeaders",
    "blobContentLanguage"
  ],
  mapper: {
    serializedName: "x-ms-blob-content-language",
    type: {
      name: "String"
    }
  }
}, blobContentLength = {
  parameterPath: "blobContentLength",
  mapper: {
    required: !0,
    serializedName: "x-ms-blob-content-length",
    type: {
      name: "Number"
    }
  }
}, blobContentMD5 = {
  parameterPath: [
    "options",
    "blobHTTPHeaders",
    "blobContentMD5"
  ],
  mapper: {
    serializedName: "x-ms-blob-content-md5",
    type: {
      name: "ByteArray"
    }
  }
}, blobContentType = {
  parameterPath: [
    "options",
    "blobHTTPHeaders",
    "blobContentType"
  ],
  mapper: {
    serializedName: "x-ms-blob-content-type",
    type: {
      name: "String"
    }
  }
}, blobDeleteType = {
  parameterPath: [
    "options",
    "blobDeleteType"
  ],
  mapper: {
    serializedName: "deletetype",
    type: {
      name: "Enum",
      allowedValues: [
        "Permanent"
      ]
    }
  }
}, blobSequenceNumber = {
  parameterPath: [
    "options",
    "blobSequenceNumber"
  ],
  mapper: {
    serializedName: "x-ms-blob-sequence-number",
    defaultValue: 0,
    type: {
      name: "Number"
    }
  }
}, blobTagsString = {
  parameterPath: [
    "options",
    "blobTagsString"
  ],
  mapper: {
    serializedName: "x-ms-tags",
    type: {
      name: "String"
    }
  }
}, blobType0 = {
  parameterPath: "blobType",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "x-ms-blob-type",
    defaultValue: "PageBlob",
    type: {
      name: "String"
    }
  }
}, blobType1 = {
  parameterPath: "blobType",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "x-ms-blob-type",
    defaultValue: "AppendBlob",
    type: {
      name: "String"
    }
  }
}, blobType2 = {
  parameterPath: "blobType",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "x-ms-blob-type",
    defaultValue: "BlockBlob",
    type: {
      name: "String"
    }
  }
}, blockId = {
  parameterPath: "blockId",
  mapper: {
    required: !0,
    serializedName: "blockid",
    type: {
      name: "String"
    }
  }
}, breakPeriod = {
  parameterPath: [
    "options",
    "breakPeriod"
  ],
  mapper: {
    serializedName: "x-ms-lease-break-period",
    type: {
      name: "Number"
    }
  }
}, cacheControl = {
  parameterPath: [
    "options",
    "directoryHttpHeaders",
    "cacheControl"
  ],
  mapper: {
    serializedName: "x-ms-cache-control",
    type: {
      name: "String"
    }
  }
}, comp0 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "properties",
    type: {
      name: "String"
    }
  }
}, comp1 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "stats",
    type: {
      name: "String"
    }
  }
}, comp10 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "expiry",
    type: {
      name: "String"
    }
  }
}, comp11 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "snapshot",
    type: {
      name: "String"
    }
  }
}, comp12 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "copy",
    type: {
      name: "String"
    }
  }
}, comp13 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "tier",
    type: {
      name: "String"
    }
  }
}, comp14 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "query",
    type: {
      name: "String"
    }
  }
}, comp15 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "tags",
    type: {
      name: "String"
    }
  }
}, comp16 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "page",
    type: {
      name: "String"
    }
  }
}, comp17 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "pagelist",
    type: {
      name: "String"
    }
  }
}, comp18 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "incrementalcopy",
    type: {
      name: "String"
    }
  }
}, comp19 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "appendblock",
    type: {
      name: "String"
    }
  }
}, comp2 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "list",
    type: {
      name: "String"
    }
  }
}, comp20 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "seal",
    type: {
      name: "String"
    }
  }
}, comp21 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "block",
    type: {
      name: "String"
    }
  }
}, comp22 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "blocklist",
    type: {
      name: "String"
    }
  }
}, comp3 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "userdelegationkey",
    type: {
      name: "String"
    }
  }
}, comp4 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "batch",
    type: {
      name: "String"
    }
  }
}, comp5 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "blobs",
    type: {
      name: "String"
    }
  }
}, comp6 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "metadata",
    type: {
      name: "String"
    }
  }
}, comp7 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "acl",
    type: {
      name: "String"
    }
  }
}, comp8 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "undelete",
    type: {
      name: "String"
    }
  }
}, comp9 = {
  parameterPath: "comp",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "comp",
    defaultValue: "lease",
    type: {
      name: "String"
    }
  }
}, contentDisposition = {
  parameterPath: [
    "options",
    "directoryHttpHeaders",
    "contentDisposition"
  ],
  mapper: {
    serializedName: "x-ms-content-disposition",
    type: {
      name: "String"
    }
  }
}, contentEncoding = {
  parameterPath: [
    "options",
    "directoryHttpHeaders",
    "contentEncoding"
  ],
  mapper: {
    serializedName: "x-ms-content-encoding",
    type: {
      name: "String"
    }
  }
}, contentLanguage = {
  parameterPath: [
    "options",
    "directoryHttpHeaders",
    "contentLanguage"
  ],
  mapper: {
    serializedName: "x-ms-content-language",
    type: {
      name: "String"
    }
  }
}, contentLength = {
  parameterPath: "contentLength",
  mapper: {
    required: !0,
    serializedName: "Content-Length",
    type: {
      name: "Number"
    }
  }
}, contentType = {
  parameterPath: [
    "options",
    "directoryHttpHeaders",
    "contentType"
  ],
  mapper: {
    serializedName: "x-ms-content-type",
    type: {
      name: "String"
    }
  }
}, copyActionAbortConstant = {
  parameterPath: "copyActionAbortConstant",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "x-ms-copy-action",
    defaultValue: "abort",
    type: {
      name: "String"
    }
  }
}, copyId = {
  parameterPath: "copyId",
  mapper: {
    required: !0,
    serializedName: "copyid",
    type: {
      name: "String"
    }
  }
}, copySource = {
  parameterPath: "copySource",
  mapper: {
    required: !0,
    serializedName: "x-ms-copy-source",
    type: {
      name: "String"
    }
  }
}, copySourceBlobProperties = {
  parameterPath: [
    "options",
    "copySourceBlobProperties"
  ],
  mapper: {
    serializedName: "x-ms-copy-source-blob-properties",
    type: {
      name: "Boolean"
    }
  }
}, defaultEncryptionScope = {
  parameterPath: [
    "options",
    "containerEncryptionScope",
    "defaultEncryptionScope"
  ],
  mapper: {
    serializedName: "x-ms-default-encryption-scope",
    type: {
      name: "String"
    }
  }
}, deletedContainerName = {
  parameterPath: [
    "options",
    "deletedContainerName"
  ],
  mapper: {
    serializedName: "x-ms-deleted-container-name",
    type: {
      name: "String"
    }
  }
}, deletedContainerVersion = {
  parameterPath: [
    "options",
    "deletedContainerVersion"
  ],
  mapper: {
    serializedName: "x-ms-deleted-container-version",
    type: {
      name: "String"
    }
  }
}, deleteSnapshots = {
  parameterPath: [
    "options",
    "deleteSnapshots"
  ],
  mapper: {
    serializedName: "x-ms-delete-snapshots",
    type: {
      name: "Enum",
      allowedValues: [
        "include",
        "only"
      ]
    }
  }
}, delimiter = {
  parameterPath: "delimiter",
  mapper: {
    required: !0,
    serializedName: "delimiter",
    type: {
      name: "String"
    }
  }
}, directoryProperties = {
  parameterPath: [
    "options",
    "directoryProperties"
  ],
  mapper: {
    serializedName: "x-ms-properties",
    type: {
      name: "String"
    }
  }
}, duration = {
  parameterPath: [
    "options",
    "duration"
  ],
  mapper: {
    serializedName: "x-ms-lease-duration",
    type: {
      name: "Number"
    }
  }
}, encryptionAlgorithm = {
  parameterPath: [
    "options",
    "cpkInfo",
    "encryptionAlgorithm"
  ],
  mapper: {
    serializedName: "x-ms-encryption-algorithm",
    type: {
      name: "Enum",
      allowedValues: [
        "AES256"
      ]
    }
  }
}, encryptionKey = {
  parameterPath: [
    "options",
    "cpkInfo",
    "encryptionKey"
  ],
  mapper: {
    serializedName: "x-ms-encryption-key",
    type: {
      name: "String"
    }
  }
}, encryptionKeySha256 = {
  parameterPath: [
    "options",
    "cpkInfo",
    "encryptionKeySha256"
  ],
  mapper: {
    serializedName: "x-ms-encryption-key-sha256",
    type: {
      name: "String"
    }
  }
}, encryptionScope = {
  parameterPath: [
    "options",
    "encryptionScope"
  ],
  mapper: {
    serializedName: "x-ms-encryption-scope",
    type: {
      name: "String"
    }
  }
}, expiresOn = {
  parameterPath: [
    "options",
    "expiresOn"
  ],
  mapper: {
    serializedName: "x-ms-expiry-time",
    type: {
      name: "String"
    }
  }
}, expiryOptions = {
  parameterPath: "expiryOptions",
  mapper: {
    required: !0,
    serializedName: "x-ms-expiry-option",
    type: {
      name: "String"
    }
  }
}, group = {
  parameterPath: [
    "options",
    "group"
  ],
  mapper: {
    serializedName: "x-ms-group",
    type: {
      name: "String"
    }
  }
}, ifMatch = {
  parameterPath: [
    "options",
    "modifiedAccessConditions",
    "ifMatch"
  ],
  mapper: {
    serializedName: "If-Match",
    type: {
      name: "String"
    }
  }
}, ifModifiedSince = {
  parameterPath: [
    "options",
    "modifiedAccessConditions",
    "ifModifiedSince"
  ],
  mapper: {
    serializedName: "If-Modified-Since",
    type: {
      name: "DateTimeRfc1123"
    }
  }
}, ifNoneMatch = {
  parameterPath: [
    "options",
    "modifiedAccessConditions",
    "ifNoneMatch"
  ],
  mapper: {
    serializedName: "If-None-Match",
    type: {
      name: "String"
    }
  }
}, ifSequenceNumberEqualTo = {
  parameterPath: [
    "options",
    "sequenceNumberAccessConditions",
    "ifSequenceNumberEqualTo"
  ],
  mapper: {
    serializedName: "x-ms-if-sequence-number-eq",
    type: {
      name: "Number"
    }
  }
}, ifSequenceNumberLessThan = {
  parameterPath: [
    "options",
    "sequenceNumberAccessConditions",
    "ifSequenceNumberLessThan"
  ],
  mapper: {
    serializedName: "x-ms-if-sequence-number-lt",
    type: {
      name: "Number"
    }
  }
}, ifSequenceNumberLessThanOrEqualTo = {
  parameterPath: [
    "options",
    "sequenceNumberAccessConditions",
    "ifSequenceNumberLessThanOrEqualTo"
  ],
  mapper: {
    serializedName: "x-ms-if-sequence-number-le",
    type: {
      name: "Number"
    }
  }
}, ifTags = {
  parameterPath: [
    "options",
    "modifiedAccessConditions",
    "ifTags"
  ],
  mapper: {
    serializedName: "x-ms-if-tags",
    type: {
      name: "String"
    }
  }
}, ifUnmodifiedSince = {
  parameterPath: [
    "options",
    "modifiedAccessConditions",
    "ifUnmodifiedSince"
  ],
  mapper: {
    serializedName: "If-Unmodified-Since",
    type: {
      name: "DateTimeRfc1123"
    }
  }
}, include0 = {
  parameterPath: [
    "options",
    "include"
  ],
  mapper: {
    serializedName: "include",
    type: {
      name: "Sequence",
      element: {
        type: {
          name: "Enum",
          allowedValues: [
            "metadata",
            "deleted"
          ]
        }
      }
    }
  },
  collectionFormat: QueryCollectionFormat.Csv
}, include1 = {
  parameterPath: [
    "options",
    "include"
  ],
  mapper: {
    serializedName: "include",
    type: {
      name: "Sequence",
      element: {
        type: {
          name: "Enum",
          allowedValues: [
            "copy",
            "deleted",
            "metadata",
            "snapshots",
            "uncommittedblobs",
            "versions",
            "tags"
          ]
        }
      }
    }
  },
  collectionFormat: QueryCollectionFormat.Csv
}, leaseId0 = {
  parameterPath: [
    "options",
    "leaseAccessConditions",
    "leaseId"
  ],
  mapper: {
    serializedName: "x-ms-lease-id",
    type: {
      name: "String"
    }
  }
}, leaseId1 = {
  parameterPath: "leaseId",
  mapper: {
    required: !0,
    serializedName: "x-ms-lease-id",
    type: {
      name: "String"
    }
  }
}, listType = {
  parameterPath: "listType",
  mapper: {
    required: !0,
    serializedName: "blocklisttype",
    defaultValue: "committed",
    type: {
      name: "Enum",
      allowedValues: [
        "committed",
        "uncommitted",
        "all"
      ]
    }
  }
}, marker0 = {
  parameterPath: [
    "options",
    "marker"
  ],
  mapper: {
    serializedName: "marker",
    type: {
      name: "String"
    }
  }
};
var maxPageSize = {
  parameterPath: [
    "options",
    "maxPageSize"
  ],
  mapper: {
    serializedName: "maxresults",
    constraints: {
      InclusiveMinimum: 1
    },
    type: {
      name: "Number"
    }
  }
}, maxSize = {
  parameterPath: [
    "options",
    "appendPositionAccessConditions",
    "maxSize"
  ],
  mapper: {
    serializedName: "x-ms-blob-condition-maxsize",
    type: {
      name: "Number"
    }
  }
}, metadata = {
  parameterPath: [
    "options",
    "metadata"
  ],
  mapper: {
    serializedName: "x-ms-meta",
    type: {
      name: "Dictionary",
      value: {
        type: {
          name: "String"
        }
      }
    },
    headerCollectionPrefix: "x-ms-meta-"
  }
}, multipartContentType = {
  parameterPath: "multipartContentType",
  mapper: {
    required: !0,
    serializedName: "Content-Type",
    type: {
      name: "String"
    }
  }
}, owner = {
  parameterPath: [
    "options",
    "owner"
  ],
  mapper: {
    serializedName: "x-ms-owner",
    type: {
      name: "String"
    }
  }
}, pageWrite0 = {
  parameterPath: "pageWrite",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "x-ms-page-write",
    defaultValue: "update",
    type: {
      name: "String"
    }
  }
}, pageWrite1 = {
  parameterPath: "pageWrite",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "x-ms-page-write",
    defaultValue: "clear",
    type: {
      name: "String"
    }
  }
}, pathRenameMode = {
  parameterPath: [
    "options",
    "pathRenameMode"
  ],
  mapper: {
    serializedName: "mode",
    type: {
      name: "Enum",
      allowedValues: [
        "legacy",
        "posix"
      ]
    }
  }
}, posixAcl = {
  parameterPath: [
    "options",
    "posixAcl"
  ],
  mapper: {
    serializedName: "x-ms-acl",
    type: {
      name: "String"
    }
  }
}, posixPermissions = {
  parameterPath: [
    "options",
    "posixPermissions"
  ],
  mapper: {
    serializedName: "x-ms-permissions",
    type: {
      name: "String"
    }
  }
}, posixUmask = {
  parameterPath: [
    "options",
    "posixUmask"
  ],
  mapper: {
    serializedName: "x-ms-umask",
    type: {
      name: "String"
    }
  }
}, prefix = {
  parameterPath: [
    "options",
    "prefix"
  ],
  mapper: {
    serializedName: "prefix",
    type: {
      name: "String"
    }
  }
}, preventEncryptionScopeOverride = {
  parameterPath: [
    "options",
    "containerEncryptionScope",
    "preventEncryptionScopeOverride"
  ],
  mapper: {
    serializedName: "x-ms-deny-encryption-scope-override",
    type: {
      name: "Boolean"
    }
  }
}, prevsnapshot = {
  parameterPath: [
    "options",
    "prevsnapshot"
  ],
  mapper: {
    serializedName: "prevsnapshot",
    type: {
      name: "String"
    }
  }
}, prevSnapshotUrl = {
  parameterPath: [
    "options",
    "prevSnapshotUrl"
  ],
  mapper: {
    serializedName: "x-ms-previous-snapshot-url",
    type: {
      name: "String"
    }
  }
}, proposedLeaseId0 = {
  parameterPath: [
    "options",
    "proposedLeaseId"
  ],
  mapper: {
    serializedName: "x-ms-proposed-lease-id",
    type: {
      name: "String"
    }
  }
}, proposedLeaseId1 = {
  parameterPath: "proposedLeaseId",
  mapper: {
    required: !0,
    serializedName: "x-ms-proposed-lease-id",
    type: {
      name: "String"
    }
  }
}, range0 = {
  parameterPath: [
    "options",
    "range"
  ],
  mapper: {
    serializedName: "x-ms-range",
    type: {
      name: "String"
    }
  }
}, range1 = {
  parameterPath: "range",
  mapper: {
    required: !0,
    serializedName: "x-ms-range",
    type: {
      name: "String"
    }
  }
}, rangeGetContentCRC64 = {
  parameterPath: [
    "options",
    "rangeGetContentCRC64"
  ],
  mapper: {
    serializedName: "x-ms-range-get-content-crc64",
    type: {
      name: "Boolean"
    }
  }
}, rangeGetContentMD5 = {
  parameterPath: [
    "options",
    "rangeGetContentMD5"
  ],
  mapper: {
    serializedName: "x-ms-range-get-content-md5",
    type: {
      name: "Boolean"
    }
  }
};
var rehydratePriority = {
  parameterPath: [
    "options",
    "rehydratePriority"
  ],
  mapper: {
    serializedName: "x-ms-rehydrate-priority",
    type: {
      name: "String"
    }
  }
}, renameSource = {
  parameterPath: "renameSource",
  mapper: {
    required: !0,
    serializedName: "x-ms-rename-source",
    type: {
      name: "String"
    }
  }
}, requestId = {
  parameterPath: [
    "options",
    "requestId"
  ],
  mapper: {
    serializedName: "x-ms-client-request-id",
    type: {
      name: "String"
    }
  }
};
var restype0 = {
  parameterPath: "restype",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "restype",
    defaultValue: "service",
    type: {
      name: "String"
    }
  }
}, restype1 = {
  parameterPath: "restype",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "restype",
    defaultValue: "account",
    type: {
      name: "String"
    }
  }
}, restype2 = {
  parameterPath: "restype",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "restype",
    defaultValue: "container",
    type: {
      name: "String"
    }
  }
}, sealBlob = {
  parameterPath: [
    "options",
    "sealBlob"
  ],
  mapper: {
    serializedName: "x-ms-seal-blob",
    type: {
      name: "Boolean"
    }
  }
}, sequenceNumberAction = {
  parameterPath: "sequenceNumberAction",
  mapper: {
    required: !0,
    serializedName: "x-ms-sequence-number-action",
    type: {
      name: "Enum",
      allowedValues: [
        "max",
        "update",
        "increment"
      ]
    }
  }
}, snapshot = {
  parameterPath: [
    "options",
    "snapshot"
  ],
  mapper: {
    serializedName: "snapshot",
    type: {
      name: "String"
    }
  }
}, sourceContentCrc64 = {
  parameterPath: [
    "options",
    "sourceContentCrc64"
  ],
  mapper: {
    serializedName: "x-ms-source-content-crc64",
    type: {
      name: "ByteArray"
    }
  }
}, sourceContentMD5 = {
  parameterPath: [
    "options",
    "sourceContentMD5"
  ],
  mapper: {
    serializedName: "x-ms-source-content-md5",
    type: {
      name: "ByteArray"
    }
  }
}, sourceIfMatch = {
  parameterPath: [
    "options",
    "sourceModifiedAccessConditions",
    "sourceIfMatch"
  ],
  mapper: {
    serializedName: "x-ms-source-if-match",
    type: {
      name: "String"
    }
  }
}, sourceIfModifiedSince = {
  parameterPath: [
    "options",
    "sourceModifiedAccessConditions",
    "sourceIfModifiedSince"
  ],
  mapper: {
    serializedName: "x-ms-source-if-modified-since",
    type: {
      name: "DateTimeRfc1123"
    }
  }
}, sourceIfNoneMatch = {
  parameterPath: [
    "options",
    "sourceModifiedAccessConditions",
    "sourceIfNoneMatch"
  ],
  mapper: {
    serializedName: "x-ms-source-if-none-match",
    type: {
      name: "String"
    }
  }
}, sourceIfTags = {
  parameterPath: [
    "options",
    "sourceModifiedAccessConditions",
    "sourceIfTags"
  ],
  mapper: {
    serializedName: "x-ms-source-if-tags",
    type: {
      name: "String"
    }
  }
}, sourceIfUnmodifiedSince = {
  parameterPath: [
    "options",
    "sourceModifiedAccessConditions",
    "sourceIfUnmodifiedSince"
  ],
  mapper: {
    serializedName: "x-ms-source-if-unmodified-since",
    type: {
      name: "DateTimeRfc1123"
    }
  }
}, sourceLeaseId = {
  parameterPath: [
    "options",
    "sourceLeaseId"
  ],
  mapper: {
    serializedName: "x-ms-source-lease-id",
    type: {
      name: "String"
    }
  }
}, sourceRange0 = {
  parameterPath: "sourceRange",
  mapper: {
    required: !0,
    serializedName: "x-ms-source-range",
    type: {
      name: "String"
    }
  }
}, sourceRange1 = {
  parameterPath: [
    "options",
    "sourceRange"
  ],
  mapper: {
    serializedName: "x-ms-source-range",
    type: {
      name: "String"
    }
  }
}, sourceUrl = {
  parameterPath: "sourceUrl",
  mapper: {
    required: !0,
    serializedName: "x-ms-copy-source",
    type: {
      name: "String"
    }
  }
}, tier0 = {
  parameterPath: [
    "options",
    "tier"
  ],
  mapper: {
    serializedName: "x-ms-access-tier",
    type: {
      name: "String"
    }
  }
}, tier1 = {
  parameterPath: "tier",
  mapper: {
    required: !0,
    serializedName: "x-ms-access-tier",
    type: {
      name: "String"
    }
  }
}, timeoutInSeconds = {
  parameterPath: [
    "options",
    "timeoutInSeconds"
  ],
  mapper: {
    serializedName: "timeout",
    constraints: {
      InclusiveMinimum: 0
    },
    type: {
      name: "Number"
    }
  }
}, transactionalContentCrc64 = {
  parameterPath: [
    "options",
    "transactionalContentCrc64"
  ],
  mapper: {
    serializedName: "x-ms-content-crc64",
    type: {
      name: "ByteArray"
    }
  }
}, transactionalContentMD5 = {
  parameterPath: [
    "options",
    "transactionalContentMD5"
  ],
  mapper: {
    serializedName: "Content-MD5",
    type: {
      name: "ByteArray"
    }
  }
}, upn = {
  parameterPath: [
    "options",
    "upn"
  ],
  mapper: {
    serializedName: "upn",
    type: {
      name: "Boolean"
    }
  }
}, url = {
  parameterPath: "url",
  mapper: {
    required: !0,
    serializedName: "url",
    defaultValue: "",
    type: {
      name: "String"
    }
  },
  skipEncoding: !0
}, version = {
  parameterPath: "version",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "x-ms-version",
    defaultValue: "2020-04-08",
    type: {
      name: "String"
    }
  }
}, versionId = {
  parameterPath: [
    "options",
    "versionId"
  ],
  mapper: {
    serializedName: "versionid",
    type: {
      name: "String"
    }
  }
}, where = {
  parameterPath: [
    "options",
    "where"
  ],
  mapper: {
    serializedName: "where",
    type: {
      name: "String"
    }
  }
}, xMsRequiresSync = {
  parameterPath: "xMsRequiresSync",
  mapper: {
    required: !0,
    isConstant: !0,
    serializedName: "x-ms-requires-sync",
    defaultValue: "true",
    type: {
      name: "String"
    }
  }
};

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/generated/src/operations/service.js
var Service = function() {
  function Service2(client) {
    this.client = client;
  }
  return __name(Service2, "Service"), Service2.prototype.setProperties = function(blobServiceProperties, options, callback) {
    return this.client.sendOperationRequest({
      blobServiceProperties,
      options
    }, setPropertiesOperationSpec, callback);
  }, Service2.prototype.getProperties = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, getPropertiesOperationSpec, callback);
  }, Service2.prototype.getStatistics = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, getStatisticsOperationSpec, callback);
  }, Service2.prototype.listContainersSegment = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, listContainersSegmentOperationSpec, callback);
  }, Service2.prototype.getUserDelegationKey = function(keyInfo, options, callback) {
    return this.client.sendOperationRequest({
      keyInfo,
      options
    }, getUserDelegationKeyOperationSpec, callback);
  }, Service2.prototype.getAccountInfo = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, getAccountInfoOperationSpec, callback);
  }, Service2.prototype.submitBatch = function(body, contentLength2, multipartContentType2, options, callback) {
    return this.client.sendOperationRequest({
      body,
      contentLength: contentLength2,
      multipartContentType: multipartContentType2,
      options
    }, submitBatchOperationSpec, callback);
  }, Service2.prototype.filterBlobs = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, filterBlobsOperationSpec, callback);
  }, Service2;
}();
var serializer = new Serializer(serviceMappers_exports, !0), setPropertiesOperationSpec = {
  httpMethod: "PUT",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    restype0,
    comp0
  ],
  headerParameters: [
    version,
    requestId
  ],
  requestBody: {
    parameterPath: "blobServiceProperties",
    mapper: __assign(__assign({}, BlobServiceProperties), {required: !0})
  },
  contentType: "application/xml; charset=utf-8",
  responses: {
    202: {
      headersMapper: ServiceSetPropertiesHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ServiceSetPropertiesHeaders
    }
  },
  isXML: !0,
  serializer
}, getPropertiesOperationSpec = {
  httpMethod: "GET",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    restype0,
    comp0
  ],
  headerParameters: [
    version,
    requestId
  ],
  responses: {
    200: {
      bodyMapper: BlobServiceProperties,
      headersMapper: ServiceGetPropertiesHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ServiceGetPropertiesHeaders
    }
  },
  isXML: !0,
  serializer
}, getStatisticsOperationSpec = {
  httpMethod: "GET",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    restype0,
    comp1
  ],
  headerParameters: [
    version,
    requestId
  ],
  responses: {
    200: {
      bodyMapper: BlobServiceStatistics,
      headersMapper: ServiceGetStatisticsHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ServiceGetStatisticsHeaders
    }
  },
  isXML: !0,
  serializer
}, listContainersSegmentOperationSpec = {
  httpMethod: "GET",
  urlParameters: [
    url
  ],
  queryParameters: [
    prefix,
    marker0,
    maxPageSize,
    include0,
    timeoutInSeconds,
    comp2
  ],
  headerParameters: [
    version,
    requestId
  ],
  responses: {
    200: {
      bodyMapper: ListContainersSegmentResponse,
      headersMapper: ServiceListContainersSegmentHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ServiceListContainersSegmentHeaders
    }
  },
  isXML: !0,
  serializer
}, getUserDelegationKeyOperationSpec = {
  httpMethod: "POST",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    restype0,
    comp3
  ],
  headerParameters: [
    version,
    requestId
  ],
  requestBody: {
    parameterPath: "keyInfo",
    mapper: __assign(__assign({}, KeyInfo), {required: !0})
  },
  contentType: "application/xml; charset=utf-8",
  responses: {
    200: {
      bodyMapper: UserDelegationKey,
      headersMapper: ServiceGetUserDelegationKeyHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ServiceGetUserDelegationKeyHeaders
    }
  },
  isXML: !0,
  serializer
}, getAccountInfoOperationSpec = {
  httpMethod: "GET",
  urlParameters: [
    url
  ],
  queryParameters: [
    restype1,
    comp0
  ],
  headerParameters: [
    version
  ],
  responses: {
    200: {
      headersMapper: ServiceGetAccountInfoHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ServiceGetAccountInfoHeaders
    }
  },
  isXML: !0,
  serializer
}, submitBatchOperationSpec = {
  httpMethod: "POST",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp4
  ],
  headerParameters: [
    contentLength,
    multipartContentType,
    version,
    requestId
  ],
  requestBody: {
    parameterPath: "body",
    mapper: {
      required: !0,
      serializedName: "body",
      type: {
        name: "Stream"
      }
    }
  },
  contentType: "application/xml; charset=utf-8",
  responses: {
    202: {
      bodyMapper: {
        serializedName: "parsedResponse",
        type: {
          name: "Stream"
        }
      },
      headersMapper: ServiceSubmitBatchHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ServiceSubmitBatchHeaders
    }
  },
  isXML: !0,
  serializer
}, filterBlobsOperationSpec = {
  httpMethod: "GET",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    where,
    marker0,
    maxPageSize,
    comp5
  ],
  headerParameters: [
    version,
    requestId
  ],
  responses: {
    200: {
      bodyMapper: FilterBlobSegment,
      headersMapper: ServiceFilterBlobsHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ServiceFilterBlobsHeaders
    }
  },
  isXML: !0,
  serializer
};

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/generated/src/models/containerMappers.js
var containerMappers_exports = {};
__export(containerMappers_exports, {
  AccessPolicy: () => AccessPolicy,
  BlobFlatListSegment: () => BlobFlatListSegment,
  BlobHierarchyListSegment: () => BlobHierarchyListSegment,
  BlobItemInternal: () => BlobItemInternal,
  BlobPrefix: () => BlobPrefix,
  BlobPropertiesInternal: () => BlobPropertiesInternal,
  BlobTag: () => BlobTag,
  BlobTags: () => BlobTags,
  ContainerAcquireLeaseHeaders: () => ContainerAcquireLeaseHeaders,
  ContainerBreakLeaseHeaders: () => ContainerBreakLeaseHeaders,
  ContainerChangeLeaseHeaders: () => ContainerChangeLeaseHeaders,
  ContainerCreateHeaders: () => ContainerCreateHeaders,
  ContainerDeleteHeaders: () => ContainerDeleteHeaders,
  ContainerGetAccessPolicyHeaders: () => ContainerGetAccessPolicyHeaders,
  ContainerGetAccountInfoHeaders: () => ContainerGetAccountInfoHeaders,
  ContainerGetPropertiesHeaders: () => ContainerGetPropertiesHeaders,
  ContainerListBlobFlatSegmentHeaders: () => ContainerListBlobFlatSegmentHeaders,
  ContainerListBlobHierarchySegmentHeaders: () => ContainerListBlobHierarchySegmentHeaders,
  ContainerReleaseLeaseHeaders: () => ContainerReleaseLeaseHeaders,
  ContainerRenewLeaseHeaders: () => ContainerRenewLeaseHeaders,
  ContainerRestoreHeaders: () => ContainerRestoreHeaders,
  ContainerSetAccessPolicyHeaders: () => ContainerSetAccessPolicyHeaders,
  ContainerSetMetadataHeaders: () => ContainerSetMetadataHeaders,
  ListBlobsFlatSegmentResponse: () => ListBlobsFlatSegmentResponse,
  ListBlobsHierarchySegmentResponse: () => ListBlobsHierarchySegmentResponse,
  SignedIdentifier: () => SignedIdentifier,
  StorageError: () => StorageError
});

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/generated/src/operations/container.js
var Container = function() {
  function Container2(client) {
    this.client = client;
  }
  return __name(Container2, "Container"), Container2.prototype.create = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, createOperationSpec, callback);
  }, Container2.prototype.getProperties = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, getPropertiesOperationSpec2, callback);
  }, Container2.prototype.deleteMethod = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, deleteMethodOperationSpec, callback);
  }, Container2.prototype.setMetadata = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, setMetadataOperationSpec, callback);
  }, Container2.prototype.getAccessPolicy = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, getAccessPolicyOperationSpec, callback);
  }, Container2.prototype.setAccessPolicy = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, setAccessPolicyOperationSpec, callback);
  }, Container2.prototype.restore = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, restoreOperationSpec, callback);
  }, Container2.prototype.acquireLease = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, acquireLeaseOperationSpec, callback);
  }, Container2.prototype.releaseLease = function(leaseId, options, callback) {
    return this.client.sendOperationRequest({
      leaseId,
      options
    }, releaseLeaseOperationSpec, callback);
  }, Container2.prototype.renewLease = function(leaseId, options, callback) {
    return this.client.sendOperationRequest({
      leaseId,
      options
    }, renewLeaseOperationSpec, callback);
  }, Container2.prototype.breakLease = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, breakLeaseOperationSpec, callback);
  }, Container2.prototype.changeLease = function(leaseId, proposedLeaseId, options, callback) {
    return this.client.sendOperationRequest({
      leaseId,
      proposedLeaseId,
      options
    }, changeLeaseOperationSpec, callback);
  }, Container2.prototype.listBlobFlatSegment = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, listBlobFlatSegmentOperationSpec, callback);
  }, Container2.prototype.listBlobHierarchySegment = function(delimiter2, options, callback) {
    return this.client.sendOperationRequest({
      delimiter: delimiter2,
      options
    }, listBlobHierarchySegmentOperationSpec, callback);
  }, Container2.prototype.getAccountInfo = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, getAccountInfoOperationSpec2, callback);
  }, Container2;
}();
var serializer2 = new Serializer(containerMappers_exports, !0), createOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    restype2
  ],
  headerParameters: [
    metadata,
    access,
    version,
    requestId,
    defaultEncryptionScope,
    preventEncryptionScopeOverride
  ],
  responses: {
    201: {
      headersMapper: ContainerCreateHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ContainerCreateHeaders
    }
  },
  isXML: !0,
  serializer: serializer2
}, getPropertiesOperationSpec2 = {
  httpMethod: "GET",
  path: "{containerName}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    restype2
  ],
  headerParameters: [
    version,
    requestId,
    leaseId0
  ],
  responses: {
    200: {
      headersMapper: ContainerGetPropertiesHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ContainerGetPropertiesHeaders
    }
  },
  isXML: !0,
  serializer: serializer2
}, deleteMethodOperationSpec = {
  httpMethod: "DELETE",
  path: "{containerName}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    restype2
  ],
  headerParameters: [
    version,
    requestId,
    leaseId0,
    ifModifiedSince,
    ifUnmodifiedSince
  ],
  responses: {
    202: {
      headersMapper: ContainerDeleteHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ContainerDeleteHeaders
    }
  },
  isXML: !0,
  serializer: serializer2
}, setMetadataOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    restype2,
    comp6
  ],
  headerParameters: [
    metadata,
    version,
    requestId,
    leaseId0,
    ifModifiedSince
  ],
  responses: {
    200: {
      headersMapper: ContainerSetMetadataHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ContainerSetMetadataHeaders
    }
  },
  isXML: !0,
  serializer: serializer2
}, getAccessPolicyOperationSpec = {
  httpMethod: "GET",
  path: "{containerName}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    restype2,
    comp7
  ],
  headerParameters: [
    version,
    requestId,
    leaseId0
  ],
  responses: {
    200: {
      bodyMapper: {
        xmlElementName: "SignedIdentifier",
        serializedName: "parsedResponse",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "SignedIdentifier"
            }
          }
        }
      },
      headersMapper: ContainerGetAccessPolicyHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ContainerGetAccessPolicyHeaders
    }
  },
  isXML: !0,
  serializer: serializer2
}, setAccessPolicyOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    restype2,
    comp7
  ],
  headerParameters: [
    access,
    version,
    requestId,
    leaseId0,
    ifModifiedSince,
    ifUnmodifiedSince
  ],
  requestBody: {
    parameterPath: [
      "options",
      "containerAcl"
    ],
    mapper: {
      xmlName: "SignedIdentifiers",
      xmlElementName: "SignedIdentifier",
      serializedName: "containerAcl",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Composite",
            className: "SignedIdentifier"
          }
        }
      }
    }
  },
  contentType: "application/xml; charset=utf-8",
  responses: {
    200: {
      headersMapper: ContainerSetAccessPolicyHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ContainerSetAccessPolicyHeaders
    }
  },
  isXML: !0,
  serializer: serializer2
}, restoreOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    restype2,
    comp8
  ],
  headerParameters: [
    version,
    requestId,
    deletedContainerName,
    deletedContainerVersion
  ],
  responses: {
    201: {
      headersMapper: ContainerRestoreHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ContainerRestoreHeaders
    }
  },
  isXML: !0,
  serializer: serializer2
}, acquireLeaseOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp9,
    restype2
  ],
  headerParameters: [
    duration,
    proposedLeaseId0,
    version,
    requestId,
    action0,
    ifModifiedSince,
    ifUnmodifiedSince
  ],
  responses: {
    201: {
      headersMapper: ContainerAcquireLeaseHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ContainerAcquireLeaseHeaders
    }
  },
  isXML: !0,
  serializer: serializer2
}, releaseLeaseOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp9,
    restype2
  ],
  headerParameters: [
    leaseId1,
    version,
    requestId,
    action1,
    ifModifiedSince,
    ifUnmodifiedSince
  ],
  responses: {
    200: {
      headersMapper: ContainerReleaseLeaseHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ContainerReleaseLeaseHeaders
    }
  },
  isXML: !0,
  serializer: serializer2
}, renewLeaseOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp9,
    restype2
  ],
  headerParameters: [
    leaseId1,
    version,
    requestId,
    action2,
    ifModifiedSince,
    ifUnmodifiedSince
  ],
  responses: {
    200: {
      headersMapper: ContainerRenewLeaseHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ContainerRenewLeaseHeaders
    }
  },
  isXML: !0,
  serializer: serializer2
}, breakLeaseOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp9,
    restype2
  ],
  headerParameters: [
    breakPeriod,
    version,
    requestId,
    action3,
    ifModifiedSince,
    ifUnmodifiedSince
  ],
  responses: {
    202: {
      headersMapper: ContainerBreakLeaseHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ContainerBreakLeaseHeaders
    }
  },
  isXML: !0,
  serializer: serializer2
}, changeLeaseOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp9,
    restype2
  ],
  headerParameters: [
    leaseId1,
    proposedLeaseId1,
    version,
    requestId,
    action4,
    ifModifiedSince,
    ifUnmodifiedSince
  ],
  responses: {
    200: {
      headersMapper: ContainerChangeLeaseHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ContainerChangeLeaseHeaders
    }
  },
  isXML: !0,
  serializer: serializer2
}, listBlobFlatSegmentOperationSpec = {
  httpMethod: "GET",
  path: "{containerName}",
  urlParameters: [
    url
  ],
  queryParameters: [
    prefix,
    marker0,
    maxPageSize,
    include1,
    timeoutInSeconds,
    restype2,
    comp2
  ],
  headerParameters: [
    version,
    requestId
  ],
  responses: {
    200: {
      bodyMapper: ListBlobsFlatSegmentResponse,
      headersMapper: ContainerListBlobFlatSegmentHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ContainerListBlobFlatSegmentHeaders
    }
  },
  isXML: !0,
  serializer: serializer2
}, listBlobHierarchySegmentOperationSpec = {
  httpMethod: "GET",
  path: "{containerName}",
  urlParameters: [
    url
  ],
  queryParameters: [
    prefix,
    delimiter,
    marker0,
    maxPageSize,
    include1,
    timeoutInSeconds,
    restype2,
    comp2
  ],
  headerParameters: [
    version,
    requestId
  ],
  responses: {
    200: {
      bodyMapper: ListBlobsHierarchySegmentResponse,
      headersMapper: ContainerListBlobHierarchySegmentHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ContainerListBlobHierarchySegmentHeaders
    }
  },
  isXML: !0,
  serializer: serializer2
}, getAccountInfoOperationSpec2 = {
  httpMethod: "GET",
  path: "{containerName}",
  urlParameters: [
    url
  ],
  queryParameters: [
    restype1,
    comp0
  ],
  headerParameters: [
    version
  ],
  responses: {
    200: {
      headersMapper: ContainerGetAccountInfoHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: ContainerGetAccountInfoHeaders
    }
  },
  isXML: !0,
  serializer: serializer2
};

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/generated/src/models/blobMappers.js
var blobMappers_exports = {};
__export(blobMappers_exports, {
  ArrowConfiguration: () => ArrowConfiguration,
  ArrowField: () => ArrowField,
  BlobAbortCopyFromURLHeaders: () => BlobAbortCopyFromURLHeaders,
  BlobAcquireLeaseHeaders: () => BlobAcquireLeaseHeaders,
  BlobBreakLeaseHeaders: () => BlobBreakLeaseHeaders,
  BlobChangeLeaseHeaders: () => BlobChangeLeaseHeaders,
  BlobCopyFromURLHeaders: () => BlobCopyFromURLHeaders,
  BlobCreateSnapshotHeaders: () => BlobCreateSnapshotHeaders,
  BlobDeleteHeaders: () => BlobDeleteHeaders,
  BlobDownloadHeaders: () => BlobDownloadHeaders,
  BlobGetAccessControlHeaders: () => BlobGetAccessControlHeaders,
  BlobGetAccountInfoHeaders: () => BlobGetAccountInfoHeaders,
  BlobGetPropertiesHeaders: () => BlobGetPropertiesHeaders,
  BlobGetTagsHeaders: () => BlobGetTagsHeaders,
  BlobQueryHeaders: () => BlobQueryHeaders,
  BlobReleaseLeaseHeaders: () => BlobReleaseLeaseHeaders,
  BlobRenameHeaders: () => BlobRenameHeaders,
  BlobRenewLeaseHeaders: () => BlobRenewLeaseHeaders,
  BlobSetAccessControlHeaders: () => BlobSetAccessControlHeaders,
  BlobSetExpiryHeaders: () => BlobSetExpiryHeaders,
  BlobSetHTTPHeadersHeaders: () => BlobSetHTTPHeadersHeaders,
  BlobSetMetadataHeaders: () => BlobSetMetadataHeaders,
  BlobSetTagsHeaders: () => BlobSetTagsHeaders,
  BlobSetTierHeaders: () => BlobSetTierHeaders,
  BlobStartCopyFromURLHeaders: () => BlobStartCopyFromURLHeaders,
  BlobTag: () => BlobTag,
  BlobTags: () => BlobTags,
  BlobUndeleteHeaders: () => BlobUndeleteHeaders,
  DataLakeStorageError: () => DataLakeStorageError,
  DataLakeStorageErrorError: () => DataLakeStorageErrorError,
  DelimitedTextConfiguration: () => DelimitedTextConfiguration,
  JsonTextConfiguration: () => JsonTextConfiguration,
  QueryFormat: () => QueryFormat,
  QueryRequest: () => QueryRequest,
  QuerySerialization: () => QuerySerialization,
  StorageError: () => StorageError
});

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/generated/src/operations/blob.js
var Blob3 = function() {
  function Blob4(client) {
    this.client = client;
  }
  return __name(Blob4, "Blob"), Blob4.prototype.download = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, downloadOperationSpec, callback);
  }, Blob4.prototype.getProperties = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, getPropertiesOperationSpec3, callback);
  }, Blob4.prototype.deleteMethod = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, deleteMethodOperationSpec2, callback);
  }, Blob4.prototype.setAccessControl = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, setAccessControlOperationSpec, callback);
  }, Blob4.prototype.getAccessControl = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, getAccessControlOperationSpec, callback);
  }, Blob4.prototype.rename = function(renameSource2, options, callback) {
    return this.client.sendOperationRequest({
      renameSource: renameSource2,
      options
    }, renameOperationSpec, callback);
  }, Blob4.prototype.undelete = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, undeleteOperationSpec, callback);
  }, Blob4.prototype.setExpiry = function(expiryOptions2, options, callback) {
    return this.client.sendOperationRequest({
      expiryOptions: expiryOptions2,
      options
    }, setExpiryOperationSpec, callback);
  }, Blob4.prototype.setHTTPHeaders = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, setHTTPHeadersOperationSpec, callback);
  }, Blob4.prototype.setMetadata = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, setMetadataOperationSpec2, callback);
  }, Blob4.prototype.acquireLease = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, acquireLeaseOperationSpec2, callback);
  }, Blob4.prototype.releaseLease = function(leaseId, options, callback) {
    return this.client.sendOperationRequest({
      leaseId,
      options
    }, releaseLeaseOperationSpec2, callback);
  }, Blob4.prototype.renewLease = function(leaseId, options, callback) {
    return this.client.sendOperationRequest({
      leaseId,
      options
    }, renewLeaseOperationSpec2, callback);
  }, Blob4.prototype.changeLease = function(leaseId, proposedLeaseId, options, callback) {
    return this.client.sendOperationRequest({
      leaseId,
      proposedLeaseId,
      options
    }, changeLeaseOperationSpec2, callback);
  }, Blob4.prototype.breakLease = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, breakLeaseOperationSpec2, callback);
  }, Blob4.prototype.createSnapshot = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, createSnapshotOperationSpec, callback);
  }, Blob4.prototype.startCopyFromURL = function(copySource2, options, callback) {
    return this.client.sendOperationRequest({
      copySource: copySource2,
      options
    }, startCopyFromURLOperationSpec, callback);
  }, Blob4.prototype.copyFromURL = function(copySource2, options, callback) {
    return this.client.sendOperationRequest({
      copySource: copySource2,
      options
    }, copyFromURLOperationSpec, callback);
  }, Blob4.prototype.abortCopyFromURL = function(copyId2, options, callback) {
    return this.client.sendOperationRequest({
      copyId: copyId2,
      options
    }, abortCopyFromURLOperationSpec, callback);
  }, Blob4.prototype.setTier = function(tier, options, callback) {
    return this.client.sendOperationRequest({
      tier,
      options
    }, setTierOperationSpec, callback);
  }, Blob4.prototype.getAccountInfo = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, getAccountInfoOperationSpec3, callback);
  }, Blob4.prototype.query = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, queryOperationSpec, callback);
  }, Blob4.prototype.getTags = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, getTagsOperationSpec, callback);
  }, Blob4.prototype.setTags = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, setTagsOperationSpec, callback);
  }, Blob4;
}();
var serializer3 = new Serializer(blobMappers_exports, !0), downloadOperationSpec = {
  httpMethod: "GET",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    snapshot,
    versionId,
    timeoutInSeconds
  ],
  headerParameters: [
    range0,
    rangeGetContentMD5,
    rangeGetContentCRC64,
    version,
    requestId,
    leaseId0,
    encryptionKey,
    encryptionKeySha256,
    encryptionAlgorithm,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  responses: {
    200: {
      bodyMapper: {
        serializedName: "parsedResponse",
        type: {
          name: "Stream"
        }
      },
      headersMapper: BlobDownloadHeaders
    },
    206: {
      bodyMapper: {
        serializedName: "parsedResponse",
        type: {
          name: "Stream"
        }
      },
      headersMapper: BlobDownloadHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlobDownloadHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, getPropertiesOperationSpec3 = {
  httpMethod: "HEAD",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    snapshot,
    versionId,
    timeoutInSeconds
  ],
  headerParameters: [
    version,
    requestId,
    leaseId0,
    encryptionKey,
    encryptionKeySha256,
    encryptionAlgorithm,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  responses: {
    200: {
      headersMapper: BlobGetPropertiesHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlobGetPropertiesHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, deleteMethodOperationSpec2 = {
  httpMethod: "DELETE",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    snapshot,
    versionId,
    timeoutInSeconds,
    blobDeleteType
  ],
  headerParameters: [
    deleteSnapshots,
    version,
    requestId,
    leaseId0,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  responses: {
    202: {
      headersMapper: BlobDeleteHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlobDeleteHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, setAccessControlOperationSpec = {
  httpMethod: "PATCH",
  path: "{filesystem}/{path}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    action5
  ],
  headerParameters: [
    owner,
    group,
    posixPermissions,
    posixAcl,
    requestId,
    version,
    leaseId0,
    ifMatch,
    ifNoneMatch,
    ifModifiedSince,
    ifUnmodifiedSince
  ],
  responses: {
    200: {
      headersMapper: BlobSetAccessControlHeaders
    },
    default: {
      bodyMapper: DataLakeStorageError,
      headersMapper: BlobSetAccessControlHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, getAccessControlOperationSpec = {
  httpMethod: "HEAD",
  path: "{filesystem}/{path}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    upn,
    action6
  ],
  headerParameters: [
    requestId,
    version,
    leaseId0,
    ifMatch,
    ifNoneMatch,
    ifModifiedSince,
    ifUnmodifiedSince
  ],
  responses: {
    200: {
      headersMapper: BlobGetAccessControlHeaders
    },
    default: {
      bodyMapper: DataLakeStorageError,
      headersMapper: BlobGetAccessControlHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, renameOperationSpec = {
  httpMethod: "PUT",
  path: "{filesystem}/{path}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    pathRenameMode
  ],
  headerParameters: [
    renameSource,
    directoryProperties,
    posixPermissions,
    posixUmask,
    sourceLeaseId,
    version,
    requestId,
    cacheControl,
    contentType,
    contentEncoding,
    contentLanguage,
    contentDisposition,
    leaseId0,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    sourceIfModifiedSince,
    sourceIfUnmodifiedSince,
    sourceIfMatch,
    sourceIfNoneMatch
  ],
  responses: {
    201: {
      headersMapper: BlobRenameHeaders
    },
    default: {
      bodyMapper: DataLakeStorageError,
      headersMapper: BlobRenameHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, undeleteOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp8
  ],
  headerParameters: [
    version,
    requestId
  ],
  responses: {
    200: {
      headersMapper: BlobUndeleteHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlobUndeleteHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, setExpiryOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp10
  ],
  headerParameters: [
    version,
    requestId,
    expiryOptions,
    expiresOn
  ],
  responses: {
    200: {
      headersMapper: BlobSetExpiryHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlobSetExpiryHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, setHTTPHeadersOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp0
  ],
  headerParameters: [
    version,
    requestId,
    blobCacheControl,
    blobContentType,
    blobContentMD5,
    blobContentEncoding,
    blobContentLanguage,
    blobContentDisposition,
    leaseId0,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  responses: {
    200: {
      headersMapper: BlobSetHTTPHeadersHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlobSetHTTPHeadersHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, setMetadataOperationSpec2 = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp6
  ],
  headerParameters: [
    metadata,
    encryptionScope,
    version,
    requestId,
    leaseId0,
    encryptionKey,
    encryptionKeySha256,
    encryptionAlgorithm,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  responses: {
    200: {
      headersMapper: BlobSetMetadataHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlobSetMetadataHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, acquireLeaseOperationSpec2 = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp9
  ],
  headerParameters: [
    duration,
    proposedLeaseId0,
    version,
    requestId,
    action0,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  responses: {
    201: {
      headersMapper: BlobAcquireLeaseHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlobAcquireLeaseHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, releaseLeaseOperationSpec2 = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp9
  ],
  headerParameters: [
    leaseId1,
    version,
    requestId,
    action1,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  responses: {
    200: {
      headersMapper: BlobReleaseLeaseHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlobReleaseLeaseHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, renewLeaseOperationSpec2 = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp9
  ],
  headerParameters: [
    leaseId1,
    version,
    requestId,
    action2,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  responses: {
    200: {
      headersMapper: BlobRenewLeaseHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlobRenewLeaseHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, changeLeaseOperationSpec2 = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp9
  ],
  headerParameters: [
    leaseId1,
    proposedLeaseId1,
    version,
    requestId,
    action4,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  responses: {
    200: {
      headersMapper: BlobChangeLeaseHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlobChangeLeaseHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, breakLeaseOperationSpec2 = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp9
  ],
  headerParameters: [
    breakPeriod,
    version,
    requestId,
    action3,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  responses: {
    202: {
      headersMapper: BlobBreakLeaseHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlobBreakLeaseHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, createSnapshotOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp11
  ],
  headerParameters: [
    metadata,
    encryptionScope,
    version,
    requestId,
    encryptionKey,
    encryptionKeySha256,
    encryptionAlgorithm,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags,
    leaseId0
  ],
  responses: {
    201: {
      headersMapper: BlobCreateSnapshotHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlobCreateSnapshotHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, startCopyFromURLOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds
  ],
  headerParameters: [
    metadata,
    tier0,
    rehydratePriority,
    copySource,
    version,
    requestId,
    blobTagsString,
    sealBlob,
    sourceIfModifiedSince,
    sourceIfUnmodifiedSince,
    sourceIfMatch,
    sourceIfNoneMatch,
    sourceIfTags,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags,
    leaseId0
  ],
  responses: {
    202: {
      headersMapper: BlobStartCopyFromURLHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlobStartCopyFromURLHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, copyFromURLOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds
  ],
  headerParameters: [
    metadata,
    tier0,
    copySource,
    version,
    requestId,
    sourceContentMD5,
    blobTagsString,
    xMsRequiresSync,
    sourceIfModifiedSince,
    sourceIfUnmodifiedSince,
    sourceIfMatch,
    sourceIfNoneMatch,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags,
    leaseId0
  ],
  responses: {
    202: {
      headersMapper: BlobCopyFromURLHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlobCopyFromURLHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, abortCopyFromURLOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    copyId,
    timeoutInSeconds,
    comp12
  ],
  headerParameters: [
    version,
    requestId,
    copyActionAbortConstant,
    leaseId0
  ],
  responses: {
    204: {
      headersMapper: BlobAbortCopyFromURLHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlobAbortCopyFromURLHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, setTierOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    snapshot,
    versionId,
    timeoutInSeconds,
    comp13
  ],
  headerParameters: [
    tier1,
    rehydratePriority,
    version,
    requestId,
    leaseId0,
    ifTags
  ],
  responses: {
    200: {
      headersMapper: BlobSetTierHeaders
    },
    202: {
      headersMapper: BlobSetTierHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlobSetTierHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, getAccountInfoOperationSpec3 = {
  httpMethod: "GET",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    restype1,
    comp0
  ],
  headerParameters: [
    version
  ],
  responses: {
    200: {
      headersMapper: BlobGetAccountInfoHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlobGetAccountInfoHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, queryOperationSpec = {
  httpMethod: "POST",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    snapshot,
    timeoutInSeconds,
    comp14
  ],
  headerParameters: [
    version,
    requestId,
    leaseId0,
    encryptionKey,
    encryptionKeySha256,
    encryptionAlgorithm,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  requestBody: {
    parameterPath: [
      "options",
      "queryRequest"
    ],
    mapper: QueryRequest
  },
  contentType: "application/xml; charset=utf-8",
  responses: {
    200: {
      bodyMapper: {
        serializedName: "parsedResponse",
        type: {
          name: "Stream"
        }
      },
      headersMapper: BlobQueryHeaders
    },
    206: {
      bodyMapper: {
        serializedName: "parsedResponse",
        type: {
          name: "Stream"
        }
      },
      headersMapper: BlobQueryHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlobQueryHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, getTagsOperationSpec = {
  httpMethod: "GET",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    snapshot,
    versionId,
    comp15
  ],
  headerParameters: [
    version,
    requestId,
    ifTags,
    leaseId0
  ],
  responses: {
    200: {
      bodyMapper: BlobTags,
      headersMapper: BlobGetTagsHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlobGetTagsHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
}, setTagsOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    versionId,
    comp15
  ],
  headerParameters: [
    version,
    transactionalContentMD5,
    transactionalContentCrc64,
    requestId,
    ifTags,
    leaseId0
  ],
  requestBody: {
    parameterPath: [
      "options",
      "tags"
    ],
    mapper: BlobTags
  },
  contentType: "application/xml; charset=utf-8",
  responses: {
    204: {
      headersMapper: BlobSetTagsHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlobSetTagsHeaders
    }
  },
  isXML: !0,
  serializer: serializer3
};

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/generated/src/models/pageBlobMappers.js
var pageBlobMappers_exports = {};
__export(pageBlobMappers_exports, {
  ClearRange: () => ClearRange,
  PageBlobClearPagesHeaders: () => PageBlobClearPagesHeaders,
  PageBlobCopyIncrementalHeaders: () => PageBlobCopyIncrementalHeaders,
  PageBlobCreateHeaders: () => PageBlobCreateHeaders,
  PageBlobGetPageRangesDiffHeaders: () => PageBlobGetPageRangesDiffHeaders,
  PageBlobGetPageRangesHeaders: () => PageBlobGetPageRangesHeaders,
  PageBlobResizeHeaders: () => PageBlobResizeHeaders,
  PageBlobUpdateSequenceNumberHeaders: () => PageBlobUpdateSequenceNumberHeaders,
  PageBlobUploadPagesFromURLHeaders: () => PageBlobUploadPagesFromURLHeaders,
  PageBlobUploadPagesHeaders: () => PageBlobUploadPagesHeaders,
  PageList: () => PageList,
  PageRange: () => PageRange,
  StorageError: () => StorageError
});

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/generated/src/operations/pageBlob.js
var PageBlob = function() {
  function PageBlob2(client) {
    this.client = client;
  }
  return __name(PageBlob2, "PageBlob"), PageBlob2.prototype.create = function(contentLength2, blobContentLength2, options, callback) {
    return this.client.sendOperationRequest({
      contentLength: contentLength2,
      blobContentLength: blobContentLength2,
      options
    }, createOperationSpec2, callback);
  }, PageBlob2.prototype.uploadPages = function(body, contentLength2, options, callback) {
    return this.client.sendOperationRequest({
      body,
      contentLength: contentLength2,
      options
    }, uploadPagesOperationSpec, callback);
  }, PageBlob2.prototype.clearPages = function(contentLength2, options, callback) {
    return this.client.sendOperationRequest({
      contentLength: contentLength2,
      options
    }, clearPagesOperationSpec, callback);
  }, PageBlob2.prototype.uploadPagesFromURL = function(sourceUrl2, sourceRange, contentLength2, range, options, callback) {
    return this.client.sendOperationRequest({
      sourceUrl: sourceUrl2,
      sourceRange,
      contentLength: contentLength2,
      range,
      options
    }, uploadPagesFromURLOperationSpec, callback);
  }, PageBlob2.prototype.getPageRanges = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, getPageRangesOperationSpec, callback);
  }, PageBlob2.prototype.getPageRangesDiff = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, getPageRangesDiffOperationSpec, callback);
  }, PageBlob2.prototype.resize = function(blobContentLength2, options, callback) {
    return this.client.sendOperationRequest({
      blobContentLength: blobContentLength2,
      options
    }, resizeOperationSpec, callback);
  }, PageBlob2.prototype.updateSequenceNumber = function(sequenceNumberAction2, options, callback) {
    return this.client.sendOperationRequest({
      sequenceNumberAction: sequenceNumberAction2,
      options
    }, updateSequenceNumberOperationSpec, callback);
  }, PageBlob2.prototype.copyIncremental = function(copySource2, options, callback) {
    return this.client.sendOperationRequest({
      copySource: copySource2,
      options
    }, copyIncrementalOperationSpec, callback);
  }, PageBlob2;
}();
var serializer4 = new Serializer(pageBlobMappers_exports, !0), createOperationSpec2 = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds
  ],
  headerParameters: [
    contentLength,
    tier0,
    metadata,
    encryptionScope,
    blobContentLength,
    blobSequenceNumber,
    version,
    requestId,
    blobTagsString,
    blobType0,
    blobContentType,
    blobContentEncoding,
    blobContentLanguage,
    blobContentMD5,
    blobCacheControl,
    blobContentDisposition,
    leaseId0,
    encryptionKey,
    encryptionKeySha256,
    encryptionAlgorithm,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  responses: {
    201: {
      headersMapper: PageBlobCreateHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: PageBlobCreateHeaders
    }
  },
  isXML: !0,
  serializer: serializer4
}, uploadPagesOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp16
  ],
  headerParameters: [
    contentLength,
    transactionalContentMD5,
    transactionalContentCrc64,
    range0,
    encryptionScope,
    version,
    requestId,
    pageWrite0,
    leaseId0,
    encryptionKey,
    encryptionKeySha256,
    encryptionAlgorithm,
    ifSequenceNumberLessThanOrEqualTo,
    ifSequenceNumberLessThan,
    ifSequenceNumberEqualTo,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  requestBody: {
    parameterPath: "body",
    mapper: {
      required: !0,
      serializedName: "body",
      type: {
        name: "Stream"
      }
    }
  },
  contentType: "application/octet-stream",
  responses: {
    201: {
      headersMapper: PageBlobUploadPagesHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: PageBlobUploadPagesHeaders
    }
  },
  isXML: !0,
  serializer: serializer4
}, clearPagesOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp16
  ],
  headerParameters: [
    contentLength,
    range0,
    encryptionScope,
    version,
    requestId,
    pageWrite1,
    leaseId0,
    encryptionKey,
    encryptionKeySha256,
    encryptionAlgorithm,
    ifSequenceNumberLessThanOrEqualTo,
    ifSequenceNumberLessThan,
    ifSequenceNumberEqualTo,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  responses: {
    201: {
      headersMapper: PageBlobClearPagesHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: PageBlobClearPagesHeaders
    }
  },
  isXML: !0,
  serializer: serializer4
}, uploadPagesFromURLOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp16
  ],
  headerParameters: [
    sourceUrl,
    sourceRange0,
    sourceContentMD5,
    sourceContentCrc64,
    contentLength,
    range1,
    encryptionScope,
    version,
    requestId,
    pageWrite0,
    encryptionKey,
    encryptionKeySha256,
    encryptionAlgorithm,
    leaseId0,
    ifSequenceNumberLessThanOrEqualTo,
    ifSequenceNumberLessThan,
    ifSequenceNumberEqualTo,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags,
    sourceIfModifiedSince,
    sourceIfUnmodifiedSince,
    sourceIfMatch,
    sourceIfNoneMatch
  ],
  responses: {
    201: {
      headersMapper: PageBlobUploadPagesFromURLHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: PageBlobUploadPagesFromURLHeaders
    }
  },
  isXML: !0,
  serializer: serializer4
}, getPageRangesOperationSpec = {
  httpMethod: "GET",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    snapshot,
    timeoutInSeconds,
    comp17
  ],
  headerParameters: [
    range0,
    version,
    requestId,
    leaseId0,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  responses: {
    200: {
      bodyMapper: PageList,
      headersMapper: PageBlobGetPageRangesHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: PageBlobGetPageRangesHeaders
    }
  },
  isXML: !0,
  serializer: serializer4
}, getPageRangesDiffOperationSpec = {
  httpMethod: "GET",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    snapshot,
    timeoutInSeconds,
    prevsnapshot,
    comp17
  ],
  headerParameters: [
    prevSnapshotUrl,
    range0,
    version,
    requestId,
    leaseId0,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  responses: {
    200: {
      bodyMapper: PageList,
      headersMapper: PageBlobGetPageRangesDiffHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: PageBlobGetPageRangesDiffHeaders
    }
  },
  isXML: !0,
  serializer: serializer4
}, resizeOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp0
  ],
  headerParameters: [
    encryptionScope,
    blobContentLength,
    version,
    requestId,
    leaseId0,
    encryptionKey,
    encryptionKeySha256,
    encryptionAlgorithm,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  responses: {
    200: {
      headersMapper: PageBlobResizeHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: PageBlobResizeHeaders
    }
  },
  isXML: !0,
  serializer: serializer4
}, updateSequenceNumberOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp0
  ],
  headerParameters: [
    sequenceNumberAction,
    blobSequenceNumber,
    version,
    requestId,
    leaseId0,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  responses: {
    200: {
      headersMapper: PageBlobUpdateSequenceNumberHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: PageBlobUpdateSequenceNumberHeaders
    }
  },
  isXML: !0,
  serializer: serializer4
}, copyIncrementalOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp18
  ],
  headerParameters: [
    copySource,
    version,
    requestId,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  responses: {
    202: {
      headersMapper: PageBlobCopyIncrementalHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: PageBlobCopyIncrementalHeaders
    }
  },
  isXML: !0,
  serializer: serializer4
};

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/generated/src/models/appendBlobMappers.js
var appendBlobMappers_exports = {};
__export(appendBlobMappers_exports, {
  AppendBlobAppendBlockFromUrlHeaders: () => AppendBlobAppendBlockFromUrlHeaders,
  AppendBlobAppendBlockHeaders: () => AppendBlobAppendBlockHeaders,
  AppendBlobCreateHeaders: () => AppendBlobCreateHeaders,
  AppendBlobSealHeaders: () => AppendBlobSealHeaders,
  StorageError: () => StorageError
});

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/generated/src/operations/appendBlob.js
var AppendBlob = function() {
  function AppendBlob2(client) {
    this.client = client;
  }
  return __name(AppendBlob2, "AppendBlob"), AppendBlob2.prototype.create = function(contentLength2, options, callback) {
    return this.client.sendOperationRequest({
      contentLength: contentLength2,
      options
    }, createOperationSpec3, callback);
  }, AppendBlob2.prototype.appendBlock = function(body, contentLength2, options, callback) {
    return this.client.sendOperationRequest({
      body,
      contentLength: contentLength2,
      options
    }, appendBlockOperationSpec, callback);
  }, AppendBlob2.prototype.appendBlockFromUrl = function(sourceUrl2, contentLength2, options, callback) {
    return this.client.sendOperationRequest({
      sourceUrl: sourceUrl2,
      contentLength: contentLength2,
      options
    }, appendBlockFromUrlOperationSpec, callback);
  }, AppendBlob2.prototype.seal = function(options, callback) {
    return this.client.sendOperationRequest({
      options
    }, sealOperationSpec, callback);
  }, AppendBlob2;
}();
var serializer5 = new Serializer(appendBlobMappers_exports, !0), createOperationSpec3 = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds
  ],
  headerParameters: [
    contentLength,
    metadata,
    encryptionScope,
    version,
    requestId,
    blobTagsString,
    blobType1,
    blobContentType,
    blobContentEncoding,
    blobContentLanguage,
    blobContentMD5,
    blobCacheControl,
    blobContentDisposition,
    leaseId0,
    encryptionKey,
    encryptionKeySha256,
    encryptionAlgorithm,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  responses: {
    201: {
      headersMapper: AppendBlobCreateHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: AppendBlobCreateHeaders
    }
  },
  isXML: !0,
  serializer: serializer5
}, appendBlockOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp19
  ],
  headerParameters: [
    contentLength,
    transactionalContentMD5,
    transactionalContentCrc64,
    encryptionScope,
    version,
    requestId,
    leaseId0,
    maxSize,
    appendPosition,
    encryptionKey,
    encryptionKeySha256,
    encryptionAlgorithm,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  requestBody: {
    parameterPath: "body",
    mapper: {
      required: !0,
      serializedName: "body",
      type: {
        name: "Stream"
      }
    }
  },
  contentType: "application/octet-stream",
  responses: {
    201: {
      headersMapper: AppendBlobAppendBlockHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: AppendBlobAppendBlockHeaders
    }
  },
  isXML: !0,
  serializer: serializer5
}, appendBlockFromUrlOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp19
  ],
  headerParameters: [
    sourceUrl,
    sourceRange1,
    sourceContentMD5,
    sourceContentCrc64,
    contentLength,
    transactionalContentMD5,
    encryptionScope,
    version,
    requestId,
    encryptionKey,
    encryptionKeySha256,
    encryptionAlgorithm,
    leaseId0,
    maxSize,
    appendPosition,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags,
    sourceIfModifiedSince,
    sourceIfUnmodifiedSince,
    sourceIfMatch,
    sourceIfNoneMatch
  ],
  responses: {
    201: {
      headersMapper: AppendBlobAppendBlockFromUrlHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: AppendBlobAppendBlockFromUrlHeaders
    }
  },
  isXML: !0,
  serializer: serializer5
}, sealOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp20
  ],
  headerParameters: [
    version,
    requestId,
    leaseId0,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    appendPosition
  ],
  responses: {
    200: {
      headersMapper: AppendBlobSealHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: AppendBlobSealHeaders
    }
  },
  isXML: !0,
  serializer: serializer5
};

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/generated/src/models/blockBlobMappers.js
var blockBlobMappers_exports = {};
__export(blockBlobMappers_exports, {
  Block: () => Block,
  BlockBlobCommitBlockListHeaders: () => BlockBlobCommitBlockListHeaders,
  BlockBlobGetBlockListHeaders: () => BlockBlobGetBlockListHeaders,
  BlockBlobPutBlobFromUrlHeaders: () => BlockBlobPutBlobFromUrlHeaders,
  BlockBlobStageBlockFromURLHeaders: () => BlockBlobStageBlockFromURLHeaders,
  BlockBlobStageBlockHeaders: () => BlockBlobStageBlockHeaders,
  BlockBlobUploadHeaders: () => BlockBlobUploadHeaders,
  BlockList: () => BlockList,
  BlockLookupList: () => BlockLookupList,
  StorageError: () => StorageError
});

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/generated/src/operations/blockBlob.js
var BlockBlob = function() {
  function BlockBlob2(client) {
    this.client = client;
  }
  return __name(BlockBlob2, "BlockBlob"), BlockBlob2.prototype.upload = function(body, contentLength2, options, callback) {
    return this.client.sendOperationRequest({
      body,
      contentLength: contentLength2,
      options
    }, uploadOperationSpec, callback);
  }, BlockBlob2.prototype.putBlobFromUrl = function(contentLength2, copySource2, options, callback) {
    return this.client.sendOperationRequest({
      contentLength: contentLength2,
      copySource: copySource2,
      options
    }, putBlobFromUrlOperationSpec, callback);
  }, BlockBlob2.prototype.stageBlock = function(blockId2, contentLength2, body, options, callback) {
    return this.client.sendOperationRequest({
      blockId: blockId2,
      contentLength: contentLength2,
      body,
      options
    }, stageBlockOperationSpec, callback);
  }, BlockBlob2.prototype.stageBlockFromURL = function(blockId2, contentLength2, sourceUrl2, options, callback) {
    return this.client.sendOperationRequest({
      blockId: blockId2,
      contentLength: contentLength2,
      sourceUrl: sourceUrl2,
      options
    }, stageBlockFromURLOperationSpec, callback);
  }, BlockBlob2.prototype.commitBlockList = function(blocks, options, callback) {
    return this.client.sendOperationRequest({
      blocks,
      options
    }, commitBlockListOperationSpec, callback);
  }, BlockBlob2.prototype.getBlockList = function(listType2, options, callback) {
    return this.client.sendOperationRequest({
      listType: listType2,
      options
    }, getBlockListOperationSpec, callback);
  }, BlockBlob2;
}();
var serializer6 = new Serializer(blockBlobMappers_exports, !0), uploadOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds
  ],
  headerParameters: [
    transactionalContentMD5,
    contentLength,
    metadata,
    encryptionScope,
    tier0,
    version,
    requestId,
    blobTagsString,
    blobType2,
    blobContentType,
    blobContentEncoding,
    blobContentLanguage,
    blobContentMD5,
    blobCacheControl,
    blobContentDisposition,
    leaseId0,
    encryptionKey,
    encryptionKeySha256,
    encryptionAlgorithm,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  requestBody: {
    parameterPath: "body",
    mapper: {
      required: !0,
      serializedName: "body",
      type: {
        name: "Stream"
      }
    }
  },
  contentType: "application/octet-stream",
  responses: {
    201: {
      headersMapper: BlockBlobUploadHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlockBlobUploadHeaders
    }
  },
  isXML: !0,
  serializer: serializer6
}, putBlobFromUrlOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds
  ],
  headerParameters: [
    transactionalContentMD5,
    contentLength,
    metadata,
    encryptionScope,
    tier0,
    version,
    requestId,
    sourceContentMD5,
    blobTagsString,
    copySource,
    copySourceBlobProperties,
    blobType2,
    blobContentType,
    blobContentEncoding,
    blobContentLanguage,
    blobContentMD5,
    blobCacheControl,
    blobContentDisposition,
    leaseId0,
    encryptionKey,
    encryptionKeySha256,
    encryptionAlgorithm,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags,
    sourceIfModifiedSince,
    sourceIfUnmodifiedSince,
    sourceIfMatch,
    sourceIfNoneMatch,
    sourceIfTags
  ],
  responses: {
    201: {
      headersMapper: BlockBlobPutBlobFromUrlHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlockBlobPutBlobFromUrlHeaders
    }
  },
  isXML: !0,
  serializer: serializer6
}, stageBlockOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    blockId,
    timeoutInSeconds,
    comp21
  ],
  headerParameters: [
    contentLength,
    transactionalContentMD5,
    transactionalContentCrc64,
    encryptionScope,
    version,
    requestId,
    leaseId0,
    encryptionKey,
    encryptionKeySha256,
    encryptionAlgorithm
  ],
  requestBody: {
    parameterPath: "body",
    mapper: {
      required: !0,
      serializedName: "body",
      type: {
        name: "Stream"
      }
    }
  },
  contentType: "application/octet-stream",
  responses: {
    201: {
      headersMapper: BlockBlobStageBlockHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlockBlobStageBlockHeaders
    }
  },
  isXML: !0,
  serializer: serializer6
}, stageBlockFromURLOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    blockId,
    timeoutInSeconds,
    comp21
  ],
  headerParameters: [
    contentLength,
    sourceUrl,
    sourceRange1,
    sourceContentMD5,
    sourceContentCrc64,
    encryptionScope,
    version,
    requestId,
    encryptionKey,
    encryptionKeySha256,
    encryptionAlgorithm,
    leaseId0,
    sourceIfModifiedSince,
    sourceIfUnmodifiedSince,
    sourceIfMatch,
    sourceIfNoneMatch
  ],
  responses: {
    201: {
      headersMapper: BlockBlobStageBlockFromURLHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlockBlobStageBlockFromURLHeaders
    }
  },
  isXML: !0,
  serializer: serializer6
}, commitBlockListOperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    timeoutInSeconds,
    comp22
  ],
  headerParameters: [
    transactionalContentMD5,
    transactionalContentCrc64,
    metadata,
    encryptionScope,
    tier0,
    version,
    requestId,
    blobTagsString,
    blobCacheControl,
    blobContentType,
    blobContentEncoding,
    blobContentLanguage,
    blobContentMD5,
    blobContentDisposition,
    leaseId0,
    encryptionKey,
    encryptionKeySha256,
    encryptionAlgorithm,
    ifModifiedSince,
    ifUnmodifiedSince,
    ifMatch,
    ifNoneMatch,
    ifTags
  ],
  requestBody: {
    parameterPath: "blocks",
    mapper: __assign(__assign({}, BlockLookupList), {required: !0})
  },
  contentType: "application/xml; charset=utf-8",
  responses: {
    201: {
      headersMapper: BlockBlobCommitBlockListHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlockBlobCommitBlockListHeaders
    }
  },
  isXML: !0,
  serializer: serializer6
}, getBlockListOperationSpec = {
  httpMethod: "GET",
  path: "{containerName}/{blob}",
  urlParameters: [
    url
  ],
  queryParameters: [
    snapshot,
    listType,
    timeoutInSeconds,
    comp22
  ],
  headerParameters: [
    version,
    requestId,
    leaseId0,
    ifTags
  ],
  responses: {
    200: {
      bodyMapper: BlockList,
      headersMapper: BlockBlobGetBlockListHeaders
    },
    default: {
      bodyMapper: StorageError,
      headersMapper: BlockBlobGetBlockListHeaders
    }
  },
  isXML: !0,
  serializer: serializer6
};

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/log.js
var logger2 = createClientLogger("storage-blob");

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/utils/constants.js
var SDK_VERSION = "12.4.0", SERVICE_VERSION = "2020-04-08", BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES = 256 * 1024 * 1024, BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES = 4e3 * 1024 * 1024, BLOCK_BLOB_MAX_BLOCKS = 5e4, DEFAULT_BLOCK_BUFFER_SIZE_BYTES = 8 * 1024 * 1024, DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES = 4 * 1024 * 1024, DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS = 5, StorageOAuthScopes = "https://storage.azure.com/.default", URLConstants = {
  Parameters: {
    FORCE_BROWSER_NO_CACHE: "_",
    SIGNATURE: "sig",
    SNAPSHOT: "snapshot",
    VERSIONID: "versionid",
    TIMEOUT: "timeout"
  }
}, HTTPURLConnection = {
  HTTP_ACCEPTED: 202,
  HTTP_CONFLICT: 409,
  HTTP_NOT_FOUND: 404,
  HTTP_PRECON_FAILED: 412,
  HTTP_RANGE_NOT_SATISFIABLE: 416
}, HeaderConstants = {
  AUTHORIZATION: "Authorization",
  AUTHORIZATION_SCHEME: "Bearer",
  CONTENT_ENCODING: "Content-Encoding",
  CONTENT_ID: "Content-ID",
  CONTENT_LANGUAGE: "Content-Language",
  CONTENT_LENGTH: "Content-Length",
  CONTENT_MD5: "Content-Md5",
  CONTENT_TRANSFER_ENCODING: "Content-Transfer-Encoding",
  CONTENT_TYPE: "Content-Type",
  COOKIE: "Cookie",
  DATE: "date",
  IF_MATCH: "if-match",
  IF_MODIFIED_SINCE: "if-modified-since",
  IF_NONE_MATCH: "if-none-match",
  IF_UNMODIFIED_SINCE: "if-unmodified-since",
  PREFIX_FOR_STORAGE: "x-ms-",
  RANGE: "Range",
  USER_AGENT: "User-Agent",
  X_MS_CLIENT_REQUEST_ID: "x-ms-client-request-id",
  X_MS_COPY_SOURCE: "x-ms-copy-source",
  X_MS_DATE: "x-ms-date",
  X_MS_ERROR_CODE: "x-ms-error-code",
  X_MS_VERSION: "x-ms-version"
}, ETagNone = "", ETagAny = "*", SIZE_1_MB = 1 * 1024 * 1024, BATCH_MAX_REQUEST = 256, BATCH_MAX_PAYLOAD_IN_BYTES = 4 * SIZE_1_MB, HTTP_LINE_ENDING = `\r
`, HTTP_VERSION_1_1 = "HTTP/1.1", EncryptionAlgorithmAES25 = "AES256", DevelopmentConnectionString = "DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;", StorageBlobLoggingAllowedHeaderNames = [
  "Access-Control-Allow-Origin",
  "Cache-Control",
  "Content-Length",
  "Content-Type",
  "Date",
  "Request-Id",
  "traceparent",
  "Transfer-Encoding",
  "User-Agent",
  "x-ms-client-request-id",
  "x-ms-date",
  "x-ms-error-code",
  "x-ms-request-id",
  "x-ms-return-client-request-id",
  "x-ms-version",
  "Accept-Ranges",
  "Content-Disposition",
  "Content-Encoding",
  "Content-Language",
  "Content-MD5",
  "Content-Range",
  "ETag",
  "Last-Modified",
  "Server",
  "Vary",
  "x-ms-content-crc64",
  "x-ms-copy-action",
  "x-ms-copy-completion-time",
  "x-ms-copy-id",
  "x-ms-copy-progress",
  "x-ms-copy-status",
  "x-ms-has-immutability-policy",
  "x-ms-has-legal-hold",
  "x-ms-lease-state",
  "x-ms-lease-status",
  "x-ms-range",
  "x-ms-request-server-encrypted",
  "x-ms-server-encrypted",
  "x-ms-snapshot",
  "x-ms-source-range",
  "If-Match",
  "If-Modified-Since",
  "If-None-Match",
  "If-Unmodified-Since",
  "x-ms-access-tier",
  "x-ms-access-tier-change-time",
  "x-ms-access-tier-inferred",
  "x-ms-account-kind",
  "x-ms-archive-status",
  "x-ms-blob-append-offset",
  "x-ms-blob-cache-control",
  "x-ms-blob-committed-block-count",
  "x-ms-blob-condition-appendpos",
  "x-ms-blob-condition-maxsize",
  "x-ms-blob-content-disposition",
  "x-ms-blob-content-encoding",
  "x-ms-blob-content-language",
  "x-ms-blob-content-length",
  "x-ms-blob-content-md5",
  "x-ms-blob-content-type",
  "x-ms-blob-public-access",
  "x-ms-blob-sequence-number",
  "x-ms-blob-type",
  "x-ms-copy-destination-snapshot",
  "x-ms-creation-time",
  "x-ms-default-encryption-scope",
  "x-ms-delete-snapshots",
  "x-ms-delete-type-permanent",
  "x-ms-deny-encryption-scope-override",
  "x-ms-encryption-algorithm",
  "x-ms-if-sequence-number-eq",
  "x-ms-if-sequence-number-le",
  "x-ms-if-sequence-number-lt",
  "x-ms-incremental-copy",
  "x-ms-lease-action",
  "x-ms-lease-break-period",
  "x-ms-lease-duration",
  "x-ms-lease-id",
  "x-ms-lease-time",
  "x-ms-page-write",
  "x-ms-proposed-lease-id",
  "x-ms-range-get-content-md5",
  "x-ms-rehydrate-priority",
  "x-ms-sequence-number-action",
  "x-ms-sku-name",
  "x-ms-source-content-md5",
  "x-ms-source-if-match",
  "x-ms-source-if-modified-since",
  "x-ms-source-if-none-match",
  "x-ms-source-if-unmodified-since",
  "x-ms-tag-count",
  "x-ms-encryption-key-sha256",
  "x-ms-if-tags",
  "x-ms-source-if-tags"
], StorageBlobLoggingAllowedQueryParameters = [
  "comp",
  "maxresults",
  "rscc",
  "rscd",
  "rsce",
  "rscl",
  "rsct",
  "se",
  "si",
  "sip",
  "sp",
  "spr",
  "sr",
  "srt",
  "ss",
  "st",
  "sv",
  "include",
  "marker",
  "prefix",
  "copyid",
  "restype",
  "blockid",
  "blocklisttype",
  "delimiter",
  "prevsnapshot",
  "ske",
  "skoid",
  "sks",
  "skt",
  "sktid",
  "skv",
  "snapshot"
];

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/utils/utils.common.js
function escapeURLPath(url2) {
  var urlParsed = URLBuilder.parse(url2), path3 = urlParsed.getPath();
  return path3 = path3 || "/", path3 = escape(path3), urlParsed.setPath(path3), urlParsed.toString();
}
__name(escapeURLPath, "escapeURLPath");
function getProxyUriFromDevConnString(connectionString) {
  var proxyUri = "";
  if (connectionString.search("DevelopmentStorageProxyUri=") !== -1)
    for (var matchCredentials = connectionString.split(";"), _i = 0, matchCredentials_1 = matchCredentials; _i < matchCredentials_1.length; _i++) {
      var element = matchCredentials_1[_i];
      element.trim().startsWith("DevelopmentStorageProxyUri=") && (proxyUri = element.trim().match("DevelopmentStorageProxyUri=(.*)")[1]);
    }
  return proxyUri;
}
__name(getProxyUriFromDevConnString, "getProxyUriFromDevConnString");
function getValueInConnString(connectionString, argument) {
  for (var elements = connectionString.split(";"), _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
    var element = elements_1[_i];
    if (element.trim().startsWith(argument))
      return element.trim().match(argument + "=(.*)")[1];
  }
  return "";
}
__name(getValueInConnString, "getValueInConnString");
function extractConnectionStringParts(connectionString) {
  var proxyUri = "";
  connectionString.startsWith("UseDevelopmentStorage=true") && (proxyUri = getProxyUriFromDevConnString(connectionString), connectionString = DevelopmentConnectionString);
  var blobEndpoint = getValueInConnString(connectionString, "BlobEndpoint");
  if (blobEndpoint = blobEndpoint.endsWith("/") ? blobEndpoint.slice(0, -1) : blobEndpoint, connectionString.search("DefaultEndpointsProtocol=") !== -1 && connectionString.search("AccountKey=") !== -1) {
    var defaultEndpointsProtocol = "", accountName = "", accountKey = Buffer.from("accountKey", "base64"), endpointSuffix = "";
    if (accountName = getValueInConnString(connectionString, "AccountName"), accountKey = Buffer.from(getValueInConnString(connectionString, "AccountKey"), "base64"), !blobEndpoint) {
      defaultEndpointsProtocol = getValueInConnString(connectionString, "DefaultEndpointsProtocol");
      var protocol = defaultEndpointsProtocol.toLowerCase();
      if (protocol !== "https" && protocol !== "http")
        throw new Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
      if (endpointSuffix = getValueInConnString(connectionString, "EndpointSuffix"), !endpointSuffix)
        throw new Error("Invalid EndpointSuffix in the provided Connection String");
      blobEndpoint = defaultEndpointsProtocol + "://" + accountName + ".blob." + endpointSuffix;
    }
    if (accountName) {
      if (accountKey.length === 0)
        throw new Error("Invalid AccountKey in the provided Connection String");
    } else
      throw new Error("Invalid AccountName in the provided Connection String");
    return {
      kind: "AccountConnString",
      url: blobEndpoint,
      accountName,
      accountKey,
      proxyUri
    };
  } else {
    var accountSas = getValueInConnString(connectionString, "SharedAccessSignature"), accountName = getAccountNameFromUrl(blobEndpoint);
    if (blobEndpoint) {
      if (!accountSas)
        throw new Error("Invalid SharedAccessSignature in the provided SAS Connection String");
    } else
      throw new Error("Invalid BlobEndpoint in the provided SAS Connection String");
    return {kind: "SASConnString", url: blobEndpoint, accountName, accountSas};
  }
}
__name(extractConnectionStringParts, "extractConnectionStringParts");
function escape(text) {
  return encodeURIComponent(text).replace(/%2F/g, "/").replace(/'/g, "%27").replace(/\+/g, "%20").replace(/%25/g, "%");
}
__name(escape, "escape");
function appendToURLPath(url2, name) {
  var urlParsed = URLBuilder.parse(url2), path3 = urlParsed.getPath();
  return path3 = path3 ? path3.endsWith("/") ? "" + path3 + name : path3 + "/" + name : name, urlParsed.setPath(path3), urlParsed.toString();
}
__name(appendToURLPath, "appendToURLPath");
function setURLParameter(url2, name, value) {
  var urlParsed = URLBuilder.parse(url2);
  return urlParsed.setQueryParameter(name, value), urlParsed.toString();
}
__name(setURLParameter, "setURLParameter");
function getURLParameter(url2, name) {
  var urlParsed = URLBuilder.parse(url2);
  return urlParsed.getQueryParameterValue(name);
}
__name(getURLParameter, "getURLParameter");
function setURLHost(url2, host) {
  var urlParsed = URLBuilder.parse(url2);
  return urlParsed.setHost(host), urlParsed.toString();
}
__name(setURLHost, "setURLHost");
function getURLPath(url2) {
  var urlParsed = URLBuilder.parse(url2);
  return urlParsed.getPath();
}
__name(getURLPath, "getURLPath");
function getURLScheme(url2) {
  var urlParsed = URLBuilder.parse(url2);
  return urlParsed.getScheme();
}
__name(getURLScheme, "getURLScheme");
function getURLPathAndQuery(url2) {
  var urlParsed = URLBuilder.parse(url2), pathString = urlParsed.getPath();
  if (!pathString)
    throw new RangeError("Invalid url without valid path.");
  var queryString = urlParsed.getQuery() || "";
  return queryString = queryString.trim(), queryString != "" && (queryString = queryString.startsWith("?") ? queryString : "?" + queryString), "" + pathString + queryString;
}
__name(getURLPathAndQuery, "getURLPathAndQuery");
function getURLQueries(url2) {
  var queryString = URLBuilder.parse(url2).getQuery();
  if (!queryString)
    return {};
  queryString = queryString.trim(), queryString = queryString.startsWith("?") ? queryString.substr(1) : queryString;
  var querySubStrings = queryString.split("&");
  querySubStrings = querySubStrings.filter(function(value2) {
    var indexOfEqual = value2.indexOf("="), lastIndexOfEqual = value2.lastIndexOf("=");
    return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value2.length - 1;
  });
  for (var queries = {}, _i = 0, querySubStrings_1 = querySubStrings; _i < querySubStrings_1.length; _i++) {
    var querySubString = querySubStrings_1[_i], splitResults = querySubString.split("="), key = splitResults[0], value = splitResults[1];
    queries[key] = value;
  }
  return queries;
}
__name(getURLQueries, "getURLQueries");
function appendToURLQuery(url2, queryParts) {
  var urlParsed = URLBuilder.parse(url2), query = urlParsed.getQuery();
  return query ? query += "&" + queryParts : query = queryParts, urlParsed.setQuery(query), urlParsed.toString();
}
__name(appendToURLQuery, "appendToURLQuery");
function truncatedISO8061Date(date, withMilliseconds) {
  withMilliseconds === void 0 && (withMilliseconds = !0);
  var dateString = date.toISOString();
  return withMilliseconds ? dateString.substring(0, dateString.length - 1) + "0000Z" : dateString.substring(0, dateString.length - 5) + "Z";
}
__name(truncatedISO8061Date, "truncatedISO8061Date");
function base64encode(content) {
  return isNode ? Buffer.from(content).toString("base64") : btoa(content);
}
__name(base64encode, "base64encode");
function generateBlockID(blockIDPrefix, blockIndex) {
  var maxSourceStringLength = 48, maxBlockIndexLength = 6, maxAllowedBlockIDPrefixLength = maxSourceStringLength - maxBlockIndexLength;
  blockIDPrefix.length > maxAllowedBlockIDPrefixLength && (blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength));
  var res = blockIDPrefix + padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, "0");
  return base64encode(res);
}
__name(generateBlockID, "generateBlockID");
function delay2(timeInMs, aborter, abortError) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a) {
      return [2, new Promise(function(resolve, reject) {
        var timeout, abortHandler = /* @__PURE__ */ __name(function() {
          timeout !== void 0 && clearTimeout(timeout), reject(abortError);
        }, "abortHandler"), resolveHandler = /* @__PURE__ */ __name(function() {
          aborter !== void 0 && aborter.removeEventListener("abort", abortHandler), resolve();
        }, "resolveHandler");
        timeout = setTimeout(resolveHandler, timeInMs), aborter !== void 0 && aborter.addEventListener("abort", abortHandler);
      })];
    });
  });
}
__name(delay2, "delay");
function padStart(currentString, targetLength, padString) {
  return padString === void 0 && (padString = " "), String.prototype.padStart ? currentString.padStart(targetLength, padString) : (padString = padString || " ", currentString.length > targetLength ? currentString : (targetLength = targetLength - currentString.length, targetLength > padString.length && (padString += padString.repeat(targetLength / padString.length)), padString.slice(0, targetLength) + currentString));
}
__name(padStart, "padStart");
function iEqual(str1, str2) {
  return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();
}
__name(iEqual, "iEqual");
function getAccountNameFromUrl(url2) {
  var parsedUrl = URLBuilder.parse(url2), accountName;
  try {
    return parsedUrl.getHost().split(".")[1] === "blob" ? accountName = parsedUrl.getHost().split(".")[0] : isIpEndpointStyle(parsedUrl) ? accountName = parsedUrl.getPath().split("/")[1] : accountName = "", accountName;
  } catch (error) {
    throw new Error("Unable to extract accountName with provided information.");
  }
}
__name(getAccountNameFromUrl, "getAccountNameFromUrl");
function isIpEndpointStyle(parsedUrl) {
  if (parsedUrl.getHost() == null)
    return !1;
  var host = parsedUrl.getHost() + (parsedUrl.getPort() == null ? "" : ":" + parsedUrl.getPort());
  return /^.*:.*:.*$|^localhost(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(host);
}
__name(isIpEndpointStyle, "isIpEndpointStyle");
function toBlobTagsString(tags) {
  if (tags !== void 0) {
    var tagPairs = [];
    for (var key in tags)
      if (tags.hasOwnProperty(key)) {
        var value = tags[key];
        tagPairs.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
      }
    return tagPairs.join("&");
  }
}
__name(toBlobTagsString, "toBlobTagsString");
function toBlobTags(tags) {
  if (tags !== void 0) {
    var res = {
      blobTagSet: []
    };
    for (var key in tags)
      if (tags.hasOwnProperty(key)) {
        var value = tags[key];
        res.blobTagSet.push({
          key,
          value
        });
      }
    return res;
  }
}
__name(toBlobTags, "toBlobTags");
function toTags(tags) {
  if (tags !== void 0) {
    for (var res = {}, _i = 0, _a = tags.blobTagSet; _i < _a.length; _i++) {
      var blobTag = _a[_i];
      res[blobTag.key] = blobTag.value;
    }
    return res;
  }
}
__name(toTags, "toTags");
function toQuerySerialization(textConfiguration) {
  if (textConfiguration !== void 0)
    switch (textConfiguration.kind) {
      case "csv":
        return {
          format: {
            type: "delimited",
            delimitedTextConfiguration: {
              columnSeparator: textConfiguration.columnSeparator || ",",
              fieldQuote: textConfiguration.fieldQuote || "",
              recordSeparator: textConfiguration.recordSeparator,
              escapeChar: textConfiguration.escapeCharacter || "",
              headersPresent: textConfiguration.hasHeaders || !1
            }
          }
        };
      case "json":
        return {
          format: {
            type: "json",
            jsonTextConfiguration: {
              recordSeparator: textConfiguration.recordSeparator
            }
          }
        };
      case "arrow":
        return {
          format: {
            type: "arrow",
            arrowConfiguration: {
              schema: textConfiguration.schema
            }
          }
        };
      default:
        throw Error("Invalid BlobQueryTextConfiguration.");
    }
}
__name(toQuerySerialization, "toQuerySerialization");
function parseObjectReplicationRecord(objectReplicationRecord) {
  if (!!objectReplicationRecord && !("policy-id" in objectReplicationRecord)) {
    var orProperties = [], _loop_1 = /* @__PURE__ */ __name(function(key2) {
      var ids = key2.split("_"), policyPrefix = "or-";
      ids[0].startsWith(policyPrefix) && (ids[0] = ids[0].substring(policyPrefix.length));
      var rule = {
        ruleId: ids[1],
        replicationStatus: objectReplicationRecord[key2]
      }, policyIndex = orProperties.findIndex(function(policy) {
        return policy.policyId === ids[0];
      });
      policyIndex > -1 ? orProperties[policyIndex].rules.push(rule) : orProperties.push({
        policyId: ids[0],
        rules: [rule]
      });
    }, "_loop_1");
    for (var key in objectReplicationRecord)
      _loop_1(key);
    return orProperties;
  }
}
__name(parseObjectReplicationRecord, "parseObjectReplicationRecord");
function attachCredential(thing, credential) {
  return thing.credential = credential, thing;
}
__name(attachCredential, "attachCredential");

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/policies/StorageBrowserPolicy.js
var StorageBrowserPolicy = function(_super) {
  __extends(StorageBrowserPolicy2, _super);
  function StorageBrowserPolicy2(nextPolicy, options) {
    return _super.call(this, nextPolicy, options) || this;
  }
  return __name(StorageBrowserPolicy2, "StorageBrowserPolicy"), StorageBrowserPolicy2.prototype.sendRequest = function(request) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        return isNode ? [2, this._nextPolicy.sendRequest(request)] : ((request.method.toUpperCase() === "GET" || request.method.toUpperCase() === "HEAD") && (request.url = setURLParameter(request.url, URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, new Date().getTime().toString())), request.headers.remove(HeaderConstants.COOKIE), request.headers.remove(HeaderConstants.CONTENT_LENGTH), [2, this._nextPolicy.sendRequest(request)]);
      });
    });
  }, StorageBrowserPolicy2;
}(BaseRequestPolicy);

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/StorageBrowserPolicyFactory.js
var StorageBrowserPolicyFactory = function() {
  function StorageBrowserPolicyFactory2() {
  }
  return __name(StorageBrowserPolicyFactory2, "StorageBrowserPolicyFactory"), StorageBrowserPolicyFactory2.prototype.create = function(nextPolicy, options) {
    return new StorageBrowserPolicy(nextPolicy, options);
  }, StorageBrowserPolicyFactory2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/policies/StorageRetryPolicy.js
var StorageRetryPolicyType;
(function(StorageRetryPolicyType2) {
  StorageRetryPolicyType2[StorageRetryPolicyType2.EXPONENTIAL = 0] = "EXPONENTIAL", StorageRetryPolicyType2[StorageRetryPolicyType2.FIXED = 1] = "FIXED";
})(StorageRetryPolicyType || (StorageRetryPolicyType = {}));
var DEFAULT_RETRY_OPTIONS = {
  maxRetryDelayInMs: 120 * 1e3,
  maxTries: 4,
  retryDelayInMs: 4 * 1e3,
  retryPolicyType: StorageRetryPolicyType.EXPONENTIAL,
  secondaryHost: "",
  tryTimeoutInMs: void 0
}, RETRY_ABORT_ERROR = new AbortError2("The operation was aborted."), StorageRetryPolicy = function(_super) {
  __extends(StorageRetryPolicy2, _super);
  function StorageRetryPolicy2(nextPolicy, options, retryOptions) {
    retryOptions === void 0 && (retryOptions = DEFAULT_RETRY_OPTIONS);
    var _this = _super.call(this, nextPolicy, options) || this;
    return _this.retryOptions = {
      retryPolicyType: retryOptions.retryPolicyType ? retryOptions.retryPolicyType : DEFAULT_RETRY_OPTIONS.retryPolicyType,
      maxTries: retryOptions.maxTries && retryOptions.maxTries >= 1 ? Math.floor(retryOptions.maxTries) : DEFAULT_RETRY_OPTIONS.maxTries,
      tryTimeoutInMs: retryOptions.tryTimeoutInMs && retryOptions.tryTimeoutInMs >= 0 ? retryOptions.tryTimeoutInMs : DEFAULT_RETRY_OPTIONS.tryTimeoutInMs,
      retryDelayInMs: retryOptions.retryDelayInMs && retryOptions.retryDelayInMs >= 0 ? Math.min(retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs) : DEFAULT_RETRY_OPTIONS.retryDelayInMs,
      maxRetryDelayInMs: retryOptions.maxRetryDelayInMs && retryOptions.maxRetryDelayInMs >= 0 ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs,
      secondaryHost: retryOptions.secondaryHost ? retryOptions.secondaryHost : DEFAULT_RETRY_OPTIONS.secondaryHost
    }, _this;
  }
  return __name(StorageRetryPolicy2, "StorageRetryPolicy"), StorageRetryPolicy2.prototype.sendRequest = function(request) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        return [2, this.attemptSendRequest(request, !1, 1)];
      });
    });
  }, StorageRetryPolicy2.prototype.attemptSendRequest = function(request, secondaryHas404, attempt) {
    return __awaiter(this, void 0, void 0, function() {
      var newRequest, isPrimaryRetry, response, err_1;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            newRequest = request.clone(), isPrimaryRetry = secondaryHas404 || !this.retryOptions.secondaryHost || !(request.method === "GET" || request.method === "HEAD" || request.method === "OPTIONS") || attempt % 2 == 1, isPrimaryRetry || (newRequest.url = setURLHost(newRequest.url, this.retryOptions.secondaryHost)), this.retryOptions.tryTimeoutInMs && (newRequest.url = setURLParameter(newRequest.url, URLConstants.Parameters.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1e3).toString())), _a.label = 1;
          case 1:
            return _a.trys.push([1, 3, , 4]), logger2.info("RetryPolicy: =====> Try=" + attempt + " " + (isPrimaryRetry ? "Primary" : "Secondary")), [4, this._nextPolicy.sendRequest(newRequest)];
          case 2:
            return response = _a.sent(), this.shouldRetry(isPrimaryRetry, attempt, response) ? (secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404, [3, 4]) : [2, response];
          case 3:
            if (err_1 = _a.sent(), logger2.error("RetryPolicy: Caught error, message: " + err_1.message + ", code: " + err_1.code), !this.shouldRetry(isPrimaryRetry, attempt, response, err_1))
              throw err_1;
            return [3, 4];
          case 4:
            return [4, this.delay(isPrimaryRetry, attempt, request.abortSignal)];
          case 5:
            return _a.sent(), [4, this.attemptSendRequest(request, secondaryHas404, ++attempt)];
          case 6:
            return [2, _a.sent()];
        }
      });
    });
  }, StorageRetryPolicy2.prototype.shouldRetry = function(isPrimaryRetry, attempt, response, err) {
    if (attempt >= this.retryOptions.maxTries)
      return logger2.info("RetryPolicy: Attempt(s) " + attempt + " >= maxTries " + this.retryOptions.maxTries + ", no further try."), !1;
    var retriableErrors = [
      "ETIMEDOUT",
      "ESOCKETTIMEDOUT",
      "ECONNREFUSED",
      "ECONNRESET",
      "ENOENT",
      "ENOTFOUND",
      "TIMEOUT",
      "EPIPE",
      "REQUEST_SEND_ERROR"
    ];
    if (err)
      for (var _i = 0, retriableErrors_1 = retriableErrors; _i < retriableErrors_1.length; _i++) {
        var retriableError = retriableErrors_1[_i];
        if (err.name.toUpperCase().includes(retriableError) || err.message.toUpperCase().includes(retriableError) || err.code && err.code.toString().toUpperCase().includes(retriableError))
          return logger2.info("RetryPolicy: Network error " + retriableError + " found, will retry."), !0;
      }
    if (response || err) {
      var statusCode = response ? response.status : err ? err.statusCode : 0;
      if (!isPrimaryRetry && statusCode === 404)
        return logger2.info("RetryPolicy: Secondary access with 404, will retry."), !0;
      if (statusCode === 503 || statusCode === 500)
        return logger2.info("RetryPolicy: Will retry for status code " + statusCode + "."), !0;
    }
    return !1;
  }, StorageRetryPolicy2.prototype.delay = function(isPrimaryRetry, attempt, abortSignal2) {
    return __awaiter(this, void 0, void 0, function() {
      var delayTimeInMs;
      return __generator(this, function(_a) {
        if (delayTimeInMs = 0, isPrimaryRetry)
          switch (this.retryOptions.retryPolicyType) {
            case StorageRetryPolicyType.EXPONENTIAL:
              delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);
              break;
            case StorageRetryPolicyType.FIXED:
              delayTimeInMs = this.retryOptions.retryDelayInMs;
              break;
          }
        else
          delayTimeInMs = Math.random() * 1e3;
        return logger2.info("RetryPolicy: Delay for " + delayTimeInMs + "ms"), [2, delay2(delayTimeInMs, abortSignal2, RETRY_ABORT_ERROR)];
      });
    });
  }, StorageRetryPolicy2;
}(BaseRequestPolicy);

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/StorageRetryPolicyFactory.js
var StorageRetryPolicyFactory = function() {
  function StorageRetryPolicyFactory2(retryOptions) {
    this.retryOptions = retryOptions;
  }
  return __name(StorageRetryPolicyFactory2, "StorageRetryPolicyFactory"), StorageRetryPolicyFactory2.prototype.create = function(nextPolicy, options) {
    return new StorageRetryPolicy(nextPolicy, options, this.retryOptions);
  }, StorageRetryPolicyFactory2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/policies/CredentialPolicy.js
var CredentialPolicy = function(_super) {
  __extends(CredentialPolicy2, _super);
  function CredentialPolicy2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return __name(CredentialPolicy2, "CredentialPolicy"), CredentialPolicy2.prototype.sendRequest = function(request) {
    return this._nextPolicy.sendRequest(this.signRequest(request));
  }, CredentialPolicy2.prototype.signRequest = function(request) {
    return request;
  }, CredentialPolicy2;
}(BaseRequestPolicy);

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/policies/AnonymousCredentialPolicy.js
var AnonymousCredentialPolicy = function(_super) {
  __extends(AnonymousCredentialPolicy2, _super);
  function AnonymousCredentialPolicy2(nextPolicy, options) {
    return _super.call(this, nextPolicy, options) || this;
  }
  return __name(AnonymousCredentialPolicy2, "AnonymousCredentialPolicy"), AnonymousCredentialPolicy2;
}(CredentialPolicy);

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/credentials/Credential.js
var Credential = function() {
  function Credential2() {
  }
  return __name(Credential2, "Credential"), Credential2.prototype.create = function(_nextPolicy, _options) {
    throw new Error("Method should be implemented in children classes.");
  }, Credential2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/credentials/AnonymousCredential.js
var AnonymousCredential = function(_super) {
  __extends(AnonymousCredential2, _super);
  function AnonymousCredential2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return __name(AnonymousCredential2, "AnonymousCredential"), AnonymousCredential2.prototype.create = function(nextPolicy, options) {
    return new AnonymousCredentialPolicy(nextPolicy, options);
  }, AnonymousCredential2;
}(Credential);

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/TelemetryPolicyFactory.js
var os2 = __toModule(require("os"));

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/policies/TelemetryPolicy.js
var TelemetryPolicy = function(_super) {
  __extends(TelemetryPolicy2, _super);
  function TelemetryPolicy2(nextPolicy, options, telemetry) {
    var _this = _super.call(this, nextPolicy, options) || this;
    return _this.telemetry = telemetry, _this;
  }
  return __name(TelemetryPolicy2, "TelemetryPolicy"), TelemetryPolicy2.prototype.sendRequest = function(request) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        return isNode && (request.headers || (request.headers = new HttpHeaders()), request.headers.get(HeaderConstants.USER_AGENT) || request.headers.set(HeaderConstants.USER_AGENT, this.telemetry)), [2, this._nextPolicy.sendRequest(request)];
      });
    });
  }, TelemetryPolicy2;
}(BaseRequestPolicy);

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/TelemetryPolicyFactory.js
var TelemetryPolicyFactory = function() {
  function TelemetryPolicyFactory2(telemetry) {
    var userAgentInfo = [];
    if (isNode) {
      if (telemetry) {
        var telemetryString = telemetry.userAgentPrefix || "";
        telemetryString.length > 0 && userAgentInfo.indexOf(telemetryString) === -1 && userAgentInfo.push(telemetryString);
      }
      var libInfo = "azsdk-js-storageblob/" + SDK_VERSION;
      userAgentInfo.indexOf(libInfo) === -1 && userAgentInfo.push(libInfo);
      var runtimeInfo = "(NODE-VERSION " + process.version + "; " + os2.type() + " " + os2.release() + ")";
      userAgentInfo.indexOf(runtimeInfo) === -1 && userAgentInfo.push(runtimeInfo);
    }
    this.telemetryString = userAgentInfo.join(" ");
  }
  return __name(TelemetryPolicyFactory2, "TelemetryPolicyFactory"), TelemetryPolicyFactory2.prototype.create = function(nextPolicy, options) {
    return new TelemetryPolicy(nextPolicy, options, this.telemetryString);
  }, TelemetryPolicyFactory2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/utils/cache.js
var _defaultHttpClient = new NodeFetchHttpClient();
function getCachedDefaultHttpClient2() {
  return _defaultHttpClient;
}
__name(getCachedDefaultHttpClient2, "getCachedDefaultHttpClient");

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/Pipeline.js
var Pipeline = function() {
  function Pipeline2(factories, options) {
    options === void 0 && (options = {}), this.factories = factories, this.options = __assign(__assign({}, options), {httpClient: options.httpClient || getCachedDefaultHttpClient2()});
  }
  return __name(Pipeline2, "Pipeline"), Pipeline2.prototype.toServiceClientOptions = function() {
    return {
      httpClient: this.options.httpClient,
      requestPolicyFactories: this.factories
    };
  }, Pipeline2;
}();
function newPipeline(credential, pipelineOptions) {
  pipelineOptions === void 0 && (pipelineOptions = {}), credential === void 0 && (credential = new AnonymousCredential());
  var telemetryPolicy = new TelemetryPolicyFactory(pipelineOptions.userAgentOptions), factories = [
    tracingPolicy({userAgent: telemetryPolicy.telemetryString}),
    keepAlivePolicy(pipelineOptions.keepAliveOptions),
    telemetryPolicy,
    generateClientRequestIdPolicy(),
    new StorageBrowserPolicyFactory(),
    deserializationPolicy(),
    new StorageRetryPolicyFactory(pipelineOptions.retryOptions),
    logPolicy({
      logger: logger2.info,
      allowedHeaderNames: StorageBlobLoggingAllowedHeaderNames,
      allowedQueryParameters: StorageBlobLoggingAllowedQueryParameters
    })
  ];
  return isNode && (factories.push(proxyPolicy(pipelineOptions.proxyOptions)), factories.push(disableResponseDecompressionPolicy())), factories.push(isTokenCredential(credential) ? attachCredential(bearerTokenAuthenticationPolicy(credential, StorageOAuthScopes), credential) : credential), new Pipeline(factories, pipelineOptions);
}
__name(newPipeline, "newPipeline");

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/Clients.js
var import_api4 = __toModule(require_src2());

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/utils/RetriableReadableStream.js
var import_stream3 = __toModule(require("stream"));
var ABORT_ERROR = new AbortError2("The operation was aborted."), RetriableReadableStream = function(_super) {
  __extends(RetriableReadableStream2, _super);
  function RetriableReadableStream2(source, getter, offset, count, options) {
    options === void 0 && (options = {});
    var _this = _super.call(this) || this;
    return _this.retries = 0, _this.abortHandler = function() {
      _this.source.pause(), _this.emit("error", ABORT_ERROR);
    }, _this.aborter = options.abortSignal || AbortSignal.none, _this.getter = getter, _this.source = source, _this.start = offset, _this.offset = offset, _this.end = offset + count - 1, _this.maxRetryRequests = options.maxRetryRequests && options.maxRetryRequests >= 0 ? options.maxRetryRequests : 0, _this.onProgress = options.onProgress, _this.options = options, _this.aborter.addEventListener("abort", _this.abortHandler), _this.setSourceDataHandler(), _this.setSourceEndHandler(), _this.setSourceErrorHandler(), _this;
  }
  return __name(RetriableReadableStream2, "RetriableReadableStream"), RetriableReadableStream2.prototype._read = function() {
    this.aborter.aborted || this.source.resume();
  }, RetriableReadableStream2.prototype.setSourceDataHandler = function() {
    var _this = this;
    this.source.on("data", function(data) {
      if (_this.options.doInjectErrorOnce) {
        _this.options.doInjectErrorOnce = void 0, _this.source.pause(), _this.source.removeAllListeners("data"), _this.source.emit("end");
        return;
      }
      _this.offset += data.length, _this.onProgress && _this.onProgress({loadedBytes: _this.offset - _this.start}), _this.push(data) || _this.source.pause();
    });
  }, RetriableReadableStream2.prototype.setSourceEndHandler = function() {
    var _this = this;
    this.source.on("end", function() {
      _this.offset - 1 === _this.end ? (_this.aborter.removeEventListener("abort", _this.abortHandler), _this.push(null)) : _this.offset <= _this.end ? _this.retries < _this.maxRetryRequests ? (_this.retries += 1, _this.getter(_this.offset).then(function(newSource) {
        _this.source = newSource, _this.setSourceDataHandler(), _this.setSourceEndHandler(), _this.setSourceErrorHandler();
      }).catch(function(error) {
        _this.emit("error", error);
      })) : _this.emit("error", new Error("Data corruption failure: received less data than required and reached maxRetires limitation. Received data offset: " + (_this.offset - 1) + ", data needed offset: " + _this.end + ", retries: " + _this.retries + ", max retries: " + _this.maxRetryRequests)) : _this.emit("error", new Error("Data corruption failure: Received more data than original request, data needed offset is " + _this.end + ", received offset: " + (_this.offset - 1)));
    });
  }, RetriableReadableStream2.prototype.setSourceErrorHandler = function() {
    var _this = this;
    this.source.on("error", function(error) {
      _this.emit("error", error);
    });
  }, RetriableReadableStream2;
}(import_stream3.Readable);

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/BlobDownloadResponse.js
var BlobDownloadResponse = function() {
  function BlobDownloadResponse2(originalResponse, getter, offset, count, options) {
    options === void 0 && (options = {}), this.originalResponse = originalResponse, this.blobDownloadStream = new RetriableReadableStream(this.originalResponse.readableStreamBody, getter, offset, count, options);
  }
  return __name(BlobDownloadResponse2, "BlobDownloadResponse"), Object.defineProperty(BlobDownloadResponse2.prototype, "acceptRanges", {
    get: function() {
      return this.originalResponse.acceptRanges;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "cacheControl", {
    get: function() {
      return this.originalResponse.cacheControl;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "contentDisposition", {
    get: function() {
      return this.originalResponse.contentDisposition;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "contentEncoding", {
    get: function() {
      return this.originalResponse.contentEncoding;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "contentLanguage", {
    get: function() {
      return this.originalResponse.contentLanguage;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "blobSequenceNumber", {
    get: function() {
      return this.originalResponse.blobSequenceNumber;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "blobType", {
    get: function() {
      return this.originalResponse.blobType;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "contentLength", {
    get: function() {
      return this.originalResponse.contentLength;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "contentMD5", {
    get: function() {
      return this.originalResponse.contentMD5;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "contentRange", {
    get: function() {
      return this.originalResponse.contentRange;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "contentType", {
    get: function() {
      return this.originalResponse.contentType;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "copyCompletedOn", {
    get: function() {
      return this.originalResponse.copyCompletedOn;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "copyId", {
    get: function() {
      return this.originalResponse.copyId;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "copyProgress", {
    get: function() {
      return this.originalResponse.copyProgress;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "copySource", {
    get: function() {
      return this.originalResponse.copySource;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "copyStatus", {
    get: function() {
      return this.originalResponse.copyStatus;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "copyStatusDescription", {
    get: function() {
      return this.originalResponse.copyStatusDescription;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "leaseDuration", {
    get: function() {
      return this.originalResponse.leaseDuration;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "leaseState", {
    get: function() {
      return this.originalResponse.leaseState;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "leaseStatus", {
    get: function() {
      return this.originalResponse.leaseStatus;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "date", {
    get: function() {
      return this.originalResponse.date;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "blobCommittedBlockCount", {
    get: function() {
      return this.originalResponse.blobCommittedBlockCount;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "etag", {
    get: function() {
      return this.originalResponse.etag;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "tagCount", {
    get: function() {
      return this.originalResponse.tagCount;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "errorCode", {
    get: function() {
      return this.originalResponse.errorCode;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "isServerEncrypted", {
    get: function() {
      return this.originalResponse.isServerEncrypted;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "blobContentMD5", {
    get: function() {
      return this.originalResponse.blobContentMD5;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "lastModified", {
    get: function() {
      return this.originalResponse.lastModified;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "lastAccessed", {
    get: function() {
      return this.originalResponse.lastAccessed;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "metadata", {
    get: function() {
      return this.originalResponse.metadata;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "requestId", {
    get: function() {
      return this.originalResponse.requestId;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "clientRequestId", {
    get: function() {
      return this.originalResponse.clientRequestId;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "version", {
    get: function() {
      return this.originalResponse.version;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "versionId", {
    get: function() {
      return this.originalResponse.versionId;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "encryptionKeySha256", {
    get: function() {
      return this.originalResponse.encryptionKeySha256;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "contentCrc64", {
    get: function() {
      return this.originalResponse.contentCrc64;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "objectReplicationDestinationPolicyId", {
    get: function() {
      return this.originalResponse.objectReplicationDestinationPolicyId;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "objectReplicationSourceProperties", {
    get: function() {
      return this.originalResponse.objectReplicationSourceProperties;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "isSealed", {
    get: function() {
      return this.originalResponse.isSealed;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "contentAsBlob", {
    get: function() {
      return this.originalResponse.blobBody;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "readableStreamBody", {
    get: function() {
      return isNode ? this.blobDownloadStream : void 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobDownloadResponse2.prototype, "_response", {
    get: function() {
      return this.originalResponse._response;
    },
    enumerable: !1,
    configurable: !0
  }), BlobDownloadResponse2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/utils/BlobQuickQueryStream.js
var import_stream4 = __toModule(require("stream"));

// ../node_modules/@azure/storage-blob/dist-esm/storage-internal-avro/src/AvroConstants.js
var AVRO_SYNC_MARKER_SIZE = 16, AVRO_INIT_BYTES = new Uint8Array([79, 98, 106, 1]), AVRO_CODEC_KEY = "avro.codec", AVRO_SCHEMA_KEY = "avro.schema";

// ../node_modules/@azure/storage-blob/dist-esm/storage-internal-avro/src/utils/utils.common.js
function arraysEqual(a, b) {
  if (a === b)
    return !0;
  if (a == null || b == null || a.length != b.length)
    return !1;
  for (var i = 0; i < a.length; ++i)
    if (a[i] !== b[i])
      return !1;
  return !0;
}
__name(arraysEqual, "arraysEqual");

// ../node_modules/@azure/storage-blob/dist-esm/storage-internal-avro/src/AvroParser.js
var AvroParser = function() {
  function AvroParser2() {
  }
  return __name(AvroParser2, "AvroParser"), AvroParser2.readFixedBytes = function(stream, length, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var bytes;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, stream.read(length, {abortSignal: options.abortSignal})];
          case 1:
            if (bytes = _a.sent(), bytes.length != length)
              throw new Error("Hit stream end.");
            return [2, bytes];
        }
      });
    });
  }, AvroParser2.readByte = function(stream, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var buf;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, AvroParser2.readFixedBytes(stream, 1, options)];
          case 1:
            return buf = _a.sent(), [2, buf[0]];
        }
      });
    });
  }, AvroParser2.readZigZagLong = function(stream, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var zigZagEncoded, significanceInBit, byte, haveMoreByte, significanceInFloat, res;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            zigZagEncoded = 0, significanceInBit = 0, _a.label = 1;
          case 1:
            return [4, AvroParser2.readByte(stream, options)];
          case 2:
            byte = _a.sent(), haveMoreByte = byte & 128, zigZagEncoded |= (byte & 127) << significanceInBit, significanceInBit += 7, _a.label = 3;
          case 3:
            if (haveMoreByte && significanceInBit < 28)
              return [3, 1];
            _a.label = 4;
          case 4:
            if (!haveMoreByte)
              return [3, 9];
            zigZagEncoded = zigZagEncoded, significanceInFloat = 268435456, _a.label = 5;
          case 5:
            return [4, AvroParser2.readByte(stream, options)];
          case 6:
            byte = _a.sent(), zigZagEncoded += (byte & 127) * significanceInFloat, significanceInFloat *= 128, _a.label = 7;
          case 7:
            if (byte & 128)
              return [3, 5];
            _a.label = 8;
          case 8:
            if (res = (zigZagEncoded % 2 ? -(zigZagEncoded + 1) : zigZagEncoded) / 2, res < Number.MIN_SAFE_INTEGER || res > Number.MAX_SAFE_INTEGER)
              throw new Error("Integer overflow.");
            return [2, res];
          case 9:
            return [2, zigZagEncoded >> 1 ^ -(zigZagEncoded & 1)];
        }
      });
    });
  }, AvroParser2.readLong = function(stream, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        return [2, AvroParser2.readZigZagLong(stream, options)];
      });
    });
  }, AvroParser2.readInt = function(stream, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        return [2, AvroParser2.readZigZagLong(stream, options)];
      });
    });
  }, AvroParser2.readNull = function() {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        return [2, null];
      });
    });
  }, AvroParser2.readBoolean = function(stream, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var b;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, AvroParser2.readByte(stream, options)];
          case 1:
            if (b = _a.sent(), b == 1)
              return [2, !0];
            if (b == 0)
              return [2, !1];
            throw new Error("Byte was not a boolean.");
            return [2];
        }
      });
    });
  }, AvroParser2.readFloat = function(stream, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var u8arr, view;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, AvroParser2.readFixedBytes(stream, 4, options)];
          case 1:
            return u8arr = _a.sent(), view = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength), [2, view.getFloat32(0, !0)];
        }
      });
    });
  }, AvroParser2.readDouble = function(stream, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var u8arr, view;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, AvroParser2.readFixedBytes(stream, 8, options)];
          case 1:
            return u8arr = _a.sent(), view = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength), [2, view.getFloat64(0, !0)];
        }
      });
    });
  }, AvroParser2.readBytes = function(stream, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var size;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, AvroParser2.readLong(stream, options)];
          case 1:
            if (size = _a.sent(), size < 0)
              throw new Error("Bytes size was negative.");
            return [4, stream.read(size, {abortSignal: options.abortSignal})];
          case 2:
            return [2, _a.sent()];
        }
      });
    });
  }, AvroParser2.readString = function(stream, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var u8arr, utf8decoder;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, AvroParser2.readBytes(stream, options)];
          case 1:
            return u8arr = _a.sent(), typeof TextDecoder == "undefined" && !0 && (global.TextDecoder = require("util").TextDecoder), utf8decoder = new TextDecoder(), [2, utf8decoder.decode(u8arr)];
        }
      });
    });
  }, AvroParser2.readMapPair = function(stream, readItemMethod, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var key, value;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, AvroParser2.readString(stream, options)];
          case 1:
            return key = _a.sent(), [4, readItemMethod(stream, options)];
          case 2:
            return value = _a.sent(), [2, {key, value}];
        }
      });
    });
  }, AvroParser2.readMap = function(stream, readItemMethod, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var readPairMethod, pairs, dict, _i, pairs_1, pair, _this = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return readPairMethod = /* @__PURE__ */ __name(function(stream2, options2) {
              return options2 === void 0 && (options2 = {}), __awaiter(_this, void 0, void 0, function() {
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      return [4, AvroParser2.readMapPair(stream2, readItemMethod, options2)];
                    case 1:
                      return [2, _a2.sent()];
                  }
                });
              });
            }, "readPairMethod"), [4, AvroParser2.readArray(stream, readPairMethod, options)];
          case 1:
            for (pairs = _a.sent(), dict = {}, _i = 0, pairs_1 = pairs; _i < pairs_1.length; _i++)
              pair = pairs_1[_i], dict[pair.key] = pair.value;
            return [2, dict];
        }
      });
    });
  }, AvroParser2.readArray = function(stream, readItemMethod, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var items, count, item;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return items = [], [4, AvroParser2.readLong(stream, options)];
          case 1:
            count = _a.sent(), _a.label = 2;
          case 2:
            return count == 0 ? [3, 8] : count < 0 ? [4, AvroParser2.readLong(stream, options)] : [3, 4];
          case 3:
            _a.sent(), count = -count, _a.label = 4;
          case 4:
            return count-- ? [4, readItemMethod(stream, options)] : [3, 6];
          case 5:
            return item = _a.sent(), items.push(item), [3, 4];
          case 6:
            return [4, AvroParser2.readLong(stream, options)];
          case 7:
            return count = _a.sent(), [3, 2];
          case 8:
            return [2, items];
        }
      });
    });
  }, AvroParser2;
}();
var AvroComplex;
(function(AvroComplex2) {
  AvroComplex2.RECORD = "record", AvroComplex2.ENUM = "enum", AvroComplex2.ARRAY = "array", AvroComplex2.MAP = "map", AvroComplex2.UNION = "union", AvroComplex2.FIXED = "fixed";
})(AvroComplex || (AvroComplex = {}));
var AvroType = function() {
  function AvroType2() {
  }
  return __name(AvroType2, "AvroType"), AvroType2.fromSchema = function(schema) {
    return typeof schema == "string" ? AvroType2.fromStringSchema(schema) : Array.isArray(schema) ? AvroType2.fromArraySchema(schema) : AvroType2.fromObjectSchema(schema);
  }, AvroType2.fromStringSchema = function(schema) {
    switch (schema) {
      case AvroPrimitive.NULL:
      case AvroPrimitive.BOOLEAN:
      case AvroPrimitive.INT:
      case AvroPrimitive.LONG:
      case AvroPrimitive.FLOAT:
      case AvroPrimitive.DOUBLE:
      case AvroPrimitive.BYTES:
      case AvroPrimitive.STRING:
        return new AvroPrimitiveType(schema);
      default:
        throw new Error("Unexpected Avro type " + schema);
    }
  }, AvroType2.fromArraySchema = function(schema) {
    return new AvroUnionType(schema.map(AvroType2.fromSchema));
  }, AvroType2.fromObjectSchema = function(schema) {
    var type3 = schema.type;
    try {
      return AvroType2.fromStringSchema(type3);
    } catch (err) {
    }
    switch (type3) {
      case AvroComplex.RECORD:
        if (schema.aliases)
          throw new Error("aliases currently is not supported, schema: " + schema);
        if (!schema.name)
          throw new Error("Required attribute 'name' doesn't exist on schema: " + schema);
        var fields = {};
        if (!schema.fields)
          throw new Error("Required attribute 'fields' doesn't exist on schema: " + schema);
        for (var _i = 0, _a = schema.fields; _i < _a.length; _i++) {
          var field = _a[_i];
          fields[field.name] = AvroType2.fromSchema(field.type);
        }
        return new AvroRecordType(fields, schema.name);
      case AvroComplex.ENUM:
        if (schema.aliases)
          throw new Error("aliases currently is not supported, schema: " + schema);
        if (!schema.symbols)
          throw new Error("Required attribute 'symbols' doesn't exist on schema: " + schema);
        return new AvroEnumType(schema.symbols);
      case AvroComplex.MAP:
        if (!schema.values)
          throw new Error("Required attribute 'values' doesn't exist on schema: " + schema);
        return new AvroMapType(AvroType2.fromSchema(schema.values));
      case AvroComplex.ARRAY:
      case AvroComplex.FIXED:
      default:
        throw new Error("Unexpected Avro type " + type3 + " in " + schema);
    }
  }, AvroType2;
}();
var AvroPrimitive;
(function(AvroPrimitive2) {
  AvroPrimitive2.NULL = "null", AvroPrimitive2.BOOLEAN = "boolean", AvroPrimitive2.INT = "int", AvroPrimitive2.LONG = "long", AvroPrimitive2.FLOAT = "float", AvroPrimitive2.DOUBLE = "double", AvroPrimitive2.BYTES = "bytes", AvroPrimitive2.STRING = "string";
})(AvroPrimitive || (AvroPrimitive = {}));
var AvroPrimitiveType = function(_super) {
  __extends(AvroPrimitiveType2, _super);
  function AvroPrimitiveType2(primitive) {
    var _this = _super.call(this) || this;
    return _this._primitive = primitive, _this;
  }
  return __name(AvroPrimitiveType2, "AvroPrimitiveType"), AvroPrimitiveType2.prototype.read = function(stream, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            switch (_a = this._primitive, _a) {
              case AvroPrimitive.NULL:
                return [3, 1];
              case AvroPrimitive.BOOLEAN:
                return [3, 3];
              case AvroPrimitive.INT:
                return [3, 5];
              case AvroPrimitive.LONG:
                return [3, 7];
              case AvroPrimitive.FLOAT:
                return [3, 9];
              case AvroPrimitive.DOUBLE:
                return [3, 11];
              case AvroPrimitive.BYTES:
                return [3, 13];
              case AvroPrimitive.STRING:
                return [3, 15];
            }
            return [3, 17];
          case 1:
            return [4, AvroParser.readNull()];
          case 2:
            return [2, _b.sent()];
          case 3:
            return [4, AvroParser.readBoolean(stream, options)];
          case 4:
            return [2, _b.sent()];
          case 5:
            return [4, AvroParser.readInt(stream, options)];
          case 6:
            return [2, _b.sent()];
          case 7:
            return [4, AvroParser.readLong(stream, options)];
          case 8:
            return [2, _b.sent()];
          case 9:
            return [4, AvroParser.readFloat(stream, options)];
          case 10:
            return [2, _b.sent()];
          case 11:
            return [4, AvroParser.readDouble(stream, options)];
          case 12:
            return [2, _b.sent()];
          case 13:
            return [4, AvroParser.readBytes(stream, options)];
          case 14:
            return [2, _b.sent()];
          case 15:
            return [4, AvroParser.readString(stream, options)];
          case 16:
            return [2, _b.sent()];
          case 17:
            throw new Error("Unknown Avro Primitive");
        }
      });
    });
  }, AvroPrimitiveType2;
}(AvroType), AvroEnumType = function(_super) {
  __extends(AvroEnumType2, _super);
  function AvroEnumType2(symbols) {
    var _this = _super.call(this) || this;
    return _this._symbols = symbols, _this;
  }
  return __name(AvroEnumType2, "AvroEnumType"), AvroEnumType2.prototype.read = function(stream, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var value;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, AvroParser.readInt(stream, options)];
          case 1:
            return value = _a.sent(), [2, this._symbols[value]];
        }
      });
    });
  }, AvroEnumType2;
}(AvroType), AvroUnionType = function(_super) {
  __extends(AvroUnionType2, _super);
  function AvroUnionType2(types) {
    var _this = _super.call(this) || this;
    return _this._types = types, _this;
  }
  return __name(AvroUnionType2, "AvroUnionType"), AvroUnionType2.prototype.read = function(stream, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var typeIndex;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, AvroParser.readInt(stream, options)];
          case 1:
            return typeIndex = _a.sent(), [4, this._types[typeIndex].read(stream, options)];
          case 2:
            return [2, _a.sent()];
        }
      });
    });
  }, AvroUnionType2;
}(AvroType), AvroMapType = function(_super) {
  __extends(AvroMapType2, _super);
  function AvroMapType2(itemType) {
    var _this = _super.call(this) || this;
    return _this._itemType = itemType, _this;
  }
  return __name(AvroMapType2, "AvroMapType"), AvroMapType2.prototype.read = function(stream, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var readItemMethod, _this = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return readItemMethod = /* @__PURE__ */ __name(function(s, options2) {
              return __awaiter(_this, void 0, void 0, function() {
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      return [4, this._itemType.read(s, options2)];
                    case 1:
                      return [2, _a2.sent()];
                  }
                });
              });
            }, "readItemMethod"), [4, AvroParser.readMap(stream, readItemMethod, options)];
          case 1:
            return [2, _a.sent()];
        }
      });
    });
  }, AvroMapType2;
}(AvroType), AvroRecordType = function(_super) {
  __extends(AvroRecordType2, _super);
  function AvroRecordType2(fields, name) {
    var _this = _super.call(this) || this;
    return _this._fields = fields, _this._name = name, _this;
  }
  return __name(AvroRecordType2, "AvroRecordType"), AvroRecordType2.prototype.read = function(stream, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var record, _a, _b, _i, key, _c, _d;
      return __generator(this, function(_e) {
        switch (_e.label) {
          case 0:
            record = {}, record.$schema = this._name, _a = [];
            for (_b in this._fields)
              _a.push(_b);
            _i = 0, _e.label = 1;
          case 1:
            return _i < _a.length ? (key = _a[_i], this._fields.hasOwnProperty(key) ? (_c = record, _d = key, [4, this._fields[key].read(stream, options)]) : [3, 3]) : [3, 4];
          case 2:
            _c[_d] = _e.sent(), _e.label = 3;
          case 3:
            return _i++, [3, 1];
          case 4:
            return [2, record];
        }
      });
    });
  }, AvroRecordType2;
}(AvroType);

// ../node_modules/@azure/core-asynciterator-polyfill/dist-esm/index.js
"use strict";
(typeof Symbol === void 0 || !Symbol.asyncIterator) && (Symbol.asyncIterator = Symbol.for("Symbol.asyncIterator"));

// ../node_modules/@azure/storage-blob/dist-esm/storage-internal-avro/src/AvroReader.js
var AvroReader = function() {
  function AvroReader2(dataStream, headerStream, currentBlockOffset, indexWithinCurrentBlock) {
    this._dataStream = dataStream, this._headerStream = headerStream || dataStream, this._initialized = !1, this._blockOffset = currentBlockOffset || 0, this._objectIndex = indexWithinCurrentBlock || 0, this._initialBlockOffset = currentBlockOffset || 0;
  }
  return __name(AvroReader2, "AvroReader"), Object.defineProperty(AvroReader2.prototype, "blockOffset", {
    get: function() {
      return this._blockOffset;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(AvroReader2.prototype, "objectIndex", {
    get: function() {
      return this._objectIndex;
    },
    enumerable: !1,
    configurable: !0
  }), AvroReader2.prototype.initialize = function(options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var header, _a, codec, _b, schema, _c, i;
      return __generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            return [4, AvroParser.readFixedBytes(this._headerStream, AVRO_INIT_BYTES.length, {
              abortSignal: options.abortSignal
            })];
          case 1:
            if (header = _d.sent(), !arraysEqual(header, AVRO_INIT_BYTES))
              throw new Error("Stream is not an Avro file.");
            return _a = this, [4, AvroParser.readMap(this._headerStream, AvroParser.readString, {
              abortSignal: options.abortSignal
            })];
          case 2:
            if (_a._metadata = _d.sent(), codec = this._metadata[AVRO_CODEC_KEY], !(codec == null || codec == "null"))
              throw new Error("Codecs are not supported");
            return _b = this, [4, AvroParser.readFixedBytes(this._headerStream, AVRO_SYNC_MARKER_SIZE, {
              abortSignal: options.abortSignal
            })];
          case 3:
            return _b._syncMarker = _d.sent(), schema = JSON.parse(this._metadata[AVRO_SCHEMA_KEY]), this._itemType = AvroType.fromSchema(schema), this._blockOffset == 0 && (this._blockOffset = this._initialBlockOffset + this._dataStream.position), _c = this, [4, AvroParser.readLong(this._dataStream, {
              abortSignal: options.abortSignal
            })];
          case 4:
            return _c._itemsRemainingInBlock = _d.sent(), [4, AvroParser.readLong(this._dataStream, {abortSignal: options.abortSignal})];
          case 5:
            if (_d.sent(), this._initialized = !0, !(this._objectIndex && this._objectIndex > 0))
              return [3, 9];
            i = 0, _d.label = 6;
          case 6:
            return i < this._objectIndex ? [4, this._itemType.read(this._dataStream, {abortSignal: options.abortSignal})] : [3, 9];
          case 7:
            _d.sent(), this._itemsRemainingInBlock--, _d.label = 8;
          case 8:
            return i++, [3, 6];
          case 9:
            return [2];
        }
      });
    });
  }, AvroReader2.prototype.hasNext = function() {
    return !this._initialized || this._itemsRemainingInBlock > 0;
  }, AvroReader2.prototype.parseObjects = function(options) {
    return options === void 0 && (options = {}), __asyncGenerator(this, arguments, /* @__PURE__ */ __name(function() {
      var result, marker, _a, err_1;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            return this._initialized ? [3, 2] : [4, __await(this.initialize(options))];
          case 1:
            _b.sent(), _b.label = 2;
          case 2:
            return this.hasNext() ? [4, __await(this._itemType.read(this._dataStream, {
              abortSignal: options.abortSignal
            }))] : [3, 13];
          case 3:
            return result = _b.sent(), this._itemsRemainingInBlock--, this._objectIndex++, this._itemsRemainingInBlock != 0 ? [3, 10] : [4, __await(AvroParser.readFixedBytes(this._dataStream, AVRO_SYNC_MARKER_SIZE, {
              abortSignal: options.abortSignal
            }))];
          case 4:
            if (marker = _b.sent(), this._blockOffset = this._initialBlockOffset + this._dataStream.position, this._objectIndex = 0, !arraysEqual(this._syncMarker, marker))
              throw new Error("Stream is not a valid Avro file.");
            _b.label = 5;
          case 5:
            return _b.trys.push([5, 7, , 8]), _a = this, [4, __await(AvroParser.readLong(this._dataStream, {
              abortSignal: options.abortSignal
            }))];
          case 6:
            return _a._itemsRemainingInBlock = _b.sent(), [3, 8];
          case 7:
            return err_1 = _b.sent(), this._itemsRemainingInBlock = 0, [3, 8];
          case 8:
            return this._itemsRemainingInBlock > 0 ? [4, __await(AvroParser.readLong(this._dataStream, {abortSignal: options.abortSignal}))] : [3, 10];
          case 9:
            _b.sent(), _b.label = 10;
          case 10:
            return [4, __await(result)];
          case 11:
            return [4, _b.sent()];
          case 12:
            return _b.sent(), [3, 2];
          case 13:
            return [2];
        }
      });
    }, "parseObjects_1"));
  }, AvroReader2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-internal-avro/src/AvroReadable.js
var AvroReadable = function() {
  function AvroReadable2() {
  }
  return __name(AvroReadable2, "AvroReadable"), AvroReadable2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-internal-avro/src/AvroReadableFromStream.js
var ABORT_ERROR2 = new AbortError2("Reading from the avro stream was aborted."), AvroReadableFromStream = function(_super) {
  __extends(AvroReadableFromStream2, _super);
  function AvroReadableFromStream2(readable) {
    var _this = _super.call(this) || this;
    return _this._readable = readable, _this._position = 0, _this;
  }
  return __name(AvroReadableFromStream2, "AvroReadableFromStream"), AvroReadableFromStream2.prototype.toUint8Array = function(data) {
    return typeof data == "string" ? Buffer.from(data) : data;
  }, Object.defineProperty(AvroReadableFromStream2.prototype, "position", {
    get: function() {
      return this._position;
    },
    enumerable: !1,
    configurable: !0
  }), AvroReadableFromStream2.prototype.read = function(size, options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var chunk, _this = this;
      return __generator(this, function(_b) {
        if ((_a = options.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted)
          throw ABORT_ERROR2;
        if (size < 0)
          throw new Error("size parameter should be positive: " + size);
        if (size === 0)
          return [2, new Uint8Array()];
        if (!this._readable.readable)
          throw new Error("Stream no longer readable.");
        if (chunk = this._readable.read(size), chunk)
          return this._position += chunk.length, [2, this.toUint8Array(chunk)];
        return [2, new Promise(function(resolve, reject) {
          var cleanUp = /* @__PURE__ */ __name(function() {
            _this._readable.removeListener("readable", readableCallback), _this._readable.removeListener("error", rejectCallback), _this._readable.removeListener("end", rejectCallback), _this._readable.removeListener("close", rejectCallback), options.abortSignal && options.abortSignal.removeEventListener("abort", abortHandler);
          }, "cleanUp"), readableCallback = /* @__PURE__ */ __name(function() {
            var chunk2 = _this._readable.read(size);
            chunk2 && (_this._position += chunk2.length, cleanUp(), resolve(_this.toUint8Array(chunk2)));
          }, "readableCallback"), rejectCallback = /* @__PURE__ */ __name(function() {
            cleanUp(), reject();
          }, "rejectCallback"), abortHandler = /* @__PURE__ */ __name(function() {
            cleanUp(), reject(ABORT_ERROR2);
          }, "abortHandler");
          _this._readable.on("readable", readableCallback), _this._readable.once("error", rejectCallback), _this._readable.once("end", rejectCallback), _this._readable.once("close", rejectCallback), options.abortSignal && options.abortSignal.addEventListener("abort", abortHandler);
        })];
        return [2];
      });
    });
  }, AvroReadableFromStream2;
}(AvroReadable);

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/utils/BlobQuickQueryStream.js
var BlobQuickQueryStream = function(_super) {
  __extends(BlobQuickQueryStream2, _super);
  function BlobQuickQueryStream2(source, options) {
    options === void 0 && (options = {});
    var _this = _super.call(this) || this;
    return _this.avroPaused = !0, _this.source = source, _this.onProgress = options.onProgress, _this.onError = options.onError, _this.avroReader = new AvroReader(new AvroReadableFromStream(_this.source)), _this.avroIter = _this.avroReader.parseObjects({abortSignal: options.abortSignal}), _this;
  }
  return __name(BlobQuickQueryStream2, "BlobQuickQueryStream"), BlobQuickQueryStream2.prototype._read = function() {
    var _this = this;
    this.avroPaused && this.readInternal().catch(function(err) {
      _this.emit("error", err);
    });
  }, BlobQuickQueryStream2.prototype.readInternal = function() {
    return __awaiter(this, void 0, void 0, function() {
      var avroNext, obj, schema, data, bytesScanned, totalBytes, fatal, name_1, description, position;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            this.avroPaused = !1, _a.label = 1;
          case 1:
            return [4, this.avroIter.next()];
          case 2:
            if (avroNext = _a.sent(), avroNext.done)
              return [3, 4];
            if (obj = avroNext.value, schema = obj.$schema, typeof schema != "string")
              throw Error("Missing schema in avro record.");
            switch (schema) {
              case "com.microsoft.azure.storage.queryBlobContents.resultData":
                if (data = obj.data, !(data instanceof Uint8Array))
                  throw Error("Invalid data in avro result record.");
                this.push(Buffer.from(data)) || (this.avroPaused = !0);
                break;
              case "com.microsoft.azure.storage.queryBlobContents.progress":
                if (bytesScanned = obj.bytesScanned, typeof bytesScanned != "number")
                  throw Error("Invalid bytesScanned in avro progress record.");
                this.onProgress && this.onProgress({loadedBytes: bytesScanned});
                break;
              case "com.microsoft.azure.storage.queryBlobContents.end":
                if (this.onProgress) {
                  if (totalBytes = obj.totalBytes, typeof totalBytes != "number")
                    throw Error("Invalid totalBytes in avro end record.");
                  this.onProgress({loadedBytes: totalBytes});
                }
                this.push(null);
                break;
              case "com.microsoft.azure.storage.queryBlobContents.error":
                if (this.onError) {
                  if (fatal = obj.fatal, typeof fatal != "boolean")
                    throw Error("Invalid fatal in avro error record.");
                  if (name_1 = obj.name, typeof name_1 != "string")
                    throw Error("Invalid name in avro error record.");
                  if (description = obj.description, typeof description != "string")
                    throw Error("Invalid description in avro error record.");
                  if (position = obj.position, typeof position != "number")
                    throw Error("Invalid position in avro error record.");
                  this.onError({
                    position,
                    name: name_1,
                    isFatal: fatal,
                    description
                  });
                }
                break;
              default:
                throw Error("Unknown schema " + schema + " in avro progress record.");
            }
            _a.label = 3;
          case 3:
            if (!avroNext.done && !this.avroPaused)
              return [3, 1];
            _a.label = 4;
          case 4:
            return [2];
        }
      });
    });
  }, BlobQuickQueryStream2;
}(import_stream4.Readable);

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/BlobQueryResponse.js
var BlobQueryResponse = function() {
  function BlobQueryResponse2(originalResponse, options) {
    options === void 0 && (options = {}), this.originalResponse = originalResponse, this.blobDownloadStream = new BlobQuickQueryStream(this.originalResponse.readableStreamBody, options);
  }
  return __name(BlobQueryResponse2, "BlobQueryResponse"), Object.defineProperty(BlobQueryResponse2.prototype, "acceptRanges", {
    get: function() {
      return this.originalResponse.acceptRanges;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "cacheControl", {
    get: function() {
      return this.originalResponse.cacheControl;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "contentDisposition", {
    get: function() {
      return this.originalResponse.contentDisposition;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "contentEncoding", {
    get: function() {
      return this.originalResponse.contentEncoding;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "contentLanguage", {
    get: function() {
      return this.originalResponse.contentLanguage;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "blobSequenceNumber", {
    get: function() {
      return this.originalResponse.blobSequenceNumber;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "blobType", {
    get: function() {
      return this.originalResponse.blobType;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "contentLength", {
    get: function() {
      return this.originalResponse.contentLength;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "contentMD5", {
    get: function() {
      return this.originalResponse.contentMD5;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "contentRange", {
    get: function() {
      return this.originalResponse.contentRange;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "contentType", {
    get: function() {
      return this.originalResponse.contentType;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "copyCompletedOn", {
    get: function() {
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "copyId", {
    get: function() {
      return this.originalResponse.copyId;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "copyProgress", {
    get: function() {
      return this.originalResponse.copyProgress;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "copySource", {
    get: function() {
      return this.originalResponse.copySource;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "copyStatus", {
    get: function() {
      return this.originalResponse.copyStatus;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "copyStatusDescription", {
    get: function() {
      return this.originalResponse.copyStatusDescription;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "leaseDuration", {
    get: function() {
      return this.originalResponse.leaseDuration;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "leaseState", {
    get: function() {
      return this.originalResponse.leaseState;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "leaseStatus", {
    get: function() {
      return this.originalResponse.leaseStatus;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "date", {
    get: function() {
      return this.originalResponse.date;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "blobCommittedBlockCount", {
    get: function() {
      return this.originalResponse.blobCommittedBlockCount;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "etag", {
    get: function() {
      return this.originalResponse.etag;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "errorCode", {
    get: function() {
      return this.originalResponse.errorCode;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "isServerEncrypted", {
    get: function() {
      return this.originalResponse.isServerEncrypted;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "blobContentMD5", {
    get: function() {
      return this.originalResponse.blobContentMD5;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "lastModified", {
    get: function() {
      return this.originalResponse.lastModified;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "metadata", {
    get: function() {
      return this.originalResponse.metadata;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "requestId", {
    get: function() {
      return this.originalResponse.requestId;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "clientRequestId", {
    get: function() {
      return this.originalResponse.clientRequestId;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "version", {
    get: function() {
      return this.originalResponse.version;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "encryptionKeySha256", {
    get: function() {
      return this.originalResponse.encryptionKeySha256;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "contentCrc64", {
    get: function() {
      return this.originalResponse.contentCrc64;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "blobBody", {
    get: function() {
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "readableStreamBody", {
    get: function() {
      return isNode ? this.blobDownloadStream : void 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobQueryResponse2.prototype, "_response", {
    get: function() {
      return this.originalResponse._response;
    },
    enumerable: !1,
    configurable: !0
  }), BlobQueryResponse2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/credentials/StorageSharedKeyCredential.js
var import_crypto2 = __toModule(require("crypto"));

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/policies/StorageSharedKeyCredentialPolicy.js
var StorageSharedKeyCredentialPolicy = function(_super) {
  __extends(StorageSharedKeyCredentialPolicy2, _super);
  function StorageSharedKeyCredentialPolicy2(nextPolicy, options, factory) {
    var _this = _super.call(this, nextPolicy, options) || this;
    return _this.factory = factory, _this;
  }
  return __name(StorageSharedKeyCredentialPolicy2, "StorageSharedKeyCredentialPolicy"), StorageSharedKeyCredentialPolicy2.prototype.signRequest = function(request) {
    request.headers.set(HeaderConstants.X_MS_DATE, new Date().toUTCString()), request.body && typeof request.body == "string" && request.body.length > 0 && request.headers.set(HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
    var stringToSign = [
      request.method.toUpperCase(),
      this.getHeaderValueToSign(request, HeaderConstants.CONTENT_LANGUAGE),
      this.getHeaderValueToSign(request, HeaderConstants.CONTENT_ENCODING),
      this.getHeaderValueToSign(request, HeaderConstants.CONTENT_LENGTH),
      this.getHeaderValueToSign(request, HeaderConstants.CONTENT_MD5),
      this.getHeaderValueToSign(request, HeaderConstants.CONTENT_TYPE),
      this.getHeaderValueToSign(request, HeaderConstants.DATE),
      this.getHeaderValueToSign(request, HeaderConstants.IF_MODIFIED_SINCE),
      this.getHeaderValueToSign(request, HeaderConstants.IF_MATCH),
      this.getHeaderValueToSign(request, HeaderConstants.IF_NONE_MATCH),
      this.getHeaderValueToSign(request, HeaderConstants.IF_UNMODIFIED_SINCE),
      this.getHeaderValueToSign(request, HeaderConstants.RANGE)
    ].join(`
`) + `
` + this.getCanonicalizedHeadersString(request) + this.getCanonicalizedResourceString(request), signature = this.factory.computeHMACSHA256(stringToSign);
    return request.headers.set(HeaderConstants.AUTHORIZATION, "SharedKey " + this.factory.accountName + ":" + signature), request;
  }, StorageSharedKeyCredentialPolicy2.prototype.getHeaderValueToSign = function(request, headerName) {
    var value = request.headers.get(headerName);
    return !value || headerName === HeaderConstants.CONTENT_LENGTH && value === "0" ? "" : value;
  }, StorageSharedKeyCredentialPolicy2.prototype.getCanonicalizedHeadersString = function(request) {
    var headersArray = request.headers.headersArray().filter(function(value) {
      return value.name.toLowerCase().startsWith(HeaderConstants.PREFIX_FOR_STORAGE);
    });
    headersArray.sort(function(a, b) {
      return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
    }), headersArray = headersArray.filter(function(value, index, array) {
      return !(index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase());
    });
    var canonicalizedHeadersStringToSign = "";
    return headersArray.forEach(function(header) {
      canonicalizedHeadersStringToSign += header.name.toLowerCase().trimRight() + ":" + header.value.trimLeft() + `
`;
    }), canonicalizedHeadersStringToSign;
  }, StorageSharedKeyCredentialPolicy2.prototype.getCanonicalizedResourceString = function(request) {
    var path3 = getURLPath(request.url) || "/", canonicalizedResourceString = "";
    canonicalizedResourceString += "/" + this.factory.accountName + path3;
    var queries = getURLQueries(request.url), lowercaseQueries = {};
    if (queries) {
      var queryKeys = [];
      for (var key in queries)
        if (queries.hasOwnProperty(key)) {
          var lowercaseKey = key.toLowerCase();
          lowercaseQueries[lowercaseKey] = queries[key], queryKeys.push(lowercaseKey);
        }
      queryKeys.sort();
      for (var _i = 0, queryKeys_1 = queryKeys; _i < queryKeys_1.length; _i++) {
        var key = queryKeys_1[_i];
        canonicalizedResourceString += `
` + key + ":" + decodeURIComponent(lowercaseQueries[key]);
      }
    }
    return canonicalizedResourceString;
  }, StorageSharedKeyCredentialPolicy2;
}(CredentialPolicy);

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/credentials/StorageSharedKeyCredential.js
var StorageSharedKeyCredential = function(_super) {
  __extends(StorageSharedKeyCredential2, _super);
  function StorageSharedKeyCredential2(accountName, accountKey) {
    var _this = _super.call(this) || this;
    return _this.accountName = accountName, _this.accountKey = Buffer.from(accountKey, "base64"), _this;
  }
  return __name(StorageSharedKeyCredential2, "StorageSharedKeyCredential"), StorageSharedKeyCredential2.prototype.create = function(nextPolicy, options) {
    return new StorageSharedKeyCredentialPolicy(nextPolicy, options, this);
  }, StorageSharedKeyCredential2.prototype.computeHMACSHA256 = function(stringToSign) {
    return import_crypto2.createHmac("sha256", this.accountKey).update(stringToSign, "utf8").digest("base64");
  }, StorageSharedKeyCredential2;
}(Credential);

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/generated/src/storageClientContext.js
var packageName = "azure-storage-blob", packageVersion = "12.4.0", StorageClientContext = function(_super) {
  __extends(StorageClientContext2, _super);
  function StorageClientContext2(url2, options) {
    var _this = this;
    if (url2 == null)
      throw new Error("'url' cannot be null.");
    if (options || (options = {}), !options.userAgent) {
      var defaultUserAgent = getDefaultUserAgentValue();
      options.userAgent = packageName + "/" + packageVersion + " " + defaultUserAgent;
    }
    return _this = _super.call(this, void 0, options) || this, _this.version = "2020-04-08", _this.baseUri = "{url}", _this.requestContentType = "application/json; charset=utf-8", _this.url = url2, _this;
  }
  return __name(StorageClientContext2, "StorageClientContext"), StorageClientContext2;
}(ServiceClient);

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/models.js
var BlockBlobTier;
(function(BlockBlobTier2) {
  BlockBlobTier2.Hot = "Hot", BlockBlobTier2.Cool = "Cool", BlockBlobTier2.Archive = "Archive";
})(BlockBlobTier || (BlockBlobTier = {}));
var PremiumPageBlobTier;
(function(PremiumPageBlobTier2) {
  PremiumPageBlobTier2.P4 = "P4", PremiumPageBlobTier2.P6 = "P6", PremiumPageBlobTier2.P10 = "P10", PremiumPageBlobTier2.P15 = "P15", PremiumPageBlobTier2.P20 = "P20", PremiumPageBlobTier2.P30 = "P30", PremiumPageBlobTier2.P40 = "P40", PremiumPageBlobTier2.P50 = "P50", PremiumPageBlobTier2.P60 = "P60", PremiumPageBlobTier2.P70 = "P70", PremiumPageBlobTier2.P80 = "P80";
})(PremiumPageBlobTier || (PremiumPageBlobTier = {}));
function toAccessTier(tier) {
  if (tier != null)
    return tier;
}
__name(toAccessTier, "toAccessTier");
function ensureCpkIfSpecified(cpk, isHttps) {
  if (cpk && !isHttps)
    throw new RangeError("Customer-provided encryption key must be used over HTTPS.");
  cpk && !cpk.encryptionAlgorithm && (cpk.encryptionAlgorithm = EncryptionAlgorithmAES25);
}
__name(ensureCpkIfSpecified, "ensureCpkIfSpecified");

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/PageBlobRangeResponse.js
function rangeResponseFromModel(response) {
  var pageRange = (response._response.parsedBody.pageRange || []).map(function(x) {
    return {
      offset: x.start,
      count: x.end - x.start
    };
  }), clearRange = (response._response.parsedBody.clearRange || []).map(function(x) {
    return {
      offset: x.start,
      count: x.end - x.start
    };
  });
  return __assign(__assign({}, response), {
    pageRange,
    clearRange,
    _response: __assign(__assign({}, response._response), {parsedBody: {
      pageRange,
      clearRange
    }})
  });
}
__name(rangeResponseFromModel, "rangeResponseFromModel");

// ../node_modules/@azure/core-lro/dist-esm/src/poller.js
var PollerStoppedError = function(_super) {
  __extends(PollerStoppedError2, _super);
  function PollerStoppedError2(message) {
    var _this = _super.call(this, message) || this;
    return _this.name = "PollerStoppedError", Object.setPrototypeOf(_this, PollerStoppedError2.prototype), _this;
  }
  return __name(PollerStoppedError2, "PollerStoppedError"), PollerStoppedError2;
}(Error);
var PollerCancelledError = function(_super) {
  __extends(PollerCancelledError2, _super);
  function PollerCancelledError2(message) {
    var _this = _super.call(this, message) || this;
    return _this.name = "PollerCancelledError", Object.setPrototypeOf(_this, PollerCancelledError2.prototype), _this;
  }
  return __name(PollerCancelledError2, "PollerCancelledError"), PollerCancelledError2;
}(Error);
var Poller = function() {
  function Poller2(operation) {
    var _this = this;
    this.stopped = !0, this.pollProgressCallbacks = [], this.operation = operation, this.promise = new Promise(function(resolve, reject) {
      _this.resolve = resolve, _this.reject = reject;
    }), this.promise.catch(function() {
    });
  }
  return __name(Poller2, "Poller"), Poller2.prototype.startPolling = function() {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            this.stopped && (this.stopped = !1), _a.label = 1;
          case 1:
            return !this.isStopped() && !this.isDone() ? [4, this.poll()] : [3, 4];
          case 2:
            return _a.sent(), [4, this.delay()];
          case 3:
            return _a.sent(), [3, 1];
          case 4:
            return [2];
        }
      });
    });
  }, Poller2.prototype.pollOnce = function(options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var state, _a, e_1;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            state = this.operation.state, _b.label = 1;
          case 1:
            return _b.trys.push([1, 4, , 5]), this.isDone() ? [3, 3] : (_a = this, [4, this.operation.update({
              abortSignal: options.abortSignal,
              fireProgress: this.fireProgress.bind(this)
            })]);
          case 2:
            _a.operation = _b.sent(), this.isDone() && this.resolve && this.resolve(state.result), _b.label = 3;
          case 3:
            return [3, 5];
          case 4:
            throw e_1 = _b.sent(), state.error = e_1, this.reject && this.reject(e_1), e_1;
          case 5:
            return [2];
        }
      });
    });
  }, Poller2.prototype.fireProgress = function(state) {
    for (var _i = 0, _a = this.pollProgressCallbacks; _i < _a.length; _i++) {
      var callback = _a[_i];
      callback(state);
    }
  }, Poller2.prototype.cancelOnce = function(options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            return _a = this, [4, this.operation.cancel(options)];
          case 1:
            return _a.operation = _b.sent(), this.reject && this.reject(new PollerCancelledError("Poller cancelled")), [2];
        }
      });
    });
  }, Poller2.prototype.poll = function(options) {
    var _this = this;
    if (options === void 0 && (options = {}), !this.pollOncePromise) {
      this.pollOncePromise = this.pollOnce(options);
      var clearPollOncePromise = /* @__PURE__ */ __name(function() {
        _this.pollOncePromise = void 0;
      }, "clearPollOncePromise");
      this.pollOncePromise.then(clearPollOncePromise, clearPollOncePromise).catch(this.reject);
    }
    return this.pollOncePromise;
  }, Poller2.prototype.pollUntilDone = function() {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        return this.stopped && this.startPolling().catch(this.reject), [2, this.promise];
      });
    });
  }, Poller2.prototype.onProgress = function(callback) {
    var _this = this;
    return this.pollProgressCallbacks.push(callback), function() {
      _this.pollProgressCallbacks = _this.pollProgressCallbacks.filter(function(c) {
        return c !== callback;
      });
    };
  }, Poller2.prototype.isDone = function() {
    var state = this.operation.state;
    return Boolean(state.isCompleted || state.isCancelled || state.error);
  }, Poller2.prototype.stopPolling = function() {
    this.stopped || (this.stopped = !0, this.reject && this.reject(new PollerStoppedError("This poller is already stopped")));
  }, Poller2.prototype.isStopped = function() {
    return this.stopped;
  }, Poller2.prototype.cancelOperation = function(options) {
    if (options === void 0 && (options = {}), this.stopped || (this.stopped = !0), !this.cancelPromise)
      this.cancelPromise = this.cancelOnce(options);
    else if (options.abortSignal)
      throw new Error("A cancel request is currently pending");
    return this.cancelPromise;
  }, Poller2.prototype.getOperationState = function() {
    return this.operation.state;
  }, Poller2.prototype.getResult = function() {
    var state = this.operation.state;
    return state.result;
  }, Poller2.prototype.toString = function() {
    return this.operation.toString();
  }, Poller2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/pollers/BlobStartCopyFromUrlPoller.js
var BlobBeginCopyFromUrlPoller = function(_super) {
  __extends(BlobBeginCopyFromUrlPoller2, _super);
  function BlobBeginCopyFromUrlPoller2(options) {
    var _this = this, blobClient = options.blobClient, copySource2 = options.copySource, _a = options.intervalInMs, intervalInMs = _a === void 0 ? 15e3 : _a, onProgress = options.onProgress, resumeFrom = options.resumeFrom, startCopyFromURLOptions = options.startCopyFromURLOptions, state;
    resumeFrom && (state = JSON.parse(resumeFrom).state);
    var operation = makeBlobBeginCopyFromURLPollOperation(__assign(__assign({}, state), {
      blobClient,
      copySource: copySource2,
      startCopyFromURLOptions
    }));
    return _this = _super.call(this, operation) || this, typeof onProgress == "function" && _this.onProgress(onProgress), _this.intervalInMs = intervalInMs, _this;
  }
  return __name(BlobBeginCopyFromUrlPoller2, "BlobBeginCopyFromUrlPoller"), BlobBeginCopyFromUrlPoller2.prototype.delay = function() {
    return delay(this.intervalInMs);
  }, BlobBeginCopyFromUrlPoller2;
}(Poller);
var cancel = /* @__PURE__ */ __name(function(options) {
  return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
    var state, copyId2;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          return state = this.state, copyId2 = state.copyId, state.isCompleted ? [2, makeBlobBeginCopyFromURLPollOperation(state)] : copyId2 ? [4, state.blobClient.abortCopyFromURL(copyId2, {
            abortSignal: options.abortSignal
          })] : (state.isCancelled = !0, [2, makeBlobBeginCopyFromURLPollOperation(state)]);
        case 1:
          return _a.sent(), state.isCancelled = !0, [2, makeBlobBeginCopyFromURLPollOperation(state)];
      }
    });
  });
}, "cancel"), update = /* @__PURE__ */ __name(function(options) {
  return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
    var state, blobClient, copySource2, startCopyFromURLOptions, result, result, copyStatus, copyProgress, prevCopyProgress, err_1;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          return state = this.state, blobClient = state.blobClient, copySource2 = state.copySource, startCopyFromURLOptions = state.startCopyFromURLOptions, state.isStarted ? [3, 2] : (state.isStarted = !0, [4, blobClient.startCopyFromURL(copySource2, startCopyFromURLOptions)]);
        case 1:
          return result = _a.sent(), state.copyId = result.copyId, result.copyStatus === "success" && (state.result = result, state.isCompleted = !0), [3, 6];
        case 2:
          if (state.isCompleted)
            return [3, 6];
          _a.label = 3;
        case 3:
          return _a.trys.push([3, 5, , 6]), [4, state.blobClient.getProperties({abortSignal: options.abortSignal})];
        case 4:
          return result = _a.sent(), copyStatus = result.copyStatus, copyProgress = result.copyProgress, prevCopyProgress = state.copyProgress, copyProgress && (state.copyProgress = copyProgress), copyStatus === "pending" && copyProgress !== prevCopyProgress && typeof options.fireProgress == "function" ? options.fireProgress(state) : copyStatus === "success" ? (state.result = result, state.isCompleted = !0) : copyStatus === "failed" && (state.error = new Error('Blob copy failed with reason: "' + (result.copyStatusDescription || "unknown") + '"'), state.isCompleted = !0), [3, 6];
        case 5:
          return err_1 = _a.sent(), state.error = err_1, state.isCompleted = !0, [3, 6];
        case 6:
          return [2, makeBlobBeginCopyFromURLPollOperation(state)];
      }
    });
  });
}, "update"), toString = /* @__PURE__ */ __name(function() {
  return JSON.stringify({state: this.state}, function(key, value) {
    if (key !== "blobClient")
      return value;
  });
}, "toString");
function makeBlobBeginCopyFromURLPollOperation(state) {
  return {
    state: __assign({}, state),
    cancel,
    toString,
    update
  };
}
__name(makeBlobBeginCopyFromURLPollOperation, "makeBlobBeginCopyFromURLPollOperation");

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/Range.js
function rangeToString(iRange) {
  if (iRange.offset < 0)
    throw new RangeError("Range.offset cannot be smaller than 0.");
  if (iRange.count && iRange.count <= 0)
    throw new RangeError("Range.count must be larger than 0. Leave it undefined if you want a range from offset to the end.");
  return iRange.count ? "bytes=" + iRange.offset + "-" + (iRange.offset + iRange.count - 1) : "bytes=" + iRange.offset + "-";
}
__name(rangeToString, "rangeToString");

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/StorageClient.js
var StorageClient = function() {
  function StorageClient2(url2, pipeline) {
    this.url = escapeURLPath(url2), this.accountName = getAccountNameFromUrl(url2), this.pipeline = pipeline, this.storageClientContext = new StorageClientContext(this.url, pipeline.toServiceClientOptions()), this.isHttps = iEqual(getURLScheme(this.url) || "", "https"), this.credential = new AnonymousCredential();
    for (var _i = 0, _a = this.pipeline.factories; _i < _a.length; _i++) {
      var factory = _a[_i];
      isNode && factory instanceof StorageSharedKeyCredential || factory instanceof AnonymousCredential ? this.credential = factory : isTokenCredential(factory.credential) && (this.credential = factory.credential);
    }
    var storageClientContext = this.storageClientContext;
    storageClientContext.requestContentType = void 0;
  }
  return __name(StorageClient2, "StorageClient"), StorageClient2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/utils/Batch.js
var import_events = __toModule(require("events")), BatchStates;
(function(BatchStates2) {
  BatchStates2[BatchStates2.Good = 0] = "Good", BatchStates2[BatchStates2.Error = 1] = "Error";
})(BatchStates || (BatchStates = {}));
var Batch = function() {
  function Batch2(concurrency) {
    if (concurrency === void 0 && (concurrency = 5), this.actives = 0, this.completed = 0, this.offset = 0, this.operations = [], this.state = BatchStates.Good, concurrency < 1)
      throw new RangeError("concurrency must be larger than 0");
    this.concurrency = concurrency, this.emitter = new import_events.EventEmitter();
  }
  return __name(Batch2, "Batch"), Batch2.prototype.addOperation = function(operation) {
    var _this = this;
    this.operations.push(function() {
      return __awaiter(_this, void 0, void 0, function() {
        var error_1;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return _a.trys.push([0, 2, , 3]), this.actives++, [4, operation()];
            case 1:
              return _a.sent(), this.actives--, this.completed++, this.parallelExecute(), [3, 3];
            case 2:
              return error_1 = _a.sent(), this.emitter.emit("error", error_1), [3, 3];
            case 3:
              return [2];
          }
        });
      });
    });
  }, Batch2.prototype.do = function() {
    return __awaiter(this, void 0, void 0, function() {
      var _this = this;
      return __generator(this, function(_a) {
        return this.operations.length === 0 ? [2, Promise.resolve()] : (this.parallelExecute(), [2, new Promise(function(resolve, reject) {
          _this.emitter.on("finish", resolve), _this.emitter.on("error", function(error) {
            _this.state = BatchStates.Error, reject(error);
          });
        })]);
      });
    });
  }, Batch2.prototype.nextOperation = function() {
    return this.offset < this.operations.length ? this.operations[this.offset++] : null;
  }, Batch2.prototype.parallelExecute = function() {
    if (this.state !== BatchStates.Error) {
      if (this.completed >= this.operations.length) {
        this.emitter.emit("finish");
        return;
      }
      for (; this.actives < this.concurrency; ) {
        var operation = this.nextOperation();
        if (operation)
          operation();
        else
          return;
      }
    }
  }, Batch2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-common/src/BufferScheduler.js
var import_events2 = __toModule(require("events"));

// ../node_modules/@azure/storage-blob/dist-esm/storage-common/src/BuffersStream.js
var import_stream5 = __toModule(require("stream")), BuffersStream = function(_super) {
  __extends(BuffersStream2, _super);
  function BuffersStream2(buffers, byteLength, options) {
    var _this = _super.call(this, options) || this;
    _this.buffers = buffers, _this.byteLength = byteLength, _this.byteOffsetInCurrentBuffer = 0, _this.bufferIndex = 0, _this.pushedBytesLength = 0;
    for (var buffersLength = 0, _i = 0, _a = _this.buffers; _i < _a.length; _i++) {
      var buf = _a[_i];
      buffersLength += buf.byteLength;
    }
    if (buffersLength < _this.byteLength)
      throw new Error("Data size shouldn't be larger than the total length of buffers.");
    return _this;
  }
  return __name(BuffersStream2, "BuffersStream"), BuffersStream2.prototype._read = function(size) {
    this.pushedBytesLength >= this.byteLength && this.push(null), size || (size = this.readableHighWaterMark);
    for (var outBuffers = [], i = 0; i < size && this.pushedBytesLength < this.byteLength; ) {
      var remainingDataInAllBuffers = this.byteLength - this.pushedBytesLength, remainingCapacityInThisBuffer = this.buffers[this.bufferIndex].byteLength - this.byteOffsetInCurrentBuffer, remaining = Math.min(remainingCapacityInThisBuffer, remainingDataInAllBuffers);
      if (remaining > size - i) {
        var end = this.byteOffsetInCurrentBuffer + size - i;
        outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, end)), this.pushedBytesLength += size - i, this.byteOffsetInCurrentBuffer = end, i = size;
        break;
      } else {
        var end = this.byteOffsetInCurrentBuffer + remaining;
        outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, end)), remaining === remainingCapacityInThisBuffer ? (this.byteOffsetInCurrentBuffer = 0, this.bufferIndex++) : this.byteOffsetInCurrentBuffer = end, this.pushedBytesLength += remaining, i += remaining;
      }
    }
    outBuffers.length > 1 ? this.push(Buffer.concat(outBuffers)) : outBuffers.length === 1 && this.push(outBuffers[0]);
  }, BuffersStream2;
}(import_stream5.Readable);

// ../node_modules/@azure/storage-blob/dist-esm/storage-common/src/PooledBuffer.js
var maxBufferLength = require("buffer").constants.MAX_LENGTH, PooledBuffer = function() {
  function PooledBuffer2(capacity, buffers, totalLength) {
    this.buffers = [], this.capacity = capacity, this._size = 0;
    for (var bufferNum = Math.ceil(capacity / maxBufferLength), i = 0; i < bufferNum; i++) {
      var len = i === bufferNum - 1 ? capacity % maxBufferLength : maxBufferLength;
      len === 0 && (len = maxBufferLength), this.buffers.push(Buffer.allocUnsafe(len));
    }
    buffers && this.fill(buffers, totalLength);
  }
  return __name(PooledBuffer2, "PooledBuffer"), Object.defineProperty(PooledBuffer2.prototype, "size", {
    get: function() {
      return this._size;
    },
    enumerable: !1,
    configurable: !0
  }), PooledBuffer2.prototype.fill = function(buffers, totalLength) {
    this._size = Math.min(this.capacity, totalLength);
    for (var i = 0, j = 0, targetOffset = 0, sourceOffset = 0, totalCopiedNum = 0; totalCopiedNum < this._size; ) {
      var source = buffers[i], target = this.buffers[j], copiedNum = source.copy(target, targetOffset, sourceOffset);
      totalCopiedNum += copiedNum, sourceOffset += copiedNum, targetOffset += copiedNum, sourceOffset === source.length && (i++, sourceOffset = 0), targetOffset === target.length && (j++, targetOffset = 0);
    }
    buffers.splice(0, i), buffers.length > 0 && (buffers[0] = buffers[0].slice(sourceOffset));
  }, PooledBuffer2.prototype.getReadableStream = function() {
    return new BuffersStream(this.buffers, this.size);
  }, PooledBuffer2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-common/src/BufferScheduler.js
var BufferScheduler = function() {
  function BufferScheduler2(readable, bufferSize, maxBuffers, outgoingHandler, concurrency, encoding) {
    if (this.emitter = new import_events2.EventEmitter(), this.offset = 0, this.isStreamEnd = !1, this.isError = !1, this.executingOutgoingHandlers = 0, this.numBuffers = 0, this.unresolvedDataArray = [], this.unresolvedLength = 0, this.incoming = [], this.outgoing = [], bufferSize <= 0)
      throw new RangeError("bufferSize must be larger than 0, current is " + bufferSize);
    if (maxBuffers <= 0)
      throw new RangeError("maxBuffers must be larger than 0, current is " + maxBuffers);
    if (concurrency <= 0)
      throw new RangeError("concurrency must be larger than 0, current is " + concurrency);
    this.bufferSize = bufferSize, this.maxBuffers = maxBuffers, this.readable = readable, this.outgoingHandler = outgoingHandler, this.concurrency = concurrency, this.encoding = encoding;
  }
  return __name(BufferScheduler2, "BufferScheduler"), BufferScheduler2.prototype.do = function() {
    return __awaiter(this, void 0, void 0, function() {
      var _this = this;
      return __generator(this, function(_a) {
        return [2, new Promise(function(resolve, reject) {
          _this.readable.on("data", function(data) {
            data = typeof data == "string" ? Buffer.from(data, _this.encoding) : data, _this.appendUnresolvedData(data), _this.resolveData() || _this.readable.pause();
          }), _this.readable.on("error", function(err) {
            _this.emitter.emit("error", err);
          }), _this.readable.on("end", function() {
            _this.isStreamEnd = !0, _this.emitter.emit("checkEnd");
          }), _this.emitter.on("error", function(err) {
            _this.isError = !0, _this.readable.pause(), reject(err);
          }), _this.emitter.on("checkEnd", function() {
            if (_this.outgoing.length > 0) {
              _this.triggerOutgoingHandlers();
              return;
            }
            if (_this.isStreamEnd && _this.executingOutgoingHandlers === 0)
              if (_this.unresolvedLength > 0 && _this.unresolvedLength < _this.bufferSize) {
                var buffer_1 = _this.shiftBufferFromUnresolvedDataArray();
                _this.outgoingHandler(function() {
                  return buffer_1.getReadableStream();
                }, buffer_1.size, _this.offset).then(resolve).catch(reject);
              } else {
                if (_this.unresolvedLength >= _this.bufferSize)
                  return;
                resolve();
              }
          });
        })];
      });
    });
  }, BufferScheduler2.prototype.appendUnresolvedData = function(data) {
    this.unresolvedDataArray.push(data), this.unresolvedLength += data.length;
  }, BufferScheduler2.prototype.shiftBufferFromUnresolvedDataArray = function(buffer) {
    return buffer ? buffer.fill(this.unresolvedDataArray, this.unresolvedLength) : buffer = new PooledBuffer(this.bufferSize, this.unresolvedDataArray, this.unresolvedLength), this.unresolvedLength -= buffer.size, buffer;
  }, BufferScheduler2.prototype.resolveData = function() {
    for (; this.unresolvedLength >= this.bufferSize; ) {
      var buffer = void 0;
      if (this.incoming.length > 0)
        buffer = this.incoming.shift(), this.shiftBufferFromUnresolvedDataArray(buffer);
      else if (this.numBuffers < this.maxBuffers)
        buffer = this.shiftBufferFromUnresolvedDataArray(), this.numBuffers++;
      else
        return !1;
      this.outgoing.push(buffer), this.triggerOutgoingHandlers();
    }
    return !0;
  }, BufferScheduler2.prototype.triggerOutgoingHandlers = function() {
    return __awaiter(this, void 0, void 0, function() {
      var buffer;
      return __generator(this, function(_a) {
        do {
          if (this.executingOutgoingHandlers >= this.concurrency)
            return [2];
          buffer = this.outgoing.shift(), buffer && this.triggerOutgoingHandler(buffer);
        } while (buffer);
        return [2];
      });
    });
  }, BufferScheduler2.prototype.triggerOutgoingHandler = function(buffer) {
    return __awaiter(this, void 0, void 0, function() {
      var bufferLength, err_1;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            bufferLength = buffer.size, this.executingOutgoingHandlers++, this.offset += bufferLength, _a.label = 1;
          case 1:
            return _a.trys.push([1, 3, , 4]), [4, this.outgoingHandler(function() {
              return buffer.getReadableStream();
            }, bufferLength, this.offset - bufferLength)];
          case 2:
            return _a.sent(), [3, 4];
          case 3:
            return err_1 = _a.sent(), this.emitter.emit("error", err_1), [2];
          case 4:
            return this.executingOutgoingHandlers--, this.reuseBuffer(buffer), this.emitter.emit("checkEnd"), [2];
        }
      });
    });
  }, BufferScheduler2.prototype.reuseBuffer = function(buffer) {
    this.incoming.push(buffer), !this.isError && this.resolveData() && !this.isStreamEnd && this.readable.resume();
  }, BufferScheduler2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/utils/tracing.js
var import_api3 = __toModule(require_src2());
function createSpan(operationName, tracingOptions) {
  tracingOptions === void 0 && (tracingOptions = {});
  var tracer = getTracer(), spanOptions = __assign(__assign({}, tracingOptions.spanOptions), {kind: import_api3.SpanKind.INTERNAL}), span = tracer.startSpan("Azure.Storage.Blob." + operationName, spanOptions);
  span.setAttribute("az.namespace", "Microsoft.Storage");
  var newOptions = tracingOptions.spanOptions || {};
  return span.isRecording() && (newOptions = __assign(__assign({}, tracingOptions.spanOptions), {parent: span.context(), attributes: __assign(__assign({}, spanOptions.attributes), {"az.namespace": "Microsoft.Storage"})})), {
    span,
    spanOptions: newOptions
  };
}
__name(createSpan, "createSpan");

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/utils/utils.node.js
var fs = __toModule(require("fs")), util2 = __toModule(require("util"));
function streamToBuffer(stream, buffer, offset, end, encoding) {
  return __awaiter(this, void 0, void 0, function() {
    var pos, count;
    return __generator(this, function(_a) {
      return pos = 0, count = end - offset, [2, new Promise(function(resolve, reject) {
        stream.on("readable", function() {
          if (pos >= count) {
            resolve();
            return;
          }
          var chunk = stream.read();
          if (!!chunk) {
            typeof chunk == "string" && (chunk = Buffer.from(chunk, encoding));
            var chunkLength = pos + chunk.length > count ? count - pos : chunk.length;
            buffer.fill(chunk.slice(0, chunkLength), offset + pos, offset + pos + chunkLength), pos += chunkLength;
          }
        }), stream.on("end", function() {
          pos < count && reject(new Error("Stream drains before getting enough data needed. Data read: " + pos + ", data need: " + count)), resolve();
        }), stream.on("error", reject);
      })];
    });
  });
}
__name(streamToBuffer, "streamToBuffer");
function streamToBuffer2(stream, buffer, encoding) {
  return __awaiter(this, void 0, void 0, function() {
    var pos, bufferSize;
    return __generator(this, function(_a) {
      return pos = 0, bufferSize = buffer.length, [2, new Promise(function(resolve, reject) {
        stream.on("readable", function() {
          var chunk = stream.read();
          if (!!chunk) {
            if (typeof chunk == "string" && (chunk = Buffer.from(chunk, encoding)), pos + chunk.length > bufferSize) {
              reject(new Error("Stream exceeds buffer size. Buffer size: " + bufferSize));
              return;
            }
            buffer.fill(chunk, pos, pos + chunk.length), pos += chunk.length;
          }
        }), stream.on("end", function() {
          resolve(pos);
        }), stream.on("error", reject);
      })];
    });
  });
}
__name(streamToBuffer2, "streamToBuffer2");
function readStreamToLocalFile(rs, file) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a) {
      return [2, new Promise(function(resolve, reject) {
        var ws = fs.createWriteStream(file);
        rs.on("error", function(err) {
          reject(err);
        }), ws.on("error", function(err) {
          reject(err);
        }), ws.on("close", resolve), rs.pipe(ws);
      })];
    });
  });
}
__name(readStreamToLocalFile, "readStreamToLocalFile");
var fsStat = util2.promisify(fs.stat), fsCreateReadStream = fs.createReadStream;

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/sas/BlobSASPermissions.js
var BlobSASPermissions = function() {
  function BlobSASPermissions2() {
    this.read = !1, this.add = !1, this.create = !1, this.write = !1, this.delete = !1, this.deleteVersion = !1, this.tag = !1, this.move = !1, this.execute = !1;
  }
  return __name(BlobSASPermissions2, "BlobSASPermissions"), BlobSASPermissions2.parse = function(permissions) {
    for (var blobSASPermissions = new BlobSASPermissions2(), _i = 0, permissions_1 = permissions; _i < permissions_1.length; _i++) {
      var char = permissions_1[_i];
      switch (char) {
        case "r":
          blobSASPermissions.read = !0;
          break;
        case "a":
          blobSASPermissions.add = !0;
          break;
        case "c":
          blobSASPermissions.create = !0;
          break;
        case "w":
          blobSASPermissions.write = !0;
          break;
        case "d":
          blobSASPermissions.delete = !0;
          break;
        case "x":
          blobSASPermissions.deleteVersion = !0;
          break;
        case "t":
          blobSASPermissions.tag = !0;
          break;
        case "m":
          blobSASPermissions.move = !0;
          break;
        case "e":
          blobSASPermissions.execute = !0;
          break;
        default:
          throw new RangeError("Invalid permission: " + char);
      }
    }
    return blobSASPermissions;
  }, BlobSASPermissions2.from = function(permissionLike) {
    var blobSASPermissions = new BlobSASPermissions2();
    return permissionLike.read && (blobSASPermissions.read = !0), permissionLike.add && (blobSASPermissions.add = !0), permissionLike.create && (blobSASPermissions.create = !0), permissionLike.write && (blobSASPermissions.write = !0), permissionLike.delete && (blobSASPermissions.delete = !0), permissionLike.deleteVersion && (blobSASPermissions.deleteVersion = !0), permissionLike.tag && (blobSASPermissions.tag = !0), permissionLike.move && (blobSASPermissions.move = !0), permissionLike.execute && (blobSASPermissions.execute = !0), blobSASPermissions;
  }, BlobSASPermissions2.prototype.toString = function() {
    var permissions = [];
    return this.read && permissions.push("r"), this.add && permissions.push("a"), this.create && permissions.push("c"), this.write && permissions.push("w"), this.delete && permissions.push("d"), this.deleteVersion && permissions.push("x"), this.tag && permissions.push("t"), this.move && permissions.push("m"), this.execute && permissions.push("e"), permissions.join("");
  }, BlobSASPermissions2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/sas/ContainerSASPermissions.js
var ContainerSASPermissions = function() {
  function ContainerSASPermissions2() {
    this.read = !1, this.add = !1, this.create = !1, this.write = !1, this.delete = !1, this.deleteVersion = !1, this.list = !1, this.tag = !1, this.move = !1, this.execute = !1;
  }
  return __name(ContainerSASPermissions2, "ContainerSASPermissions"), ContainerSASPermissions2.parse = function(permissions) {
    for (var containerSASPermissions = new ContainerSASPermissions2(), _i = 0, permissions_1 = permissions; _i < permissions_1.length; _i++) {
      var char = permissions_1[_i];
      switch (char) {
        case "r":
          containerSASPermissions.read = !0;
          break;
        case "a":
          containerSASPermissions.add = !0;
          break;
        case "c":
          containerSASPermissions.create = !0;
          break;
        case "w":
          containerSASPermissions.write = !0;
          break;
        case "d":
          containerSASPermissions.delete = !0;
          break;
        case "l":
          containerSASPermissions.list = !0;
          break;
        case "t":
          containerSASPermissions.tag = !0;
          break;
        case "x":
          containerSASPermissions.deleteVersion = !0;
          break;
        case "m":
          containerSASPermissions.move = !0;
          break;
        case "e":
          containerSASPermissions.execute = !0;
          break;
        default:
          throw new RangeError("Invalid permission " + char);
      }
    }
    return containerSASPermissions;
  }, ContainerSASPermissions2.from = function(permissionLike) {
    var containerSASPermissions = new ContainerSASPermissions2();
    return permissionLike.read && (containerSASPermissions.read = !0), permissionLike.add && (containerSASPermissions.add = !0), permissionLike.create && (containerSASPermissions.create = !0), permissionLike.write && (containerSASPermissions.write = !0), permissionLike.delete && (containerSASPermissions.delete = !0), permissionLike.list && (containerSASPermissions.list = !0), permissionLike.deleteVersion && (containerSASPermissions.deleteVersion = !0), permissionLike.tag && (containerSASPermissions.tag = !0), permissionLike.move && (containerSASPermissions.move = !0), permissionLike.execute && (containerSASPermissions.execute = !0), containerSASPermissions;
  }, ContainerSASPermissions2.prototype.toString = function() {
    var permissions = [];
    return this.read && permissions.push("r"), this.add && permissions.push("a"), this.create && permissions.push("c"), this.write && permissions.push("w"), this.delete && permissions.push("d"), this.deleteVersion && permissions.push("x"), this.list && permissions.push("l"), this.tag && permissions.push("t"), this.move && permissions.push("m"), this.execute && permissions.push("e"), permissions.join("");
  }, ContainerSASPermissions2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/credentials/UserDelegationKeyCredential.js
var import_crypto3 = __toModule(require("crypto")), UserDelegationKeyCredential = function() {
  function UserDelegationKeyCredential2(accountName, userDelegationKey) {
    this.accountName = accountName, this.userDelegationKey = userDelegationKey, this.key = Buffer.from(userDelegationKey.value, "base64");
  }
  return __name(UserDelegationKeyCredential2, "UserDelegationKeyCredential"), UserDelegationKeyCredential2.prototype.computeHMACSHA256 = function(stringToSign) {
    return import_crypto3.createHmac("sha256", this.key).update(stringToSign, "utf8").digest("base64");
  }, UserDelegationKeyCredential2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/sas/SasIPRange.js
function ipRangeToString(ipRange) {
  return ipRange.end ? ipRange.start + "-" + ipRange.end : ipRange.start;
}
__name(ipRangeToString, "ipRangeToString");

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/sas/SASQueryParameters.js
var SASProtocol;
(function(SASProtocol2) {
  SASProtocol2.Https = "https", SASProtocol2.HttpsAndHttp = "https,http";
})(SASProtocol || (SASProtocol = {}));
var SASQueryParameters = function() {
  function SASQueryParameters2(version2, signature, permissionsOrOptions, services, resourceTypes, protocol, startsOn, expiresOn2, ipRange, identifier, resource, cacheControl2, contentDisposition2, contentEncoding2, contentLanguage2, contentType2, userDelegationKey, preauthorizedAgentObjectId, correlationId) {
    this.version = version2, this.signature = signature, permissionsOrOptions !== void 0 && typeof permissionsOrOptions != "string" ? (this.permissions = permissionsOrOptions.permissions, this.services = permissionsOrOptions.services, this.resourceTypes = permissionsOrOptions.resourceTypes, this.protocol = permissionsOrOptions.protocol, this.startsOn = permissionsOrOptions.startsOn, this.expiresOn = permissionsOrOptions.expiresOn, this.ipRangeInner = permissionsOrOptions.ipRange, this.identifier = permissionsOrOptions.identifier, this.resource = permissionsOrOptions.resource, this.cacheControl = permissionsOrOptions.cacheControl, this.contentDisposition = permissionsOrOptions.contentDisposition, this.contentEncoding = permissionsOrOptions.contentEncoding, this.contentLanguage = permissionsOrOptions.contentLanguage, this.contentType = permissionsOrOptions.contentType, permissionsOrOptions.userDelegationKey && (this.signedOid = permissionsOrOptions.userDelegationKey.signedObjectId, this.signedTenantId = permissionsOrOptions.userDelegationKey.signedTenantId, this.signedStartsOn = permissionsOrOptions.userDelegationKey.signedStartsOn, this.signedExpiresOn = permissionsOrOptions.userDelegationKey.signedExpiresOn, this.signedService = permissionsOrOptions.userDelegationKey.signedService, this.signedVersion = permissionsOrOptions.userDelegationKey.signedVersion, this.preauthorizedAgentObjectId = permissionsOrOptions.preauthorizedAgentObjectId, this.correlationId = permissionsOrOptions.correlationId)) : (this.services = services, this.resourceTypes = resourceTypes, this.expiresOn = expiresOn2, this.permissions = permissionsOrOptions, this.protocol = protocol, this.startsOn = startsOn, this.ipRangeInner = ipRange, this.identifier = identifier, this.resource = resource, this.cacheControl = cacheControl2, this.contentDisposition = contentDisposition2, this.contentEncoding = contentEncoding2, this.contentLanguage = contentLanguage2, this.contentType = contentType2, userDelegationKey && (this.signedOid = userDelegationKey.signedObjectId, this.signedTenantId = userDelegationKey.signedTenantId, this.signedStartsOn = userDelegationKey.signedStartsOn, this.signedExpiresOn = userDelegationKey.signedExpiresOn, this.signedService = userDelegationKey.signedService, this.signedVersion = userDelegationKey.signedVersion, this.preauthorizedAgentObjectId = preauthorizedAgentObjectId, this.correlationId = correlationId));
  }
  return __name(SASQueryParameters2, "SASQueryParameters"), Object.defineProperty(SASQueryParameters2.prototype, "ipRange", {
    get: function() {
      if (this.ipRangeInner)
        return {
          end: this.ipRangeInner.end,
          start: this.ipRangeInner.start
        };
    },
    enumerable: !1,
    configurable: !0
  }), SASQueryParameters2.prototype.toString = function() {
    for (var params = [
      "sv",
      "ss",
      "srt",
      "spr",
      "st",
      "se",
      "sip",
      "si",
      "skoid",
      "sktid",
      "skt",
      "ske",
      "sks",
      "skv",
      "sr",
      "sp",
      "sig",
      "rscc",
      "rscd",
      "rsce",
      "rscl",
      "rsct",
      "saoid",
      "scid"
    ], queries = [], _i = 0, params_1 = params; _i < params_1.length; _i++) {
      var param = params_1[_i];
      switch (param) {
        case "sv":
          this.tryAppendQueryParameter(queries, param, this.version);
          break;
        case "ss":
          this.tryAppendQueryParameter(queries, param, this.services);
          break;
        case "srt":
          this.tryAppendQueryParameter(queries, param, this.resourceTypes);
          break;
        case "spr":
          this.tryAppendQueryParameter(queries, param, this.protocol);
          break;
        case "st":
          this.tryAppendQueryParameter(queries, param, this.startsOn ? truncatedISO8061Date(this.startsOn, !1) : void 0);
          break;
        case "se":
          this.tryAppendQueryParameter(queries, param, this.expiresOn ? truncatedISO8061Date(this.expiresOn, !1) : void 0);
          break;
        case "sip":
          this.tryAppendQueryParameter(queries, param, this.ipRange ? ipRangeToString(this.ipRange) : void 0);
          break;
        case "si":
          this.tryAppendQueryParameter(queries, param, this.identifier);
          break;
        case "skoid":
          this.tryAppendQueryParameter(queries, param, this.signedOid);
          break;
        case "sktid":
          this.tryAppendQueryParameter(queries, param, this.signedTenantId);
          break;
        case "skt":
          this.tryAppendQueryParameter(queries, param, this.signedStartsOn ? truncatedISO8061Date(this.signedStartsOn, !1) : void 0);
          break;
        case "ske":
          this.tryAppendQueryParameter(queries, param, this.signedExpiresOn ? truncatedISO8061Date(this.signedExpiresOn, !1) : void 0);
          break;
        case "sks":
          this.tryAppendQueryParameter(queries, param, this.signedService);
          break;
        case "skv":
          this.tryAppendQueryParameter(queries, param, this.signedVersion);
          break;
        case "sr":
          this.tryAppendQueryParameter(queries, param, this.resource);
          break;
        case "sp":
          this.tryAppendQueryParameter(queries, param, this.permissions);
          break;
        case "sig":
          this.tryAppendQueryParameter(queries, param, this.signature);
          break;
        case "rscc":
          this.tryAppendQueryParameter(queries, param, this.cacheControl);
          break;
        case "rscd":
          this.tryAppendQueryParameter(queries, param, this.contentDisposition);
          break;
        case "rsce":
          this.tryAppendQueryParameter(queries, param, this.contentEncoding);
          break;
        case "rscl":
          this.tryAppendQueryParameter(queries, param, this.contentLanguage);
          break;
        case "rsct":
          this.tryAppendQueryParameter(queries, param, this.contentType);
          break;
        case "saoid":
          this.tryAppendQueryParameter(queries, param, this.preauthorizedAgentObjectId);
          break;
        case "scid":
          this.tryAppendQueryParameter(queries, param, this.correlationId);
          break;
      }
    }
    return queries.join("&");
  }, SASQueryParameters2.prototype.tryAppendQueryParameter = function(queries, key, value) {
    !value || (key = encodeURIComponent(key), value = encodeURIComponent(value), key.length > 0 && value.length > 0 && queries.push(key + "=" + value));
  }, SASQueryParameters2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/sas/BlobSASSignatureValues.js
function generateBlobSASQueryParameters(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {
  var version2 = blobSASSignatureValues.version ? blobSASSignatureValues.version : SERVICE_VERSION, sharedKeyCredential = sharedKeyCredentialOrUserDelegationKey instanceof StorageSharedKeyCredential ? sharedKeyCredentialOrUserDelegationKey : void 0, userDelegationKeyCredential;
  if (sharedKeyCredential === void 0 && accountName !== void 0 && (userDelegationKeyCredential = new UserDelegationKeyCredential(accountName, sharedKeyCredentialOrUserDelegationKey)), sharedKeyCredential === void 0 && userDelegationKeyCredential === void 0)
    throw TypeError("Invalid sharedKeyCredential, userDelegationKey or accountName.");
  if (version2 >= "2018-11-09")
    return sharedKeyCredential !== void 0 ? generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential) : version2 >= "2020-02-10" ? generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential) : generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential);
  if (version2 >= "2015-04-05") {
    if (sharedKeyCredential !== void 0)
      return generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential);
    throw new RangeError("'version' must be >= '2018-11-09' when generating user delegation SAS using user delegation key.");
  }
  throw new RangeError("'version' must be >= '2015-04-05'.");
}
__name(generateBlobSASQueryParameters, "generateBlobSASQueryParameters");
function generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential) {
  if (blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues), !blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn))
    throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
  var resource = "c";
  blobSASSignatureValues.blobName && (resource = "b");
  var verifiedPermissions;
  blobSASSignatureValues.permissions && (blobSASSignatureValues.blobName ? verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString() : verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString());
  var stringToSign = [
    verifiedPermissions || "",
    blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, !1) : "",
    blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, !1) : "",
    getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
    blobSASSignatureValues.identifier,
    blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
    blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
    blobSASSignatureValues.version,
    blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
    blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
    blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
    blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
    blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
  ].join(`
`), signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
  return new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType);
}
__name(generateBlobSASQueryParameters20150405, "generateBlobSASQueryParameters20150405");
function generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential) {
  if (blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues), !blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn))
    throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
  var resource = "c", timestamp = blobSASSignatureValues.snapshotTime;
  blobSASSignatureValues.blobName && (resource = "b", blobSASSignatureValues.snapshotTime ? resource = "bs" : blobSASSignatureValues.versionId && (resource = "bv", timestamp = blobSASSignatureValues.versionId));
  var verifiedPermissions;
  blobSASSignatureValues.permissions && (blobSASSignatureValues.blobName ? verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString() : verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString());
  var stringToSign = [
    verifiedPermissions || "",
    blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, !1) : "",
    blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, !1) : "",
    getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
    blobSASSignatureValues.identifier,
    blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
    blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
    blobSASSignatureValues.version,
    resource,
    timestamp,
    blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
    blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
    blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
    blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
    blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
  ].join(`
`), signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
  return new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType);
}
__name(generateBlobSASQueryParameters20181109, "generateBlobSASQueryParameters20181109");
function generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential) {
  if (blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues), !blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn)
    throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
  var resource = "c", timestamp = blobSASSignatureValues.snapshotTime;
  blobSASSignatureValues.blobName && (resource = "b", blobSASSignatureValues.snapshotTime ? resource = "bs" : blobSASSignatureValues.versionId && (resource = "bv", timestamp = blobSASSignatureValues.versionId));
  var verifiedPermissions;
  blobSASSignatureValues.permissions && (blobSASSignatureValues.blobName ? verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString() : verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString());
  var stringToSign = [
    verifiedPermissions || "",
    blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, !1) : "",
    blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, !1) : "",
    getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
    userDelegationKeyCredential.userDelegationKey.signedObjectId,
    userDelegationKeyCredential.userDelegationKey.signedTenantId,
    userDelegationKeyCredential.userDelegationKey.signedStartsOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, !1) : "",
    userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, !1) : "",
    userDelegationKeyCredential.userDelegationKey.signedService,
    userDelegationKeyCredential.userDelegationKey.signedVersion,
    blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
    blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
    blobSASSignatureValues.version,
    resource,
    timestamp,
    blobSASSignatureValues.cacheControl,
    blobSASSignatureValues.contentDisposition,
    blobSASSignatureValues.contentEncoding,
    blobSASSignatureValues.contentLanguage,
    blobSASSignatureValues.contentType
  ].join(`
`), signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
  return new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey);
}
__name(generateBlobSASQueryParametersUDK20181109, "generateBlobSASQueryParametersUDK20181109");
function generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential) {
  if (blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues), !blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn)
    throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
  var resource = "c", timestamp = blobSASSignatureValues.snapshotTime;
  blobSASSignatureValues.blobName && (resource = "b", blobSASSignatureValues.snapshotTime ? resource = "bs" : blobSASSignatureValues.versionId && (resource = "bv", timestamp = blobSASSignatureValues.versionId));
  var verifiedPermissions;
  blobSASSignatureValues.permissions && (blobSASSignatureValues.blobName ? verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString() : verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString());
  var stringToSign = [
    verifiedPermissions || "",
    blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, !1) : "",
    blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, !1) : "",
    getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
    userDelegationKeyCredential.userDelegationKey.signedObjectId,
    userDelegationKeyCredential.userDelegationKey.signedTenantId,
    userDelegationKeyCredential.userDelegationKey.signedStartsOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, !1) : "",
    userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, !1) : "",
    userDelegationKeyCredential.userDelegationKey.signedService,
    userDelegationKeyCredential.userDelegationKey.signedVersion,
    blobSASSignatureValues.preauthorizedAgentObjectId,
    void 0,
    blobSASSignatureValues.correlationId,
    blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
    blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
    blobSASSignatureValues.version,
    resource,
    timestamp,
    blobSASSignatureValues.cacheControl,
    blobSASSignatureValues.contentDisposition,
    blobSASSignatureValues.contentEncoding,
    blobSASSignatureValues.contentLanguage,
    blobSASSignatureValues.contentType
  ].join(`
`), signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
  return new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId);
}
__name(generateBlobSASQueryParametersUDK20200210, "generateBlobSASQueryParametersUDK20200210");
function getCanonicalName(accountName, containerName, blobName) {
  var elements = ["/blob/" + accountName + "/" + containerName];
  return blobName && elements.push("/" + blobName), elements.join("");
}
__name(getCanonicalName, "getCanonicalName");
function SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues) {
  var version2 = blobSASSignatureValues.version ? blobSASSignatureValues.version : SERVICE_VERSION;
  if (blobSASSignatureValues.snapshotTime && version2 < "2018-11-09")
    throw RangeError("'version' must be >= '2018-11-09' when providing 'snapshotTime'.");
  if (blobSASSignatureValues.blobName === void 0 && blobSASSignatureValues.snapshotTime)
    throw RangeError("Must provide 'blobName' when providing 'snapshotTime'.");
  if (blobSASSignatureValues.versionId && version2 < "2019-10-10")
    throw RangeError("'version' must be >= '2019-10-10' when providing 'versionId'.");
  if (blobSASSignatureValues.blobName === void 0 && blobSASSignatureValues.versionId)
    throw RangeError("Must provide 'blobName' when providing 'versionId'.");
  if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.deleteVersion && version2 < "2019-10-10")
    throw RangeError("'version' must be >= '2019-10-10' when providing 'x' permission.");
  if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.tag && version2 < "2019-12-12")
    throw RangeError("'version' must be >= '2019-12-12' when providing 't' permission.");
  if (version2 < "2020-02-10" && blobSASSignatureValues.permissions && (blobSASSignatureValues.permissions.move || blobSASSignatureValues.permissions.execute))
    throw RangeError("'version' must be >= '2020-02-10' when providing the 'm' or 'e' permission.");
  if (version2 < "2020-02-10" && (blobSASSignatureValues.preauthorizedAgentObjectId || blobSASSignatureValues.correlationId))
    throw RangeError("'version' must be >= '2020-02-10' when providing 'preauthorizedAgentObjectId' or 'correlationId'.");
  return blobSASSignatureValues.version = version2, blobSASSignatureValues;
}
__name(SASSignatureValuesSanityCheckAndAutofill, "SASSignatureValuesSanityCheckAndAutofill");

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/Clients.js
var BlobClient = function(_super) {
  __extends(BlobClient2, _super);
  function BlobClient2(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
    var _a, _this = this;
    options = options || {};
    var pipeline, url2;
    if (credentialOrPipelineOrContainerName instanceof Pipeline)
      url2 = urlOrConnectionString, pipeline = credentialOrPipelineOrContainerName;
    else if (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName))
      url2 = urlOrConnectionString, options = blobNameOrOptions, pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
    else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName != "string")
      url2 = urlOrConnectionString, pipeline = newPipeline(new AnonymousCredential(), options);
    else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName == "string" && blobNameOrOptions && typeof blobNameOrOptions == "string") {
      var containerName = credentialOrPipelineOrContainerName, blobName = blobNameOrOptions, extractedCreds = extractConnectionStringParts(urlOrConnectionString);
      if (extractedCreds.kind === "AccountConnString")
        if (isNode) {
          var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
          url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)), options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri), pipeline = newPipeline(sharedKeyCredential, options);
        } else
          throw new Error("Account connection string is only supported in Node.js environment");
      else if (extractedCreds.kind === "SASConnString")
        url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas, pipeline = newPipeline(new AnonymousCredential(), options);
      else
        throw new Error("Connection string must be either an Account connection string or a SAS connection string");
    } else
      throw new Error("Expecting non-empty strings for containerName and blobName parameters");
    return _this = _super.call(this, url2, pipeline) || this, _a = _this.getBlobAndContainerNamesFromUrl(), _this._name = _a.blobName, _this._containerName = _a.containerName, _this.blobContext = new Blob3(_this.storageClientContext), _this._snapshot = getURLParameter(_this.url, URLConstants.Parameters.SNAPSHOT), _this._versionId = getURLParameter(_this.url, URLConstants.Parameters.VERSIONID), _this;
  }
  return __name(BlobClient2, "BlobClient"), Object.defineProperty(BlobClient2.prototype, "name", {
    get: function() {
      return this._name;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobClient2.prototype, "containerName", {
    get: function() {
      return this._containerName;
    },
    enumerable: !1,
    configurable: !0
  }), BlobClient2.prototype.withSnapshot = function(snapshot2) {
    return new BlobClient2(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot2.length === 0 ? void 0 : snapshot2), this.pipeline);
  }, BlobClient2.prototype.withVersion = function(versionId2) {
    return new BlobClient2(setURLParameter(this.url, URLConstants.Parameters.VERSIONID, versionId2.length === 0 ? void 0 : versionId2), this.pipeline);
  }, BlobClient2.prototype.getAppendBlobClient = function() {
    return new AppendBlobClient(this.url, this.pipeline);
  }, BlobClient2.prototype.getBlockBlobClient = function() {
    return new BlockBlobClient(this.url, this.pipeline);
  }, BlobClient2.prototype.getPageBlobClient = function() {
    return new PageBlobClient(this.url, this.pipeline);
  }, BlobClient2.prototype.download = function(offset, count, options) {
    var _a;
    return offset === void 0 && (offset = 0), options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, res_1, wrappedRes, e_1, _this = this;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            options.conditions = options.conditions || {}, options.conditions = options.conditions || {}, ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps), _b = createSpan("BlobClient-download", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), [4, this.blobContext.download({
              abortSignal: options.abortSignal,
              leaseAccessConditions: options.conditions,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              onDownloadProgress: isNode ? void 0 : options.onProgress,
              range: offset === 0 && !count ? void 0 : rangeToString({offset, count}),
              rangeGetContentMD5: options.rangeGetContentMD5,
              rangeGetContentCRC64: options.rangeGetContentCrc64,
              snapshot: options.snapshot,
              cpkInfo: options.customerProvidedKey,
              spanOptions
            })];
          case 2:
            if (res_1 = _c.sent(), wrappedRes = __assign(__assign({}, res_1), {_response: res_1._response, objectReplicationDestinationPolicyId: res_1.objectReplicationPolicyId, objectReplicationSourceProperties: parseObjectReplicationRecord(res_1.objectReplicationRules)}), !isNode)
              return [2, wrappedRes];
            if ((options.maxRetryRequests === void 0 || options.maxRetryRequests < 0) && (options.maxRetryRequests = DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS), res_1.contentLength === void 0)
              throw new RangeError("File download response doesn't contain valid content length header");
            if (!res_1.etag)
              throw new RangeError("File download response doesn't contain valid etag header");
            return [2, new BlobDownloadResponse(wrappedRes, function(start) {
              return __awaiter(_this, void 0, void 0, function() {
                var updatedOptions, _a2;
                return __generator(this, function(_b2) {
                  switch (_b2.label) {
                    case 0:
                      return updatedOptions = {
                        leaseAccessConditions: options.conditions,
                        modifiedAccessConditions: {
                          ifMatch: options.conditions.ifMatch || res_1.etag,
                          ifModifiedSince: options.conditions.ifModifiedSince,
                          ifNoneMatch: options.conditions.ifNoneMatch,
                          ifUnmodifiedSince: options.conditions.ifUnmodifiedSince,
                          ifTags: (_a2 = options.conditions) === null || _a2 === void 0 ? void 0 : _a2.tagConditions
                        },
                        range: rangeToString({
                          count: offset + res_1.contentLength - start,
                          offset: start
                        }),
                        rangeGetContentMD5: options.rangeGetContentMD5,
                        rangeGetContentCRC64: options.rangeGetContentCrc64,
                        snapshot: options.snapshot,
                        cpkInfo: options.customerProvidedKey
                      }, [4, this.blobContext.download(__assign({abortSignal: options.abortSignal}, updatedOptions))];
                    case 1:
                      return [2, _b2.sent().readableStreamBody];
                  }
                });
              });
            }, offset, res_1.contentLength, {
              abortSignal: options.abortSignal,
              maxRetryRequests: options.maxRetryRequests,
              onProgress: options.onProgress
            })];
          case 3:
            throw e_1 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_1.message
            }), e_1;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobClient2.prototype.exists = function(options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, e_2;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("BlobClient-exists", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps), [4, this.getProperties({
              abortSignal: options.abortSignal,
              customerProvidedKey: options.customerProvidedKey,
              conditions: options.conditions,
              tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})
            })];
          case 2:
            return _b.sent(), [2, !0];
          case 3:
            if (e_2 = _b.sent(), e_2.statusCode === 404)
              return span.setStatus({
                code: import_api4.CanonicalCode.NOT_FOUND,
                message: "Expected exception when checking blob existence"
              }), [2, !1];
            throw span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_2.message
            }), e_2;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobClient2.prototype.getProperties = function(options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, res, e_3;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            _b = createSpan("BlobClient-getProperties", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), options.conditions = options.conditions || {}, ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps), [4, this.blobContext.getProperties({
              abortSignal: options.abortSignal,
              leaseAccessConditions: options.conditions,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              cpkInfo: options.customerProvidedKey,
              spanOptions
            })];
          case 2:
            return res = _c.sent(), [2, __assign(__assign({}, res), {_response: res._response, objectReplicationDestinationPolicyId: res.objectReplicationPolicyId, objectReplicationSourceProperties: parseObjectReplicationRecord(res.objectReplicationRules)})];
          case 3:
            throw e_3 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_3.message
            }), e_3;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobClient2.prototype.delete = function(options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_4;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            _b = createSpan("BlobClient-delete", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, options.conditions = options.conditions || {}, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), [4, this.blobContext.deleteMethod({
              abortSignal: options.abortSignal,
              deleteSnapshots: options.deleteSnapshots,
              leaseAccessConditions: options.conditions,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              spanOptions
            })];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_4 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_4.message
            }), e_4;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobClient2.prototype.deleteIfExists = function(options) {
    var _a, _b;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _c, span, spanOptions, res, e_5;
      return __generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            _c = createSpan("BlobClient-deleteIfExists", options.tracingOptions), span = _c.span, spanOptions = _c.spanOptions, _d.label = 1;
          case 1:
            return _d.trys.push([1, 3, 4, 5]), [4, this.delete(__assign(__assign({}, options), {tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})}))];
          case 2:
            return res = _d.sent(), [2, __assign(__assign({succeeded: !0}, res), {
              _response: res._response
            })];
          case 3:
            if (e_5 = _d.sent(), ((_a = e_5.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "BlobNotFound")
              return span.setStatus({
                code: import_api4.CanonicalCode.NOT_FOUND,
                message: "Expected exception when deleting a blob or snapshot only if it exists."
              }), [2, __assign(__assign({succeeded: !1}, (_b = e_5.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), {_response: e_5.response})];
            throw span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_5.message
            }), e_5;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobClient2.prototype.undelete = function(options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, e_6;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("BlobClient-undelete", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), [4, this.blobContext.undelete({
              abortSignal: options.abortSignal,
              spanOptions
            })];
          case 2:
            return [2, _b.sent()];
          case 3:
            throw e_6 = _b.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_6.message
            }), e_6;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobClient2.prototype.setHTTPHeaders = function(blobHTTPHeaders, options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_7;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            _b = createSpan("BlobClient-setHTTPHeaders", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, options.conditions = options.conditions || {}, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps), [4, this.blobContext.setHTTPHeaders({
              abortSignal: options.abortSignal,
              blobHTTPHeaders,
              leaseAccessConditions: options.conditions,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              cpkInfo: options.customerProvidedKey,
              spanOptions
            })];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_7 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_7.message
            }), e_7;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobClient2.prototype.setMetadata = function(metadata2, options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_8;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            _b = createSpan("BlobClient-setMetadata", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, options.conditions = options.conditions || {}, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps), [4, this.blobContext.setMetadata({
              abortSignal: options.abortSignal,
              leaseAccessConditions: options.conditions,
              metadata: metadata2,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              cpkInfo: options.customerProvidedKey,
              encryptionScope: options.encryptionScope,
              spanOptions
            })];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_8 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_8.message
            }), e_8;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobClient2.prototype.setTags = function(tags, options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_9;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            _b = createSpan("BlobClient-setTags", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), [4, this.blobContext.setTags({
              abortSignal: options.abortSignal,
              leaseAccessConditions: options.conditions,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              spanOptions,
              tags: toBlobTags(tags)
            })];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_9 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_9.message
            }), e_9;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobClient2.prototype.getTags = function(options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, response, wrappedResponse, e_10;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            _b = createSpan("BlobClient-getTags", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), [4, this.blobContext.getTags({
              abortSignal: options.abortSignal,
              leaseAccessConditions: options.conditions,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              spanOptions
            })];
          case 2:
            return response = _c.sent(), wrappedResponse = __assign(__assign({}, response), {_response: response._response, tags: toTags({blobTagSet: response.blobTagSet}) || {}}), [2, wrappedResponse];
          case 3:
            throw e_10 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_10.message
            }), e_10;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobClient2.prototype.getBlobLeaseClient = function(proposeLeaseId) {
    return new BlobLeaseClient(this, proposeLeaseId);
  }, BlobClient2.prototype.createSnapshot = function(options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_11;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            _b = createSpan("BlobClient-createSnapshot", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, options.conditions = options.conditions || {}, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps), [4, this.blobContext.createSnapshot({
              abortSignal: options.abortSignal,
              leaseAccessConditions: options.conditions,
              metadata: options.metadata,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              cpkInfo: options.customerProvidedKey,
              encryptionScope: options.encryptionScope,
              spanOptions
            })];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_11 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_11.message
            }), e_11;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobClient2.prototype.beginCopyFromURL = function(copySource2, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var client, poller, _this = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return client = {
              abortCopyFromURL: function() {
                for (var args = [], _i = 0; _i < arguments.length; _i++)
                  args[_i] = arguments[_i];
                return _this.abortCopyFromURL.apply(_this, args);
              },
              getProperties: function() {
                for (var args = [], _i = 0; _i < arguments.length; _i++)
                  args[_i] = arguments[_i];
                return _this.getProperties.apply(_this, args);
              },
              startCopyFromURL: function() {
                for (var args = [], _i = 0; _i < arguments.length; _i++)
                  args[_i] = arguments[_i];
                return _this.startCopyFromURL.apply(_this, args);
              }
            }, poller = new BlobBeginCopyFromUrlPoller({
              blobClient: client,
              copySource: copySource2,
              intervalInMs: options.intervalInMs,
              onProgress: options.onProgress,
              resumeFrom: options.resumeFrom,
              startCopyFromURLOptions: options
            }), [4, poller.poll()];
          case 1:
            return _a.sent(), [2, poller];
        }
      });
    });
  }, BlobClient2.prototype.abortCopyFromURL = function(copyId2, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, e_12;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("BlobClient-abortCopyFromURL", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), [4, this.blobContext.abortCopyFromURL(copyId2, {
              abortSignal: options.abortSignal,
              leaseAccessConditions: options.conditions,
              spanOptions
            })];
          case 2:
            return [2, _b.sent()];
          case 3:
            throw e_12 = _b.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_12.message
            }), e_12;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobClient2.prototype.syncCopyFromURL = function(copySource2, options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_13;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            _b = createSpan("BlobClient-syncCopyFromURL", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, options.conditions = options.conditions || {}, options.sourceConditions = options.sourceConditions || {}, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), [4, this.blobContext.copyFromURL(copySource2, {
              abortSignal: options.abortSignal,
              metadata: options.metadata,
              leaseAccessConditions: options.conditions,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              sourceModifiedAccessConditions: {
                sourceIfMatch: options.sourceConditions.ifMatch,
                sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,
                sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,
                sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince
              },
              sourceContentMD5: options.sourceContentMD5,
              blobTagsString: toBlobTagsString(options.tags),
              spanOptions
            })];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_13 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_13.message
            }), e_13;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobClient2.prototype.setAccessTier = function(tier, options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_14;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            _b = createSpan("BlobClient-setAccessTier", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), [4, this.blobContext.setTier(toAccessTier(tier), {
              abortSignal: options.abortSignal,
              leaseAccessConditions: options.conditions,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              rehydratePriority: options.rehydratePriority,
              spanOptions
            })];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_14 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_14.message
            }), e_14;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobClient2.prototype.downloadToBuffer = function(param1, param2, param3, param4) {
    return param4 === void 0 && (param4 = {}), __awaiter(this, void 0, void 0, function() {
      var buffer, offset, count, options, _a, span, spanOptions, response, transferProgress_1, batch, _loop_1, off, e_15, _this = this;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            offset = 0, count = 0, options = param4, param1 instanceof Buffer ? (buffer = param1, offset = param2 || 0, count = typeof param3 == "number" ? param3 : 0) : (offset = typeof param1 == "number" ? param1 : 0, count = typeof param2 == "number" ? param2 : 0, options = param3 || {}), _a = createSpan("BlobClient-downloadToBuffer", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            if (_b.trys.push([1, 5, 6, 7]), options.blockSize || (options.blockSize = 0), options.blockSize < 0)
              throw new RangeError("blockSize option must be >= 0");
            if (options.blockSize === 0 && (options.blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES), offset < 0)
              throw new RangeError("offset option must be >= 0");
            if (count && count <= 0)
              throw new RangeError("count option must be > 0");
            return options.conditions || (options.conditions = {}), count ? [3, 3] : [4, this.getProperties(__assign(__assign({}, options), {tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})}))];
          case 2:
            if (response = _b.sent(), count = response.contentLength - offset, count < 0)
              throw new RangeError("offset " + offset + " shouldn't be larger than blob size " + response.contentLength);
            _b.label = 3;
          case 3:
            if (!buffer)
              try {
                buffer = Buffer.alloc(count);
              } catch (error) {
                throw new Error("Unable to allocate the buffer of size: " + count + '(in bytes). Please try passing your own buffer to the "downloadToBuffer" method or try using other methods like "download" or "downloadToFile".	 ' + error.message);
              }
            if (buffer.length < count)
              throw new RangeError("The buffer's size should be equal to or larger than the request count of bytes: " + count);
            for (transferProgress_1 = 0, batch = new Batch(options.concurrency), _loop_1 = /* @__PURE__ */ __name(function(off2) {
              batch.addOperation(function() {
                return __awaiter(_this, void 0, void 0, function() {
                  var chunkEnd, response2, stream;
                  return __generator(this, function(_a2) {
                    switch (_a2.label) {
                      case 0:
                        return chunkEnd = offset + count, off2 + options.blockSize < chunkEnd && (chunkEnd = off2 + options.blockSize), [4, this.download(off2, chunkEnd - off2, {
                          abortSignal: options.abortSignal,
                          conditions: options.conditions,
                          maxRetryRequests: options.maxRetryRequestsPerBlock,
                          customerProvidedKey: options.customerProvidedKey,
                          tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})
                        })];
                      case 1:
                        return response2 = _a2.sent(), stream = response2.readableStreamBody, [4, streamToBuffer(stream, buffer, off2 - offset, chunkEnd - offset)];
                      case 2:
                        return _a2.sent(), transferProgress_1 += chunkEnd - off2, options.onProgress && options.onProgress({loadedBytes: transferProgress_1}), [2];
                    }
                  });
                });
              });
            }, "_loop_1"), off = offset; off < offset + count; off = off + options.blockSize)
              _loop_1(off);
            return [4, batch.do()];
          case 4:
            return _b.sent(), [2, buffer];
          case 5:
            throw e_15 = _b.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_15.message
            }), e_15;
          case 6:
            return span.end(), [7];
          case 7:
            return [2];
        }
      });
    });
  }, BlobClient2.prototype.downloadToFile = function(filePath, offset, count, options) {
    return offset === void 0 && (offset = 0), options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, response, e_16;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("BlobClient-downloadToFile", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 5, 6, 7]), [4, this.download(offset, count, __assign(__assign({}, options), {tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})}))];
          case 2:
            return response = _b.sent(), response.readableStreamBody ? [4, readStreamToLocalFile(response.readableStreamBody, filePath)] : [3, 4];
          case 3:
            _b.sent(), _b.label = 4;
          case 4:
            return response.blobDownloadStream = void 0, [2, response];
          case 5:
            throw e_16 = _b.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_16.message
            }), e_16;
          case 6:
            return span.end(), [7];
          case 7:
            return [2];
        }
      });
    });
  }, BlobClient2.prototype.getBlobAndContainerNamesFromUrl = function() {
    var containerName, blobName;
    try {
      var parsedUrl = URLBuilder.parse(this.url);
      if (parsedUrl.getHost().split(".")[1] === "blob") {
        var pathComponents = parsedUrl.getPath().match("/([^/]*)(/(.*))?");
        containerName = pathComponents[1], blobName = pathComponents[3];
      } else if (isIpEndpointStyle(parsedUrl)) {
        var pathComponents = parsedUrl.getPath().match("/([^/]*)/([^/]*)(/(.*))?");
        containerName = pathComponents[2], blobName = pathComponents[4];
      } else {
        var pathComponents = parsedUrl.getPath().match("/([^/]*)(/(.*))?");
        containerName = pathComponents[1], blobName = pathComponents[3];
      }
      if (containerName = decodeURIComponent(containerName), blobName = decodeURIComponent(blobName), blobName = blobName.replace(/\\/g, "/"), !containerName)
        throw new Error("Provided containerName is invalid.");
      return {blobName, containerName};
    } catch (error) {
      throw new Error("Unable to extract blobName and containerName with provided information.");
    }
  }, BlobClient2.prototype.startCopyFromURL = function(copySource2, options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_17;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            _b = createSpan("BlobClient-startCopyFromURL", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, options.conditions = options.conditions || {}, options.sourceConditions = options.sourceConditions || {}, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), [4, this.blobContext.startCopyFromURL(copySource2, {
              abortSignal: options.abortSignal,
              leaseAccessConditions: options.conditions,
              metadata: options.metadata,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              sourceModifiedAccessConditions: {
                sourceIfMatch: options.sourceConditions.ifMatch,
                sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,
                sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,
                sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince,
                sourceIfTags: options.sourceConditions.tagConditions
              },
              rehydratePriority: options.rehydratePriority,
              tier: toAccessTier(options.tier),
              blobTagsString: toBlobTagsString(options.tags),
              sealBlob: options.sealBlob,
              spanOptions
            })];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_17 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_17.message
            }), e_17;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobClient2.prototype.generateSasUrl = function(options) {
    var _this = this;
    return new Promise(function(resolve) {
      if (!(_this.credential instanceof StorageSharedKeyCredential))
        throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
      var sas = generateBlobSASQueryParameters(__assign({containerName: _this._containerName, blobName: _this._name, snapshotTime: _this._snapshot, versionId: _this._versionId}, options), _this.credential).toString();
      resolve(appendToURLQuery(_this.url, sas));
    });
  }, BlobClient2;
}(StorageClient);
var AppendBlobClient = function(_super) {
  __extends(AppendBlobClient2, _super);
  function AppendBlobClient2(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
    var _this = this, pipeline, url2;
    if (options = options || {}, credentialOrPipelineOrContainerName instanceof Pipeline)
      url2 = urlOrConnectionString, pipeline = credentialOrPipelineOrContainerName;
    else if (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName))
      url2 = urlOrConnectionString, options = blobNameOrOptions, pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
    else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName != "string")
      url2 = urlOrConnectionString, pipeline = newPipeline(new AnonymousCredential(), options);
    else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName == "string" && blobNameOrOptions && typeof blobNameOrOptions == "string") {
      var containerName = credentialOrPipelineOrContainerName, blobName = blobNameOrOptions, extractedCreds = extractConnectionStringParts(urlOrConnectionString);
      if (extractedCreds.kind === "AccountConnString")
        if (isNode) {
          var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
          url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)), options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri), pipeline = newPipeline(sharedKeyCredential, options);
        } else
          throw new Error("Account connection string is only supported in Node.js environment");
      else if (extractedCreds.kind === "SASConnString")
        url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas, pipeline = newPipeline(new AnonymousCredential(), options);
      else
        throw new Error("Connection string must be either an Account connection string or a SAS connection string");
    } else
      throw new Error("Expecting non-empty strings for containerName and blobName parameters");
    return _this = _super.call(this, url2, pipeline) || this, _this.appendBlobContext = new AppendBlob(_this.storageClientContext), _this;
  }
  return __name(AppendBlobClient2, "AppendBlobClient"), AppendBlobClient2.prototype.withSnapshot = function(snapshot2) {
    return new AppendBlobClient2(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot2.length === 0 ? void 0 : snapshot2), this.pipeline);
  }, AppendBlobClient2.prototype.create = function(options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_18;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            _b = createSpan("AppendBlobClient-create", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, options.conditions = options.conditions || {}, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps), [4, this.appendBlobContext.create(0, {
              abortSignal: options.abortSignal,
              blobHTTPHeaders: options.blobHTTPHeaders,
              leaseAccessConditions: options.conditions,
              metadata: options.metadata,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              cpkInfo: options.customerProvidedKey,
              encryptionScope: options.encryptionScope,
              blobTagsString: toBlobTagsString(options.tags),
              spanOptions
            })];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_18 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_18.message
            }), e_18;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, AppendBlobClient2.prototype.createIfNotExists = function(options) {
    var _a, _b;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _c, span, spanOptions, conditions, res, e_19;
      return __generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            _c = createSpan("AppendBlobClient-createIfNotExists", options.tracingOptions), span = _c.span, spanOptions = _c.spanOptions, conditions = {ifNoneMatch: ETagAny}, _d.label = 1;
          case 1:
            return _d.trys.push([1, 3, 4, 5]), [4, this.create(__assign(__assign({}, options), {conditions, tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})}))];
          case 2:
            return res = _d.sent(), [2, __assign(__assign({succeeded: !0}, res), {
              _response: res._response
            })];
          case 3:
            if (e_19 = _d.sent(), ((_a = e_19.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "BlobAlreadyExists")
              return span.setStatus({
                code: import_api4.CanonicalCode.ALREADY_EXISTS,
                message: "Expected exception when creating a blob only if it does not already exist."
              }), [2, __assign(__assign({succeeded: !1}, (_b = e_19.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), {_response: e_19.response})];
            throw span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_19.message
            }), e_19;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, AppendBlobClient2.prototype.seal = function(options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_20;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            _b = createSpan("AppendBlobClient-seal", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, options.conditions = options.conditions || {}, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), [4, this.appendBlobContext.seal({
              abortSignal: options.abortSignal,
              appendPositionAccessConditions: options.conditions,
              leaseAccessConditions: options.conditions,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              spanOptions
            })];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_20 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_20.message
            }), e_20;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, AppendBlobClient2.prototype.appendBlock = function(body, contentLength2, options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_21;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            _b = createSpan("AppendBlobClient-appendBlock", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, options.conditions = options.conditions || {}, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps), [4, this.appendBlobContext.appendBlock(body, contentLength2, {
              abortSignal: options.abortSignal,
              appendPositionAccessConditions: options.conditions,
              leaseAccessConditions: options.conditions,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              onUploadProgress: options.onProgress,
              transactionalContentMD5: options.transactionalContentMD5,
              transactionalContentCrc64: options.transactionalContentCrc64,
              cpkInfo: options.customerProvidedKey,
              encryptionScope: options.encryptionScope,
              spanOptions
            })];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_21 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_21.message
            }), e_21;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, AppendBlobClient2.prototype.appendBlockFromURL = function(sourceURL, sourceOffset, count, options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_22;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            _b = createSpan("AppendBlobClient-appendBlockFromURL", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, options.conditions = options.conditions || {}, options.sourceConditions = options.sourceConditions || {}, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps), [4, this.appendBlobContext.appendBlockFromUrl(sourceURL, 0, {
              abortSignal: options.abortSignal,
              sourceRange: rangeToString({offset: sourceOffset, count}),
              sourceContentMD5: options.sourceContentMD5,
              sourceContentCrc64: options.sourceContentCrc64,
              leaseAccessConditions: options.conditions,
              appendPositionAccessConditions: options.conditions,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              sourceModifiedAccessConditions: {
                sourceIfMatch: options.sourceConditions.ifMatch,
                sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,
                sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,
                sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince
              },
              cpkInfo: options.customerProvidedKey,
              encryptionScope: options.encryptionScope,
              spanOptions
            })];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_22 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_22.message
            }), e_22;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, AppendBlobClient2;
}(BlobClient);
var BlockBlobClient = function(_super) {
  __extends(BlockBlobClient2, _super);
  function BlockBlobClient2(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
    var _this = this, pipeline, url2;
    if (options = options || {}, credentialOrPipelineOrContainerName instanceof Pipeline)
      url2 = urlOrConnectionString, pipeline = credentialOrPipelineOrContainerName;
    else if (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName))
      url2 = urlOrConnectionString, options = blobNameOrOptions, pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
    else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName != "string")
      url2 = urlOrConnectionString, pipeline = newPipeline(new AnonymousCredential(), options);
    else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName == "string" && blobNameOrOptions && typeof blobNameOrOptions == "string") {
      var containerName = credentialOrPipelineOrContainerName, blobName = blobNameOrOptions, extractedCreds = extractConnectionStringParts(urlOrConnectionString);
      if (extractedCreds.kind === "AccountConnString")
        if (isNode) {
          var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
          url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)), options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri), pipeline = newPipeline(sharedKeyCredential, options);
        } else
          throw new Error("Account connection string is only supported in Node.js environment");
      else if (extractedCreds.kind === "SASConnString")
        url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas, pipeline = newPipeline(new AnonymousCredential(), options);
      else
        throw new Error("Connection string must be either an Account connection string or a SAS connection string");
    } else
      throw new Error("Expecting non-empty strings for containerName and blobName parameters");
    return _this = _super.call(this, url2, pipeline) || this, _this.blockBlobContext = new BlockBlob(_this.storageClientContext), _this._blobContext = new Blob3(_this.storageClientContext), _this;
  }
  return __name(BlockBlobClient2, "BlockBlobClient"), BlockBlobClient2.prototype.withSnapshot = function(snapshot2) {
    return new BlockBlobClient2(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot2.length === 0 ? void 0 : snapshot2), this.pipeline);
  }, BlockBlobClient2.prototype.query = function(query, options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, response, e_23;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps), _b = createSpan("BlockBlobClient-query", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, _c.label = 1;
          case 1:
            if (_c.trys.push([1, 3, 4, 5]), !isNode)
              throw new Error("This operation currently is only supported in Node.js.");
            return [4, this._blobContext.query({
              abortSignal: options.abortSignal,
              queryRequest: {
                expression: query,
                inputSerialization: toQuerySerialization(options.inputTextConfiguration),
                outputSerialization: toQuerySerialization(options.outputTextConfiguration)
              },
              leaseAccessConditions: options.conditions,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              spanOptions
            })];
          case 2:
            return response = _c.sent(), [2, new BlobQueryResponse(response, {
              abortSignal: options.abortSignal,
              onProgress: options.onProgress,
              onError: options.onError
            })];
          case 3:
            throw e_23 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_23.message
            }), e_23;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlockBlobClient2.prototype.upload = function(body, contentLength2, options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_24;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            options.conditions = options.conditions || {}, _b = createSpan("BlockBlobClient-upload", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps), [4, this.blockBlobContext.upload(body, contentLength2, {
              abortSignal: options.abortSignal,
              blobHTTPHeaders: options.blobHTTPHeaders,
              leaseAccessConditions: options.conditions,
              metadata: options.metadata,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              onUploadProgress: options.onProgress,
              cpkInfo: options.customerProvidedKey,
              encryptionScope: options.encryptionScope,
              tier: toAccessTier(options.tier),
              blobTagsString: toBlobTagsString(options.tags),
              spanOptions
            })];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_24 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_24.message
            }), e_24;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlockBlobClient2.prototype.syncUploadFromURL = function(sourceURL, options) {
    var _a, _b, _c, _d, _e;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _f, span, spanOptions, e_25;
      return __generator(this, function(_g) {
        switch (_g.label) {
          case 0:
            options.conditions = options.conditions || {}, _f = createSpan("BlockBlobClient-syncUploadFromURL", options.tracingOptions), span = _f.span, spanOptions = _f.spanOptions, _g.label = 1;
          case 1:
            return _g.trys.push([1, 3, 4, 5]), ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps), [4, this.blockBlobContext.putBlobFromUrl(0, sourceURL, __assign(__assign({}, options), {leaseAccessConditions: options.conditions, modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: options.conditions.tagConditions}), sourceModifiedAccessConditions: {
              sourceIfMatch: (_a = options.sourceConditions) === null || _a === void 0 ? void 0 : _a.ifMatch,
              sourceIfModifiedSince: (_b = options.sourceConditions) === null || _b === void 0 ? void 0 : _b.ifModifiedSince,
              sourceIfNoneMatch: (_c = options.sourceConditions) === null || _c === void 0 ? void 0 : _c.ifNoneMatch,
              sourceIfUnmodifiedSince: (_d = options.sourceConditions) === null || _d === void 0 ? void 0 : _d.ifUnmodifiedSince,
              sourceIfTags: (_e = options.sourceConditions) === null || _e === void 0 ? void 0 : _e.tagConditions
            }, cpkInfo: options.customerProvidedKey, tier: toAccessTier(options.tier), blobTagsString: toBlobTagsString(options.tags), spanOptions}))];
          case 2:
            return [2, _g.sent()];
          case 3:
            throw e_25 = _g.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_25.message
            }), e_25;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlockBlobClient2.prototype.stageBlock = function(blockId2, body, contentLength2, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, e_26;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("BlockBlobClient-stageBlock", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps), [4, this.blockBlobContext.stageBlock(blockId2, contentLength2, body, {
              abortSignal: options.abortSignal,
              leaseAccessConditions: options.conditions,
              onUploadProgress: options.onProgress,
              transactionalContentMD5: options.transactionalContentMD5,
              transactionalContentCrc64: options.transactionalContentCrc64,
              cpkInfo: options.customerProvidedKey,
              encryptionScope: options.encryptionScope,
              spanOptions
            })];
          case 2:
            return [2, _b.sent()];
          case 3:
            throw e_26 = _b.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_26.message
            }), e_26;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlockBlobClient2.prototype.stageBlockFromURL = function(blockId2, sourceURL, offset, count, options) {
    return offset === void 0 && (offset = 0), options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, e_27;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("BlockBlobClient-stageBlockFromURL", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps), [4, this.blockBlobContext.stageBlockFromURL(blockId2, 0, sourceURL, {
              abortSignal: options.abortSignal,
              leaseAccessConditions: options.conditions,
              sourceContentMD5: options.sourceContentMD5,
              sourceContentCrc64: options.sourceContentCrc64,
              sourceRange: offset === 0 && !count ? void 0 : rangeToString({offset, count}),
              cpkInfo: options.customerProvidedKey,
              encryptionScope: options.encryptionScope,
              spanOptions
            })];
          case 2:
            return [2, _b.sent()];
          case 3:
            throw e_27 = _b.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_27.message
            }), e_27;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlockBlobClient2.prototype.commitBlockList = function(blocks, options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_28;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            options.conditions = options.conditions || {}, _b = createSpan("BlockBlobClient-commitBlockList", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps), [4, this.blockBlobContext.commitBlockList({latest: blocks}, {
              abortSignal: options.abortSignal,
              blobHTTPHeaders: options.blobHTTPHeaders,
              leaseAccessConditions: options.conditions,
              metadata: options.metadata,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              cpkInfo: options.customerProvidedKey,
              encryptionScope: options.encryptionScope,
              tier: toAccessTier(options.tier),
              blobTagsString: toBlobTagsString(options.tags),
              spanOptions
            })];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_28 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_28.message
            }), e_28;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlockBlobClient2.prototype.getBlockList = function(listType2, options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, res, e_29;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            _b = createSpan("BlockBlobClient-getBlockList", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), [4, this.blockBlobContext.getBlockList(listType2, {
              abortSignal: options.abortSignal,
              leaseAccessConditions: options.conditions,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              spanOptions
            })];
          case 2:
            return res = _c.sent(), res.committedBlocks || (res.committedBlocks = []), res.uncommittedBlocks || (res.uncommittedBlocks = []), [2, res];
          case 3:
            throw e_29 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_29.message
            }), e_29;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlockBlobClient2.prototype.uploadData = function(data, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, buffer_1, browserBlob_1;
      return __generator(this, function(_b) {
        _a = createSpan("BlockBlobClient-uploadData", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
        try {
          return isNode ? (data instanceof Buffer ? buffer_1 = data : data instanceof ArrayBuffer ? buffer_1 = Buffer.from(data) : (data = data, buffer_1 = Buffer.from(data.buffer, data.byteOffset, data.byteLength)), [2, this.uploadSeekableInternal(function(offset, size) {
            return buffer_1.slice(offset, offset + size);
          }, buffer_1.byteLength, __assign(__assign({}, options), {tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})}))]) : (browserBlob_1 = new Blob([data]), [2, this.uploadSeekableInternal(function(offset, size) {
            return browserBlob_1.slice(offset, offset + size);
          }, browserBlob_1.size, __assign(__assign({}, options), {tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})}))]);
        } catch (e) {
          throw span.setStatus({
            code: import_api4.CanonicalCode.UNKNOWN,
            message: e.message
          }), e;
        } finally {
          span.end();
        }
        return [2];
      });
    });
  }, BlockBlobClient2.prototype.uploadBrowserData = function(browserData, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, browserBlob_2, e_30;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("BlockBlobClient-uploadBrowserData", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), browserBlob_2 = new Blob([browserData]), [4, this.uploadSeekableInternal(function(offset, size) {
              return browserBlob_2.slice(offset, offset + size);
            }, browserBlob_2.size, __assign(__assign({}, options), {tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})}))];
          case 2:
            return [2, _b.sent()];
          case 3:
            throw e_30 = _b.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_30.message
            }), e_30;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlockBlobClient2.prototype.uploadSeekableInternal = function(bodyFactory, size, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, numBlocks_1, blockList_1, blockIDPrefix_1, transferProgress_2, batch, _loop_2, i, e_31, _this = this;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            if (options.blockSize || (options.blockSize = 0), options.blockSize < 0 || options.blockSize > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES)
              throw new RangeError("blockSize option must be >= 0 and <= " + BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES);
            if (options.maxSingleShotSize !== 0 && !options.maxSingleShotSize && (options.maxSingleShotSize = BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES), options.maxSingleShotSize < 0 || options.maxSingleShotSize > BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES)
              throw new RangeError("maxSingleShotSize option must be >= 0 and <= " + BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES);
            if (options.blockSize === 0) {
              if (size > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES * BLOCK_BLOB_MAX_BLOCKS)
                throw new RangeError(size + " is too larger to upload to a block blob.");
              size > options.maxSingleShotSize && (options.blockSize = Math.ceil(size / BLOCK_BLOB_MAX_BLOCKS), options.blockSize < DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES && (options.blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES));
            }
            options.blobHTTPHeaders || (options.blobHTTPHeaders = {}), options.conditions || (options.conditions = {}), _a = createSpan("BlockBlobClient-uploadSeekableInternal", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 5, 6, 7]), size <= options.maxSingleShotSize ? [4, this.upload(bodyFactory(0, size), size, __assign(__assign({}, options), {tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})}))] : [3, 3];
          case 2:
            return [2, _b.sent()];
          case 3:
            if (numBlocks_1 = Math.floor((size - 1) / options.blockSize) + 1, numBlocks_1 > BLOCK_BLOB_MAX_BLOCKS)
              throw new RangeError("The buffer's size is too big or the BlockSize is too small;" + ("the number of blocks must be <= " + BLOCK_BLOB_MAX_BLOCKS));
            for (blockList_1 = [], blockIDPrefix_1 = generateUuid(), transferProgress_2 = 0, batch = new Batch(options.concurrency), _loop_2 = /* @__PURE__ */ __name(function(i2) {
              batch.addOperation(function() {
                return __awaiter(_this, void 0, void 0, function() {
                  var blockID, start, end, contentLength2;
                  return __generator(this, function(_a2) {
                    switch (_a2.label) {
                      case 0:
                        return blockID = generateBlockID(blockIDPrefix_1, i2), start = options.blockSize * i2, end = i2 === numBlocks_1 - 1 ? size : start + options.blockSize, contentLength2 = end - start, blockList_1.push(blockID), [4, this.stageBlock(blockID, bodyFactory(start, contentLength2), contentLength2, {
                          abortSignal: options.abortSignal,
                          conditions: options.conditions,
                          encryptionScope: options.encryptionScope,
                          tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})
                        })];
                      case 1:
                        return _a2.sent(), transferProgress_2 += contentLength2, options.onProgress && options.onProgress({
                          loadedBytes: transferProgress_2
                        }), [2];
                    }
                  });
                });
              });
            }, "_loop_2"), i = 0; i < numBlocks_1; i++)
              _loop_2(i);
            return [4, batch.do()];
          case 4:
            return _b.sent(), [2, this.commitBlockList(blockList_1, __assign(__assign({}, options), {tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})}))];
          case 5:
            throw e_31 = _b.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_31.message
            }), e_31;
          case 6:
            return span.end(), [7];
          case 7:
            return [2];
        }
      });
    });
  }, BlockBlobClient2.prototype.uploadFile = function(filePath, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, size, e_32;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("BlockBlobClient-uploadFile", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 4, 5, 6]), [4, fsStat(filePath)];
          case 2:
            return size = _b.sent().size, [4, this.uploadSeekableInternal(function(offset, count) {
              return function() {
                return fsCreateReadStream(filePath, {
                  autoClose: !0,
                  end: count ? offset + count - 1 : Infinity,
                  start: offset
                });
              };
            }, size, __assign(__assign({}, options), {tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})}))];
          case 3:
            return [2, _b.sent()];
          case 4:
            throw e_32 = _b.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_32.message
            }), e_32;
          case 5:
            return span.end(), [7];
          case 6:
            return [2];
        }
      });
    });
  }, BlockBlobClient2.prototype.uploadStream = function(stream, bufferSize, maxConcurrency, options) {
    return bufferSize === void 0 && (bufferSize = DEFAULT_BLOCK_BUFFER_SIZE_BYTES), maxConcurrency === void 0 && (maxConcurrency = 5), options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, blockNum_1, blockIDPrefix_2, transferProgress_3, blockList_2, scheduler, e_33, _this = this;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            options.blobHTTPHeaders || (options.blobHTTPHeaders = {}), options.conditions || (options.conditions = {}), _a = createSpan("BlockBlobClient-uploadStream", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 4, 5, 6]), blockNum_1 = 0, blockIDPrefix_2 = generateUuid(), transferProgress_3 = 0, blockList_2 = [], scheduler = new BufferScheduler(stream, bufferSize, maxConcurrency, function(body, length) {
              return __awaiter(_this, void 0, void 0, function() {
                var blockID;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      return blockID = generateBlockID(blockIDPrefix_2, blockNum_1), blockList_2.push(blockID), blockNum_1++, [4, this.stageBlock(blockID, body, length, {
                        conditions: options.conditions,
                        encryptionScope: options.encryptionScope,
                        tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})
                      })];
                    case 1:
                      return _a2.sent(), transferProgress_3 += length, options.onProgress && options.onProgress({loadedBytes: transferProgress_3}), [2];
                  }
                });
              });
            }, Math.ceil(maxConcurrency / 4 * 3)), [4, scheduler.do()];
          case 2:
            return _b.sent(), [4, this.commitBlockList(blockList_2, __assign(__assign({}, options), {tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})}))];
          case 3:
            return [2, _b.sent()];
          case 4:
            throw e_33 = _b.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_33.message
            }), e_33;
          case 5:
            return span.end(), [7];
          case 6:
            return [2];
        }
      });
    });
  }, BlockBlobClient2;
}(BlobClient);
var PageBlobClient = function(_super) {
  __extends(PageBlobClient2, _super);
  function PageBlobClient2(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
    var _this = this, pipeline, url2;
    if (options = options || {}, credentialOrPipelineOrContainerName instanceof Pipeline)
      url2 = urlOrConnectionString, pipeline = credentialOrPipelineOrContainerName;
    else if (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName))
      url2 = urlOrConnectionString, options = blobNameOrOptions, pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
    else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName != "string")
      url2 = urlOrConnectionString, pipeline = newPipeline(new AnonymousCredential(), options);
    else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName == "string" && blobNameOrOptions && typeof blobNameOrOptions == "string") {
      var containerName = credentialOrPipelineOrContainerName, blobName = blobNameOrOptions, extractedCreds = extractConnectionStringParts(urlOrConnectionString);
      if (extractedCreds.kind === "AccountConnString")
        if (isNode) {
          var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
          url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)), options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri), pipeline = newPipeline(sharedKeyCredential, options);
        } else
          throw new Error("Account connection string is only supported in Node.js environment");
      else if (extractedCreds.kind === "SASConnString")
        url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas, pipeline = newPipeline(new AnonymousCredential(), options);
      else
        throw new Error("Connection string must be either an Account connection string or a SAS connection string");
    } else
      throw new Error("Expecting non-empty strings for containerName and blobName parameters");
    return _this = _super.call(this, url2, pipeline) || this, _this.pageBlobContext = new PageBlob(_this.storageClientContext), _this;
  }
  return __name(PageBlobClient2, "PageBlobClient"), PageBlobClient2.prototype.withSnapshot = function(snapshot2) {
    return new PageBlobClient2(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot2.length === 0 ? void 0 : snapshot2), this.pipeline);
  }, PageBlobClient2.prototype.create = function(size, options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_34;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            options.conditions = options.conditions || {}, _b = createSpan("PageBlobClient-create", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps), [4, this.pageBlobContext.create(0, size, {
              abortSignal: options.abortSignal,
              blobHTTPHeaders: options.blobHTTPHeaders,
              blobSequenceNumber: options.blobSequenceNumber,
              leaseAccessConditions: options.conditions,
              metadata: options.metadata,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              cpkInfo: options.customerProvidedKey,
              encryptionScope: options.encryptionScope,
              tier: toAccessTier(options.tier),
              blobTagsString: toBlobTagsString(options.tags),
              spanOptions
            })];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_34 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_34.message
            }), e_34;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, PageBlobClient2.prototype.createIfNotExists = function(size, options) {
    var _a, _b;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _c, span, spanOptions, conditions, res, e_35;
      return __generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            _c = createSpan("PageBlobClient-createIfNotExists", options.tracingOptions), span = _c.span, spanOptions = _c.spanOptions, _d.label = 1;
          case 1:
            return _d.trys.push([1, 3, 4, 5]), conditions = {ifNoneMatch: ETagAny}, [4, this.create(size, __assign(__assign({}, options), {conditions, tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})}))];
          case 2:
            return res = _d.sent(), [2, __assign(__assign({succeeded: !0}, res), {
              _response: res._response
            })];
          case 3:
            if (e_35 = _d.sent(), ((_a = e_35.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "BlobAlreadyExists")
              return span.setStatus({
                code: import_api4.CanonicalCode.ALREADY_EXISTS,
                message: "Expected exception when creating a blob only if it does not already exist."
              }), [2, __assign(__assign({succeeded: !1}, (_b = e_35.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), {_response: e_35.response})];
            throw span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_35.message
            }), e_35;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, PageBlobClient2.prototype.uploadPages = function(body, offset, count, options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_36;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            options.conditions = options.conditions || {}, _b = createSpan("PageBlobClient-uploadPages", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps), [4, this.pageBlobContext.uploadPages(body, count, {
              abortSignal: options.abortSignal,
              leaseAccessConditions: options.conditions,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              onUploadProgress: options.onProgress,
              range: rangeToString({offset, count}),
              sequenceNumberAccessConditions: options.conditions,
              transactionalContentMD5: options.transactionalContentMD5,
              transactionalContentCrc64: options.transactionalContentCrc64,
              cpkInfo: options.customerProvidedKey,
              encryptionScope: options.encryptionScope,
              spanOptions
            })];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_36 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_36.message
            }), e_36;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, PageBlobClient2.prototype.uploadPagesFromURL = function(sourceURL, sourceOffset, destOffset, count, options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_37;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            options.conditions = options.conditions || {}, options.sourceConditions = options.sourceConditions || {}, _b = createSpan("PageBlobClient-uploadPagesFromURL", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps), [4, this.pageBlobContext.uploadPagesFromURL(sourceURL, rangeToString({offset: sourceOffset, count}), 0, rangeToString({offset: destOffset, count}), {
              abortSignal: options.abortSignal,
              sourceContentMD5: options.sourceContentMD5,
              sourceContentCrc64: options.sourceContentCrc64,
              leaseAccessConditions: options.conditions,
              sequenceNumberAccessConditions: options.conditions,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              sourceModifiedAccessConditions: {
                sourceIfMatch: options.sourceConditions.ifMatch,
                sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,
                sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,
                sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince
              },
              cpkInfo: options.customerProvidedKey,
              encryptionScope: options.encryptionScope,
              spanOptions
            })];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_37 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_37.message
            }), e_37;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, PageBlobClient2.prototype.clearPages = function(offset, count, options) {
    var _a;
    return offset === void 0 && (offset = 0), options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_38;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            options.conditions = options.conditions || {}, _b = createSpan("PageBlobClient-clearPages", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), [4, this.pageBlobContext.clearPages(0, {
              abortSignal: options.abortSignal,
              leaseAccessConditions: options.conditions,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              range: rangeToString({offset, count}),
              sequenceNumberAccessConditions: options.conditions,
              cpkInfo: options.customerProvidedKey,
              encryptionScope: options.encryptionScope,
              spanOptions
            })];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_38 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_38.message
            }), e_38;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, PageBlobClient2.prototype.getPageRanges = function(offset, count, options) {
    var _a;
    return offset === void 0 && (offset = 0), options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_39;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            options.conditions = options.conditions || {}, _b = createSpan("PageBlobClient-getPageRanges", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), [4, this.pageBlobContext.getPageRanges({
              abortSignal: options.abortSignal,
              leaseAccessConditions: options.conditions,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              range: rangeToString({offset, count}),
              spanOptions
            }).then(rangeResponseFromModel)];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_39 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_39.message
            }), e_39;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, PageBlobClient2.prototype.getPageRangesDiff = function(offset, count, prevSnapshot, options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_40;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            options.conditions = options.conditions || {}, _b = createSpan("PageBlobClient-getPageRangesDiff", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), [4, this.pageBlobContext.getPageRangesDiff({
              abortSignal: options.abortSignal,
              leaseAccessConditions: options.conditions,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              prevsnapshot: prevSnapshot,
              range: rangeToString({offset, count}),
              spanOptions
            }).then(rangeResponseFromModel)];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_40 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_40.message
            }), e_40;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, PageBlobClient2.prototype.getPageRangesDiffForManagedDisks = function(offset, count, prevSnapshotUrl2, options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_41;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            options.conditions = options.conditions || {}, _b = createSpan("PageBlobClient-GetPageRangesDiffForManagedDisks", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), [4, this.pageBlobContext.getPageRangesDiff({
              abortSignal: options.abortSignal,
              leaseAccessConditions: options.conditions,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              prevSnapshotUrl: prevSnapshotUrl2,
              range: rangeToString({offset, count}),
              spanOptions
            }).then(rangeResponseFromModel)];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_41 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_41.message
            }), e_41;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, PageBlobClient2.prototype.resize = function(size, options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_42;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            options.conditions = options.conditions || {}, _b = createSpan("PageBlobClient-resize", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), [4, this.pageBlobContext.resize(size, {
              abortSignal: options.abortSignal,
              leaseAccessConditions: options.conditions,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              encryptionScope: options.encryptionScope,
              spanOptions
            })];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_42 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_42.message
            }), e_42;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, PageBlobClient2.prototype.updateSequenceNumber = function(sequenceNumberAction2, sequenceNumber, options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_43;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            options.conditions = options.conditions || {}, _b = createSpan("PageBlobClient-updateSequenceNumber", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), [4, this.pageBlobContext.updateSequenceNumber(sequenceNumberAction2, {
              abortSignal: options.abortSignal,
              blobSequenceNumber: sequenceNumber,
              leaseAccessConditions: options.conditions,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              spanOptions
            })];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_43 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_43.message
            }), e_43;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, PageBlobClient2.prototype.startCopyIncremental = function(copySource2, options) {
    var _a;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _b, span, spanOptions, e_44;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            _b = createSpan("PageBlobClient-startCopyIncremental", options.tracingOptions), span = _b.span, spanOptions = _b.spanOptions, _c.label = 1;
          case 1:
            return _c.trys.push([1, 3, 4, 5]), [4, this.pageBlobContext.copyIncremental(copySource2, {
              abortSignal: options.abortSignal,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions}),
              spanOptions
            })];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_44 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_44.message
            }), e_44;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, PageBlobClient2;
}(BlobClient);
var BlobLeaseClient = function() {
  function BlobLeaseClient2(client, leaseId) {
    var clientContext = new StorageClientContext(client.url, client.pipeline.toServiceClientOptions());
    this._url = client.url, client instanceof ContainerClient ? (this._isContainer = !0, this._containerOrBlobOperation = new Container(clientContext)) : (this._isContainer = !1, this._containerOrBlobOperation = new Blob3(clientContext)), leaseId || (leaseId = generateUuid()), this._leaseId = leaseId;
  }
  return __name(BlobLeaseClient2, "BlobLeaseClient"), Object.defineProperty(BlobLeaseClient2.prototype, "leaseId", {
    get: function() {
      return this._leaseId;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(BlobLeaseClient2.prototype, "url", {
    get: function() {
      return this._url;
    },
    enumerable: !1,
    configurable: !0
  }), BlobLeaseClient2.prototype.acquireLease = function(duration2, options) {
    var _a, _b, _c, _d, _e, _f;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _g, span, spanOptions, e_45;
      return __generator(this, function(_h) {
        switch (_h.label) {
          case 0:
            if (_g = createSpan("BlobLeaseClient-acquireLease", options.tracingOptions), span = _g.span, spanOptions = _g.spanOptions, this._isContainer && (((_a = options.conditions) === null || _a === void 0 ? void 0 : _a.ifMatch) && ((_b = options.conditions) === null || _b === void 0 ? void 0 : _b.ifMatch) !== ETagNone || ((_c = options.conditions) === null || _c === void 0 ? void 0 : _c.ifNoneMatch) && ((_d = options.conditions) === null || _d === void 0 ? void 0 : _d.ifNoneMatch) !== ETagNone || ((_e = options.conditions) === null || _e === void 0 ? void 0 : _e.tagConditions)))
              throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
            _h.label = 1;
          case 1:
            return _h.trys.push([1, 3, 4, 5]), [4, this._containerOrBlobOperation.acquireLease({
              abortSignal: options.abortSignal,
              duration: duration2,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_f = options.conditions) === null || _f === void 0 ? void 0 : _f.tagConditions}),
              proposedLeaseId: this._leaseId,
              spanOptions
            })];
          case 2:
            return [2, _h.sent()];
          case 3:
            throw e_45 = _h.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_45.message
            }), e_45;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobLeaseClient2.prototype.changeLease = function(proposedLeaseId, options) {
    var _a, _b, _c, _d, _e, _f;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _g, span, spanOptions, response, e_46;
      return __generator(this, function(_h) {
        switch (_h.label) {
          case 0:
            if (_g = createSpan("BlobLeaseClient-changeLease", options.tracingOptions), span = _g.span, spanOptions = _g.spanOptions, this._isContainer && (((_a = options.conditions) === null || _a === void 0 ? void 0 : _a.ifMatch) && ((_b = options.conditions) === null || _b === void 0 ? void 0 : _b.ifMatch) !== ETagNone || ((_c = options.conditions) === null || _c === void 0 ? void 0 : _c.ifNoneMatch) && ((_d = options.conditions) === null || _d === void 0 ? void 0 : _d.ifNoneMatch) !== ETagNone || ((_e = options.conditions) === null || _e === void 0 ? void 0 : _e.tagConditions)))
              throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
            _h.label = 1;
          case 1:
            return _h.trys.push([1, 3, 4, 5]), [4, this._containerOrBlobOperation.changeLease(this._leaseId, proposedLeaseId, {
              abortSignal: options.abortSignal,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_f = options.conditions) === null || _f === void 0 ? void 0 : _f.tagConditions}),
              spanOptions
            })];
          case 2:
            return response = _h.sent(), this._leaseId = proposedLeaseId, [2, response];
          case 3:
            throw e_46 = _h.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_46.message
            }), e_46;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobLeaseClient2.prototype.releaseLease = function(options) {
    var _a, _b, _c, _d, _e, _f;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _g, span, spanOptions, e_47;
      return __generator(this, function(_h) {
        switch (_h.label) {
          case 0:
            if (_g = createSpan("BlobLeaseClient-releaseLease", options.tracingOptions), span = _g.span, spanOptions = _g.spanOptions, this._isContainer && (((_a = options.conditions) === null || _a === void 0 ? void 0 : _a.ifMatch) && ((_b = options.conditions) === null || _b === void 0 ? void 0 : _b.ifMatch) !== ETagNone || ((_c = options.conditions) === null || _c === void 0 ? void 0 : _c.ifNoneMatch) && ((_d = options.conditions) === null || _d === void 0 ? void 0 : _d.ifNoneMatch) !== ETagNone || ((_e = options.conditions) === null || _e === void 0 ? void 0 : _e.tagConditions)))
              throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
            _h.label = 1;
          case 1:
            return _h.trys.push([1, 3, 4, 5]), [4, this._containerOrBlobOperation.releaseLease(this._leaseId, {
              abortSignal: options.abortSignal,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_f = options.conditions) === null || _f === void 0 ? void 0 : _f.tagConditions}),
              spanOptions
            })];
          case 2:
            return [2, _h.sent()];
          case 3:
            throw e_47 = _h.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_47.message
            }), e_47;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobLeaseClient2.prototype.renewLease = function(options) {
    var _a, _b, _c, _d, _e, _f;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _g, span, spanOptions, e_48;
      return __generator(this, function(_h) {
        switch (_h.label) {
          case 0:
            if (_g = createSpan("BlobLeaseClient-renewLease", options.tracingOptions), span = _g.span, spanOptions = _g.spanOptions, this._isContainer && (((_a = options.conditions) === null || _a === void 0 ? void 0 : _a.ifMatch) && ((_b = options.conditions) === null || _b === void 0 ? void 0 : _b.ifMatch) !== ETagNone || ((_c = options.conditions) === null || _c === void 0 ? void 0 : _c.ifNoneMatch) && ((_d = options.conditions) === null || _d === void 0 ? void 0 : _d.ifNoneMatch) !== ETagNone || ((_e = options.conditions) === null || _e === void 0 ? void 0 : _e.tagConditions)))
              throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
            _h.label = 1;
          case 1:
            return _h.trys.push([1, 3, 4, 5]), [4, this._containerOrBlobOperation.renewLease(this._leaseId, {
              abortSignal: options.abortSignal,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_f = options.conditions) === null || _f === void 0 ? void 0 : _f.tagConditions}),
              spanOptions
            })];
          case 2:
            return [2, _h.sent()];
          case 3:
            throw e_48 = _h.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_48.message
            }), e_48;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobLeaseClient2.prototype.breakLease = function(breakPeriod2, options) {
    var _a, _b, _c, _d, _e, _f;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _g, span, spanOptions, operationOptions, e_49;
      return __generator(this, function(_h) {
        switch (_h.label) {
          case 0:
            if (_g = createSpan("BlobLeaseClient-breakLease", options.tracingOptions), span = _g.span, spanOptions = _g.spanOptions, this._isContainer && (((_a = options.conditions) === null || _a === void 0 ? void 0 : _a.ifMatch) && ((_b = options.conditions) === null || _b === void 0 ? void 0 : _b.ifMatch) !== ETagNone || ((_c = options.conditions) === null || _c === void 0 ? void 0 : _c.ifNoneMatch) && ((_d = options.conditions) === null || _d === void 0 ? void 0 : _d.ifNoneMatch) !== ETagNone || ((_e = options.conditions) === null || _e === void 0 ? void 0 : _e.tagConditions)))
              throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
            _h.label = 1;
          case 1:
            return _h.trys.push([1, 3, 4, 5]), operationOptions = {
              abortSignal: options.abortSignal,
              breakPeriod: breakPeriod2,
              modifiedAccessConditions: __assign(__assign({}, options.conditions), {ifTags: (_f = options.conditions) === null || _f === void 0 ? void 0 : _f.tagConditions}),
              spanOptions
            }, [4, this._containerOrBlobOperation.breakLease(operationOptions)];
          case 2:
            return [2, _h.sent()];
          case 3:
            throw e_49 = _h.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_49.message
            }), e_49;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobLeaseClient2;
}();
var ContainerClient = function(_super) {
  __extends(ContainerClient2, _super);
  function ContainerClient2(urlOrConnectionString, credentialOrPipelineOrContainerName, options) {
    var _this = this, pipeline, url2;
    if (options = options || {}, credentialOrPipelineOrContainerName instanceof Pipeline)
      url2 = urlOrConnectionString, pipeline = credentialOrPipelineOrContainerName;
    else if (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName))
      url2 = urlOrConnectionString, pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
    else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName != "string")
      url2 = urlOrConnectionString, pipeline = newPipeline(new AnonymousCredential(), options);
    else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName == "string") {
      var containerName = credentialOrPipelineOrContainerName, extractedCreds = extractConnectionStringParts(urlOrConnectionString);
      if (extractedCreds.kind === "AccountConnString")
        if (isNode) {
          var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
          url2 = appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri), pipeline = newPipeline(sharedKeyCredential, options);
        } else
          throw new Error("Account connection string is only supported in Node.js environment");
      else if (extractedCreds.kind === "SASConnString")
        url2 = appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)) + "?" + extractedCreds.accountSas, pipeline = newPipeline(new AnonymousCredential(), options);
      else
        throw new Error("Connection string must be either an Account connection string or a SAS connection string");
    } else
      throw new Error("Expecting non-empty strings for containerName parameter");
    return _this = _super.call(this, url2, pipeline) || this, _this._containerName = _this.getContainerNameFromUrl(), _this.containerContext = new Container(_this.storageClientContext), _this;
  }
  return __name(ContainerClient2, "ContainerClient"), Object.defineProperty(ContainerClient2.prototype, "containerName", {
    get: function() {
      return this._containerName;
    },
    enumerable: !1,
    configurable: !0
  }), ContainerClient2.prototype.create = function(options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, e_50;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("ContainerClient-create", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), [4, this.containerContext.create(__assign(__assign({}, options), {spanOptions}))];
          case 2:
            return [2, _b.sent()];
          case 3:
            throw e_50 = _b.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_50.message
            }), e_50;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, ContainerClient2.prototype.createIfNotExists = function(options) {
    var _a, _b;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _c, span, spanOptions, res, e_51;
      return __generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            _c = createSpan("ContainerClient-createIfNotExists", options.tracingOptions), span = _c.span, spanOptions = _c.spanOptions, _d.label = 1;
          case 1:
            return _d.trys.push([1, 3, 4, 5]), [4, this.create(__assign(__assign({}, options), {tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})}))];
          case 2:
            return res = _d.sent(), [2, __assign(__assign({succeeded: !0}, res), {
              _response: res._response
            })];
          case 3:
            if (e_51 = _d.sent(), ((_a = e_51.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "ContainerAlreadyExists")
              return span.setStatus({
                code: import_api4.CanonicalCode.ALREADY_EXISTS,
                message: "Expected exception when creating a container only if it does not already exist."
              }), [2, __assign(__assign({succeeded: !1}, (_b = e_51.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), {_response: e_51.response})];
            throw span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_51.message
            }), e_51;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, ContainerClient2.prototype.exists = function(options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, e_52;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("ContainerClient-exists", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), [4, this.getProperties({
              abortSignal: options.abortSignal,
              tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})
            })];
          case 2:
            return _b.sent(), [2, !0];
          case 3:
            if (e_52 = _b.sent(), e_52.statusCode === 404)
              return span.setStatus({
                code: import_api4.CanonicalCode.NOT_FOUND,
                message: "Expected exception when checking container existence"
              }), [2, !1];
            throw span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_52.message
            }), e_52;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, ContainerClient2.prototype.getBlobClient = function(blobName) {
    return new BlobClient(appendToURLPath(this.url, encodeURIComponent(blobName)), this.pipeline);
  }, ContainerClient2.prototype.getAppendBlobClient = function(blobName) {
    return new AppendBlobClient(appendToURLPath(this.url, encodeURIComponent(blobName)), this.pipeline);
  }, ContainerClient2.prototype.getBlockBlobClient = function(blobName) {
    return new BlockBlobClient(appendToURLPath(this.url, encodeURIComponent(blobName)), this.pipeline);
  }, ContainerClient2.prototype.getPageBlobClient = function(blobName) {
    return new PageBlobClient(appendToURLPath(this.url, encodeURIComponent(blobName)), this.pipeline);
  }, ContainerClient2.prototype.getProperties = function(options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, e_53;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            options.conditions || (options.conditions = {}), _a = createSpan("ContainerClient-getProperties", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), [4, this.containerContext.getProperties(__assign(__assign({abortSignal: options.abortSignal}, options.conditions), {spanOptions}))];
          case 2:
            return [2, _b.sent()];
          case 3:
            throw e_53 = _b.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_53.message
            }), e_53;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, ContainerClient2.prototype.delete = function(options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, e_54;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            options.conditions || (options.conditions = {}), _a = createSpan("ContainerClient-delete", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), [4, this.containerContext.deleteMethod({
              abortSignal: options.abortSignal,
              leaseAccessConditions: options.conditions,
              modifiedAccessConditions: options.conditions,
              spanOptions
            })];
          case 2:
            return [2, _b.sent()];
          case 3:
            throw e_54 = _b.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_54.message
            }), e_54;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, ContainerClient2.prototype.deleteIfExists = function(options) {
    var _a, _b;
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _c, span, spanOptions, res, e_55;
      return __generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            _c = createSpan("ContainerClient-deleteIfExists", options.tracingOptions), span = _c.span, spanOptions = _c.spanOptions, _d.label = 1;
          case 1:
            return _d.trys.push([1, 3, 4, 5]), [4, this.delete(__assign(__assign({}, options), {tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})}))];
          case 2:
            return res = _d.sent(), [2, __assign(__assign({succeeded: !0}, res), {
              _response: res._response
            })];
          case 3:
            if (e_55 = _d.sent(), ((_a = e_55.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "ContainerNotFound")
              return span.setStatus({
                code: import_api4.CanonicalCode.NOT_FOUND,
                message: "Expected exception when deleting a container only if it exists."
              }), [2, __assign(__assign({succeeded: !1}, (_b = e_55.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), {_response: e_55.response})];
            throw span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_55.message
            }), e_55;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, ContainerClient2.prototype.setMetadata = function(metadata2, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, e_56;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            if (options.conditions || (options.conditions = {}), options.conditions.ifUnmodifiedSince)
              throw new RangeError("the IfUnmodifiedSince must have their default values because they are ignored by the blob service");
            _a = createSpan("ContainerClient-setMetadata", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), [4, this.containerContext.setMetadata({
              abortSignal: options.abortSignal,
              leaseAccessConditions: options.conditions,
              metadata: metadata2,
              modifiedAccessConditions: options.conditions,
              spanOptions
            })];
          case 2:
            return [2, _b.sent()];
          case 3:
            throw e_56 = _b.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_56.message
            }), e_56;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, ContainerClient2.prototype.getAccessPolicy = function(options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, response, res, _i, response_1, identifier, accessPolicy, e_57;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            options.conditions || (options.conditions = {}), _a = createSpan("ContainerClient-getAccessPolicy", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), [4, this.containerContext.getAccessPolicy({
              abortSignal: options.abortSignal,
              leaseAccessConditions: options.conditions,
              spanOptions
            })];
          case 2:
            for (response = _b.sent(), res = {
              _response: response._response,
              blobPublicAccess: response.blobPublicAccess,
              date: response.date,
              etag: response.etag,
              errorCode: response.errorCode,
              lastModified: response.lastModified,
              requestId: response.requestId,
              clientRequestId: response.clientRequestId,
              signedIdentifiers: [],
              version: response.version
            }, _i = 0, response_1 = response; _i < response_1.length; _i++)
              identifier = response_1[_i], accessPolicy = void 0, identifier.accessPolicy && (accessPolicy = {
                permissions: identifier.accessPolicy.permissions
              }, identifier.accessPolicy.expiresOn && (accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn)), identifier.accessPolicy.startsOn && (accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn))), res.signedIdentifiers.push({
                accessPolicy,
                id: identifier.id
              });
            return [2, res];
          case 3:
            throw e_57 = _b.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_57.message
            }), e_57;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, ContainerClient2.prototype.setAccessPolicy = function(access2, containerAcl, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, acl, _i, _b, identifier, e_58;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            options.conditions = options.conditions || {}, _a = createSpan("ContainerClient-setAccessPolicy", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _c.label = 1;
          case 1:
            for (_c.trys.push([1, 3, 4, 5]), acl = [], _i = 0, _b = containerAcl || []; _i < _b.length; _i++)
              identifier = _b[_i], acl.push({
                accessPolicy: {
                  expiresOn: identifier.accessPolicy.expiresOn ? truncatedISO8061Date(identifier.accessPolicy.expiresOn) : "",
                  permissions: identifier.accessPolicy.permissions,
                  startsOn: identifier.accessPolicy.startsOn ? truncatedISO8061Date(identifier.accessPolicy.startsOn) : ""
                },
                id: identifier.id
              });
            return [4, this.containerContext.setAccessPolicy({
              abortSignal: options.abortSignal,
              access: access2,
              containerAcl: acl,
              leaseAccessConditions: options.conditions,
              modifiedAccessConditions: options.conditions,
              spanOptions
            })];
          case 2:
            return [2, _c.sent()];
          case 3:
            throw e_58 = _c.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_58.message
            }), e_58;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, ContainerClient2.prototype.getBlobLeaseClient = function(proposeLeaseId) {
    return new BlobLeaseClient(this, proposeLeaseId);
  }, ContainerClient2.prototype.uploadBlockBlob = function(blobName, body, contentLength2, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, blockBlobClient, response, e_59;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("ContainerClient-uploadBlockBlob", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), blockBlobClient = this.getBlockBlobClient(blobName), [4, blockBlobClient.upload(body, contentLength2, __assign(__assign({}, options), {tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})}))];
          case 2:
            return response = _b.sent(), [2, {
              blockBlobClient,
              response
            }];
          case 3:
            throw e_59 = _b.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_59.message
            }), e_59;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, ContainerClient2.prototype.deleteBlob = function(blobName, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, blobClient, e_60;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("ContainerClient-deleteBlob", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), blobClient = this.getBlobClient(blobName), options.versionId && (blobClient = blobClient.withVersion(options.versionId)), [4, blobClient.delete(__assign(__assign({}, options), {tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})}))];
          case 2:
            return [2, _b.sent()];
          case 3:
            throw e_60 = _b.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_60.message
            }), e_60;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, ContainerClient2.prototype.listBlobFlatSegment = function(marker, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, response, wrappedResponse, e_61;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("ContainerClient-listBlobFlatSegment", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), [4, this.containerContext.listBlobFlatSegment(__assign(__assign({marker}, options), {spanOptions}))];
          case 2:
            return response = _b.sent(), wrappedResponse = __assign(__assign({}, response), {_response: response._response, segment: __assign(__assign({}, response.segment), {blobItems: response.segment.blobItems.map(function(blobItemInteral) {
              var blobItem = __assign(__assign({}, blobItemInteral), {tags: toTags(blobItemInteral.blobTags), objectReplicationSourceProperties: parseObjectReplicationRecord(blobItemInteral.objectReplicationMetadata)});
              return blobItem;
            })})}), [2, wrappedResponse];
          case 3:
            throw e_61 = _b.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_61.message
            }), e_61;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, ContainerClient2.prototype.listBlobHierarchySegment = function(delimiter2, marker, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, response, wrappedResponse, e_62;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("ContainerClient-listBlobHierarchySegment", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), [4, this.containerContext.listBlobHierarchySegment(delimiter2, __assign(__assign({marker}, options), {spanOptions}))];
          case 2:
            return response = _b.sent(), wrappedResponse = __assign(__assign({}, response), {_response: response._response, segment: __assign(__assign({}, response.segment), {blobItems: response.segment.blobItems.map(function(blobItemInteral) {
              var blobItem = __assign(__assign({}, blobItemInteral), {tags: toTags(blobItemInteral.blobTags), objectReplicationSourceProperties: parseObjectReplicationRecord(blobItemInteral.objectReplicationMetadata)});
              return blobItem;
            })})}), [2, wrappedResponse];
          case 3:
            throw e_62 = _b.sent(), span.setStatus({
              code: import_api4.CanonicalCode.UNKNOWN,
              message: e_62.message
            }), e_62;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, ContainerClient2.prototype.listSegments = function(marker, options) {
    return options === void 0 && (options = {}), __asyncGenerator(this, arguments, /* @__PURE__ */ __name(function() {
      var listBlobsFlatSegmentResponse;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!(!!marker || marker === void 0))
              return [3, 7];
            _a.label = 1;
          case 1:
            return [4, __await(this.listBlobFlatSegment(marker, options))];
          case 2:
            return listBlobsFlatSegmentResponse = _a.sent(), marker = listBlobsFlatSegmentResponse.continuationToken, [4, __await(listBlobsFlatSegmentResponse)];
          case 3:
            return [4, __await.apply(void 0, [_a.sent()])];
          case 4:
            return [4, _a.sent()];
          case 5:
            _a.sent(), _a.label = 6;
          case 6:
            if (marker)
              return [3, 1];
            _a.label = 7;
          case 7:
            return [2];
        }
      });
    }, "listSegments_1"));
  }, ContainerClient2.prototype.listItems = function(options) {
    return options === void 0 && (options = {}), __asyncGenerator(this, arguments, /* @__PURE__ */ __name(function() {
      var marker, _a, _b, listBlobsFlatSegmentResponse, e_63_1, e_63, _c;
      return __generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            _d.trys.push([0, 7, 8, 13]), _a = __asyncValues(this.listSegments(marker, options)), _d.label = 1;
          case 1:
            return [4, __await(_a.next())];
          case 2:
            return _b = _d.sent(), !_b.done ? (listBlobsFlatSegmentResponse = _b.value, [5, __values2(__asyncDelegator(__asyncValues(listBlobsFlatSegmentResponse.segment.blobItems)))]) : [3, 6];
          case 3:
            return [4, __await.apply(void 0, [_d.sent()])];
          case 4:
            _d.sent(), _d.label = 5;
          case 5:
            return [3, 1];
          case 6:
            return [3, 13];
          case 7:
            return e_63_1 = _d.sent(), e_63 = {error: e_63_1}, [3, 13];
          case 8:
            return _d.trys.push([8, , 11, 12]), _b && !_b.done && (_c = _a.return) ? [4, __await(_c.call(_a))] : [3, 10];
          case 9:
            _d.sent(), _d.label = 10;
          case 10:
            return [3, 12];
          case 11:
            if (e_63)
              throw e_63.error;
            return [7];
          case 12:
            return [7];
          case 13:
            return [2];
        }
      });
    }, "listItems_1"));
  }, ContainerClient2.prototype.listBlobsFlat = function(options) {
    var _a, _this = this;
    options === void 0 && (options = {});
    var include = [];
    options.includeCopy && include.push("copy"), options.includeDeleted && include.push("deleted"), options.includeMetadata && include.push("metadata"), options.includeSnapshots && include.push("snapshots"), options.includeVersions && include.push("versions"), options.includeUncommitedBlobs && include.push("uncommittedblobs"), options.includeTags && include.push("tags"), options.prefix === "" && (options.prefix = void 0);
    var updatedOptions = __assign(__assign({}, options), include.length > 0 ? {include} : {}), iter = this.listItems(updatedOptions);
    return _a = {
      next: function() {
        return iter.next();
      }
    }, _a[Symbol.asyncIterator] = function() {
      return this;
    }, _a.byPage = function(settings) {
      return settings === void 0 && (settings = {}), _this.listSegments(settings.continuationToken, __assign({maxPageSize: settings.maxPageSize}, updatedOptions));
    }, _a;
  }, ContainerClient2.prototype.listHierarchySegments = function(delimiter2, marker, options) {
    return options === void 0 && (options = {}), __asyncGenerator(this, arguments, /* @__PURE__ */ __name(function() {
      var listBlobsHierarchySegmentResponse;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!(!!marker || marker === void 0))
              return [3, 7];
            _a.label = 1;
          case 1:
            return [4, __await(this.listBlobHierarchySegment(delimiter2, marker, options))];
          case 2:
            return listBlobsHierarchySegmentResponse = _a.sent(), marker = listBlobsHierarchySegmentResponse.continuationToken, [4, __await(listBlobsHierarchySegmentResponse)];
          case 3:
            return [4, __await.apply(void 0, [_a.sent()])];
          case 4:
            return [4, _a.sent()];
          case 5:
            _a.sent(), _a.label = 6;
          case 6:
            if (marker)
              return [3, 1];
            _a.label = 7;
          case 7:
            return [2];
        }
      });
    }, "listHierarchySegments_1"));
  }, ContainerClient2.prototype.listItemsByHierarchy = function(delimiter2, options) {
    return options === void 0 && (options = {}), __asyncGenerator(this, arguments, /* @__PURE__ */ __name(function() {
      var marker, _a, _b, listBlobsHierarchySegmentResponse, segment, _i, _c, prefix2, _d, _e, blob, e_64_1, e_64, _f;
      return __generator(this, function(_g) {
        switch (_g.label) {
          case 0:
            _g.trys.push([0, 14, 15, 20]), _a = __asyncValues(this.listHierarchySegments(delimiter2, marker, options)), _g.label = 1;
          case 1:
            return [4, __await(_a.next())];
          case 2:
            if (_b = _g.sent(), !!_b.done)
              return [3, 13];
            if (listBlobsHierarchySegmentResponse = _b.value, segment = listBlobsHierarchySegmentResponse.segment, !segment.blobPrefixes)
              return [3, 7];
            _i = 0, _c = segment.blobPrefixes, _g.label = 3;
          case 3:
            return _i < _c.length ? (prefix2 = _c[_i], [4, __await(__assign({kind: "prefix"}, prefix2))]) : [3, 7];
          case 4:
            return [4, _g.sent()];
          case 5:
            _g.sent(), _g.label = 6;
          case 6:
            return _i++, [3, 3];
          case 7:
            _d = 0, _e = segment.blobItems, _g.label = 8;
          case 8:
            return _d < _e.length ? (blob = _e[_d], [4, __await(__assign({kind: "blob"}, blob))]) : [3, 12];
          case 9:
            return [4, _g.sent()];
          case 10:
            _g.sent(), _g.label = 11;
          case 11:
            return _d++, [3, 8];
          case 12:
            return [3, 1];
          case 13:
            return [3, 20];
          case 14:
            return e_64_1 = _g.sent(), e_64 = {error: e_64_1}, [3, 20];
          case 15:
            return _g.trys.push([15, , 18, 19]), _b && !_b.done && (_f = _a.return) ? [4, __await(_f.call(_a))] : [3, 17];
          case 16:
            _g.sent(), _g.label = 17;
          case 17:
            return [3, 19];
          case 18:
            if (e_64)
              throw e_64.error;
            return [7];
          case 19:
            return [7];
          case 20:
            return [2];
        }
      });
    }, "listItemsByHierarchy_1"));
  }, ContainerClient2.prototype.listBlobsByHierarchy = function(delimiter2, options) {
    var _a, _this = this;
    if (options === void 0 && (options = {}), delimiter2 === "")
      throw new RangeError("delimiter should contain one or more characters");
    var include = [];
    options.includeCopy && include.push("copy"), options.includeDeleted && include.push("deleted"), options.includeMetadata && include.push("metadata"), options.includeSnapshots && include.push("snapshots"), options.includeVersions && include.push("versions"), options.includeUncommitedBlobs && include.push("uncommittedblobs"), options.includeTags && include.push("tags"), options.prefix === "" && (options.prefix = void 0);
    var updatedOptions = __assign(__assign({}, options), include.length > 0 ? {include} : {}), iter = this.listItemsByHierarchy(delimiter2, updatedOptions);
    return _a = {
      next: function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            return [2, iter.next()];
          });
        });
      }
    }, _a[Symbol.asyncIterator] = function() {
      return this;
    }, _a.byPage = function(settings) {
      return settings === void 0 && (settings = {}), _this.listHierarchySegments(delimiter2, settings.continuationToken, __assign({maxPageSize: settings.maxPageSize}, updatedOptions));
    }, _a;
  }, ContainerClient2.prototype.getContainerNameFromUrl = function() {
    var containerName;
    try {
      var parsedUrl = URLBuilder.parse(this.url);
      if (parsedUrl.getHost().split(".")[1] === "blob" ? containerName = parsedUrl.getPath().split("/")[1] : isIpEndpointStyle(parsedUrl) ? containerName = parsedUrl.getPath().split("/")[2] : containerName = parsedUrl.getPath().split("/")[1], containerName = decodeURIComponent(containerName), !containerName)
        throw new Error("Provided containerName is invalid.");
      return containerName;
    } catch (error) {
      throw new Error("Unable to extract containerName with provided information.");
    }
  }, ContainerClient2.prototype.generateSasUrl = function(options) {
    var _this = this;
    return new Promise(function(resolve) {
      if (!(_this.credential instanceof StorageSharedKeyCredential))
        throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
      var sas = generateBlobSASQueryParameters(__assign({containerName: _this._containerName}, options), _this.credential).toString();
      resolve(appendToURLQuery(_this.url, sas));
    });
  }, ContainerClient2;
}(StorageClient);

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/BatchUtils.js
function getBodyAsText(batchResponse) {
  return __awaiter(this, void 0, void 0, function() {
    var buffer, responseLength;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          return buffer = Buffer.alloc(BATCH_MAX_PAYLOAD_IN_BYTES), [4, streamToBuffer2(batchResponse.readableStreamBody, buffer)];
        case 1:
          return responseLength = _a.sent(), buffer = buffer.slice(0, responseLength), [2, buffer.toString()];
      }
    });
  });
}
__name(getBodyAsText, "getBodyAsText");
function utf8ByteLength(str) {
  return Buffer.byteLength(str);
}
__name(utf8ByteLength, "utf8ByteLength");

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/BatchResponseParser.js
var HTTP_HEADER_DELIMITER = ": ", SPACE_DELIMITER = " ", NOT_FOUND = -1, BatchResponseParser = function() {
  function BatchResponseParser2(batchResponse, subRequests) {
    if (!batchResponse || !batchResponse.contentType)
      throw new RangeError("batchResponse is malformed or doesn't contain valid content-type.");
    if (!subRequests || subRequests.size === 0)
      throw new RangeError("Invalid state: subRequests is not provided or size is 0.");
    this.batchResponse = batchResponse, this.subRequests = subRequests, this.responseBatchBoundary = this.batchResponse.contentType.split("=")[1], this.perResponsePrefix = "--" + this.responseBatchBoundary + HTTP_LINE_ENDING, this.batchResponseEnding = "--" + this.responseBatchBoundary + "--";
  }
  return __name(BatchResponseParser2, "BatchResponseParser"), BatchResponseParser2.prototype.parseBatchResponse = function() {
    return __awaiter(this, void 0, void 0, function() {
      var responseBodyAsText, subResponses, subResponseCount, deserializedSubResponses, subResponsesSucceededCount, subResponsesFailedCount, index, subResponse, deserializedSubResponse, responseLines, subRespHeaderStartFound, subRespHeaderEndFound, subRespFailed, contentId, _i, responseLines_1, responseLine, tokens, tokens;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (this.batchResponse._response.status != HTTPURLConnection.HTTP_ACCEPTED)
              throw new Error("Invalid state: batch request failed with status: '" + this.batchResponse._response.status + "'.");
            return [4, getBodyAsText(this.batchResponse)];
          case 1:
            if (responseBodyAsText = _a.sent(), subResponses = responseBodyAsText.split(this.batchResponseEnding)[0].split(this.perResponsePrefix).slice(1), subResponseCount = subResponses.length, subResponseCount != this.subRequests.size && subResponseCount != 1)
              throw new Error("Invalid state: sub responses' count is not equal to sub requests' count.");
            for (deserializedSubResponses = new Array(subResponseCount), subResponsesSucceededCount = 0, subResponsesFailedCount = 0, index = 0; index < subResponseCount; index++) {
              for (subResponse = subResponses[index], deserializedSubResponse = {}, deserializedSubResponse.headers = new HttpHeaders(), responseLines = subResponse.split("" + HTTP_LINE_ENDING), subRespHeaderStartFound = !1, subRespHeaderEndFound = !1, subRespFailed = !1, contentId = NOT_FOUND, _i = 0, responseLines_1 = responseLines; _i < responseLines_1.length; _i++) {
                if (responseLine = responseLines_1[_i], !subRespHeaderStartFound) {
                  responseLine.startsWith(HeaderConstants.CONTENT_ID) && (contentId = parseInt(responseLine.split(HTTP_HEADER_DELIMITER)[1])), responseLine.startsWith(HTTP_VERSION_1_1) && (subRespHeaderStartFound = !0, tokens = responseLine.split(SPACE_DELIMITER), deserializedSubResponse.status = parseInt(tokens[1]), deserializedSubResponse.statusMessage = tokens.slice(2).join(SPACE_DELIMITER));
                  continue;
                }
                if (responseLine.trim() === "") {
                  subRespHeaderEndFound || (subRespHeaderEndFound = !0);
                  continue;
                }
                if (subRespHeaderEndFound)
                  deserializedSubResponse.bodyAsText || (deserializedSubResponse.bodyAsText = ""), deserializedSubResponse.bodyAsText += responseLine;
                else {
                  if (responseLine.indexOf(HTTP_HEADER_DELIMITER) === -1)
                    throw new Error("Invalid state: find non-empty line '" + responseLine + "' without HTTP header delimiter '" + HTTP_HEADER_DELIMITER + "'.");
                  tokens = responseLine.split(HTTP_HEADER_DELIMITER), deserializedSubResponse.headers.set(tokens[0], tokens[1]), tokens[0] === HeaderConstants.X_MS_ERROR_CODE && (deserializedSubResponse.errorCode = tokens[1], subRespFailed = !0);
                }
              }
              contentId != NOT_FOUND && Number.isInteger(contentId) && contentId >= 0 && contentId < this.subRequests.size && deserializedSubResponses[contentId] === void 0 ? (deserializedSubResponse._request = this.subRequests.get(contentId), deserializedSubResponses[contentId] = deserializedSubResponse) : logger2.error("subResponses[" + index + "] is dropped as the Content-ID is not found or invalid, Content-ID: " + contentId), subRespFailed ? subResponsesFailedCount++ : subResponsesSucceededCount++;
            }
            return [2, {
              subResponses: deserializedSubResponses,
              subResponsesSucceededCount,
              subResponsesFailedCount
            }];
        }
      });
    });
  }, BatchResponseParser2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/BlobBatch.js
var import_api5 = __toModule(require_src2());

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/utils/Mutex.js
var MutexLockStatus;
(function(MutexLockStatus2) {
  MutexLockStatus2[MutexLockStatus2.LOCKED = 0] = "LOCKED", MutexLockStatus2[MutexLockStatus2.UNLOCKED = 1] = "UNLOCKED";
})(MutexLockStatus || (MutexLockStatus = {}));
var Mutex = function() {
  function Mutex2() {
  }
  return __name(Mutex2, "Mutex"), Mutex2.lock = function(key) {
    return __awaiter(this, void 0, void 0, function() {
      var _this = this;
      return __generator(this, function(_a) {
        return [2, new Promise(function(resolve) {
          _this.keys[key] === void 0 || _this.keys[key] === MutexLockStatus.UNLOCKED ? (_this.keys[key] = MutexLockStatus.LOCKED, resolve()) : _this.onUnlockEvent(key, function() {
            _this.keys[key] = MutexLockStatus.LOCKED, resolve();
          });
        })];
      });
    });
  }, Mutex2.unlock = function(key) {
    return __awaiter(this, void 0, void 0, function() {
      var _this = this;
      return __generator(this, function(_a) {
        return [2, new Promise(function(resolve) {
          _this.keys[key] === MutexLockStatus.LOCKED && _this.emitUnlockEvent(key), delete _this.keys[key], resolve();
        })];
      });
    });
  }, Mutex2.onUnlockEvent = function(key, handler) {
    this.listeners[key] === void 0 ? this.listeners[key] = [handler] : this.listeners[key].push(handler);
  }, Mutex2.emitUnlockEvent = function(key) {
    var _this = this;
    if (this.listeners[key] !== void 0 && this.listeners[key].length > 0) {
      var handler_1 = this.listeners[key].shift();
      setImmediate(function() {
        handler_1.call(_this);
      });
    }
  }, Mutex2.keys = {}, Mutex2.listeners = {}, Mutex2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/BlobBatch.js
var BlobBatch = function() {
  function BlobBatch2() {
    this.batch = "batch", this.batchRequest = new InnerBatchRequest();
  }
  return __name(BlobBatch2, "BlobBatch"), BlobBatch2.prototype.getMultiPartContentType = function() {
    return this.batchRequest.getMultipartContentType();
  }, BlobBatch2.prototype.getHttpRequestBody = function() {
    return this.batchRequest.getHttpRequestBody();
  }, BlobBatch2.prototype.getSubRequests = function() {
    return this.batchRequest.getSubRequests();
  }, BlobBatch2.prototype.addSubRequestInternal = function(subRequest, assembleSubRequestFunc) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, Mutex.lock(this.batch)];
          case 1:
            _a.sent(), _a.label = 2;
          case 2:
            return _a.trys.push([2, , 4, 6]), this.batchRequest.preAddSubRequest(subRequest), [4, assembleSubRequestFunc()];
          case 3:
            return _a.sent(), this.batchRequest.postAddSubRequest(subRequest), [3, 6];
          case 4:
            return [4, Mutex.unlock(this.batch)];
          case 5:
            return _a.sent(), [7];
          case 6:
            return [2];
        }
      });
    });
  }, BlobBatch2.prototype.setBatchType = function(batchType) {
    if (this.batchType || (this.batchType = batchType), this.batchType !== batchType)
      throw new RangeError("BlobBatch only supports one operation type per batch and it already is being used for " + this.batchType + " operations.");
  }, BlobBatch2.prototype.deleteBlob = function(urlOrBlobClient, credentialOrOptions, options) {
    return __awaiter(this, void 0, void 0, function() {
      var url2, credential, _a, span, spanOptions, e_1, _this = this;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            if (typeof urlOrBlobClient == "string" && (isNode && credentialOrOptions instanceof StorageSharedKeyCredential || credentialOrOptions instanceof AnonymousCredential || isTokenCredential(credentialOrOptions)))
              url2 = urlOrBlobClient, credential = credentialOrOptions;
            else if (urlOrBlobClient instanceof BlobClient)
              url2 = urlOrBlobClient.url, credential = urlOrBlobClient.credential, options = credentialOrOptions;
            else
              throw new RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
            options || (options = {}), _a = createSpan("BatchDeleteRequest-addSubRequest", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), this.setBatchType("delete"), [4, this.addSubRequestInternal({
              url: url2,
              credential
            }, function() {
              return __awaiter(_this, void 0, void 0, function() {
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      return [4, new BlobClient(url2, this.batchRequest.createPipeline(credential)).delete(__assign(__assign({}, options), {tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})}))];
                    case 1:
                      return _a2.sent(), [2];
                  }
                });
              });
            })];
          case 2:
            return _b.sent(), [3, 5];
          case 3:
            throw e_1 = _b.sent(), span.setStatus({
              code: import_api5.CanonicalCode.UNKNOWN,
              message: e_1.message
            }), e_1;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobBatch2.prototype.setBlobAccessTier = function(urlOrBlobClient, credentialOrTier, tierOrOptions, options) {
    return __awaiter(this, void 0, void 0, function() {
      var url2, credential, tier, _a, span, spanOptions, e_2, _this = this;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            if (typeof urlOrBlobClient == "string" && (isNode && credentialOrTier instanceof StorageSharedKeyCredential || credentialOrTier instanceof AnonymousCredential || isTokenCredential(credentialOrTier)))
              url2 = urlOrBlobClient, credential = credentialOrTier, tier = tierOrOptions;
            else if (urlOrBlobClient instanceof BlobClient)
              url2 = urlOrBlobClient.url, credential = urlOrBlobClient.credential, tier = credentialOrTier, options = tierOrOptions;
            else
              throw new RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
            options || (options = {}), _a = createSpan("BatchSetTierRequest-addSubRequest", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), this.setBatchType("setAccessTier"), [4, this.addSubRequestInternal({
              url: url2,
              credential
            }, function() {
              return __awaiter(_this, void 0, void 0, function() {
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      return [4, new BlobClient(url2, this.batchRequest.createPipeline(credential)).setAccessTier(tier, __assign(__assign({}, options), {tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})}))];
                    case 1:
                      return _a2.sent(), [2];
                  }
                });
              });
            })];
          case 2:
            return _b.sent(), [3, 5];
          case 3:
            throw e_2 = _b.sent(), span.setStatus({
              code: import_api5.CanonicalCode.UNKNOWN,
              message: e_2.message
            }), e_2;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobBatch2;
}();
var InnerBatchRequest = function() {
  function InnerBatchRequest2() {
    this.operationCount = 0, this.body = "";
    var tempGuid = generateUuid();
    this.boundary = "batch_" + tempGuid, this.subRequestPrefix = "--" + this.boundary + HTTP_LINE_ENDING + HeaderConstants.CONTENT_TYPE + ": application/http" + HTTP_LINE_ENDING + HeaderConstants.CONTENT_TRANSFER_ENCODING + ": binary", this.multipartContentType = "multipart/mixed; boundary=" + this.boundary, this.batchRequestEnding = "--" + this.boundary + "--", this.subRequests = new Map();
  }
  return __name(InnerBatchRequest2, "InnerBatchRequest"), InnerBatchRequest2.prototype.createPipeline = function(credential) {
    var isAnonymousCreds = credential instanceof AnonymousCredential, policyFactoryLength = 3 + (isAnonymousCreds ? 0 : 1), factories = new Array(policyFactoryLength);
    return factories[0] = deserializationPolicy(), factories[1] = new BatchHeaderFilterPolicyFactory(), isAnonymousCreds || (factories[2] = isTokenCredential(credential) ? attachCredential(bearerTokenAuthenticationPolicy(credential, StorageOAuthScopes), credential) : credential), factories[policyFactoryLength - 1] = new BatchRequestAssemblePolicyFactory(this), new Pipeline(factories, {});
  }, InnerBatchRequest2.prototype.appendSubRequestToBody = function(request) {
    this.body += [
      this.subRequestPrefix,
      HeaderConstants.CONTENT_ID + ": " + this.operationCount,
      "",
      request.method.toString() + " " + getURLPathAndQuery(request.url) + " " + HTTP_VERSION_1_1 + HTTP_LINE_ENDING
    ].join(HTTP_LINE_ENDING);
    for (var _i = 0, _a = request.headers.headersArray(); _i < _a.length; _i++) {
      var header = _a[_i];
      this.body += header.name + ": " + header.value + HTTP_LINE_ENDING;
    }
    this.body += HTTP_LINE_ENDING;
  }, InnerBatchRequest2.prototype.preAddSubRequest = function(subRequest) {
    if (this.operationCount >= BATCH_MAX_REQUEST)
      throw new RangeError("Cannot exceed " + BATCH_MAX_REQUEST + " sub requests in a single batch");
    var path3 = getURLPath(subRequest.url);
    if (!path3 || path3 == "")
      throw new RangeError("Invalid url for sub request: '" + subRequest.url + "'");
  }, InnerBatchRequest2.prototype.postAddSubRequest = function(subRequest) {
    this.subRequests.set(this.operationCount, subRequest), this.operationCount++;
  }, InnerBatchRequest2.prototype.getHttpRequestBody = function() {
    return "" + this.body + this.batchRequestEnding + HTTP_LINE_ENDING;
  }, InnerBatchRequest2.prototype.getMultipartContentType = function() {
    return this.multipartContentType;
  }, InnerBatchRequest2.prototype.getSubRequests = function() {
    return this.subRequests;
  }, InnerBatchRequest2;
}(), BatchRequestAssemblePolicy = function(_super) {
  __extends(BatchRequestAssemblePolicy2, _super);
  function BatchRequestAssemblePolicy2(batchRequest, nextPolicy, options) {
    var _this = _super.call(this, nextPolicy, options) || this;
    return _this.dummyResponse = {
      request: new WebResource(),
      status: 200,
      headers: new HttpHeaders()
    }, _this.batchRequest = batchRequest, _this;
  }
  return __name(BatchRequestAssemblePolicy2, "BatchRequestAssemblePolicy"), BatchRequestAssemblePolicy2.prototype.sendRequest = function(request) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, this.batchRequest.appendSubRequestToBody(request)];
          case 1:
            return _a.sent(), [2, this.dummyResponse];
        }
      });
    });
  }, BatchRequestAssemblePolicy2;
}(BaseRequestPolicy), BatchRequestAssemblePolicyFactory = function() {
  function BatchRequestAssemblePolicyFactory2(batchRequest) {
    this.batchRequest = batchRequest;
  }
  return __name(BatchRequestAssemblePolicyFactory2, "BatchRequestAssemblePolicyFactory"), BatchRequestAssemblePolicyFactory2.prototype.create = function(nextPolicy, options) {
    return new BatchRequestAssemblePolicy(this.batchRequest, nextPolicy, options);
  }, BatchRequestAssemblePolicyFactory2;
}(), BatchHeaderFilterPolicy = function(_super) {
  __extends(BatchHeaderFilterPolicy2, _super);
  function BatchHeaderFilterPolicy2(nextPolicy, options) {
    return _super.call(this, nextPolicy, options) || this;
  }
  return __name(BatchHeaderFilterPolicy2, "BatchHeaderFilterPolicy"), BatchHeaderFilterPolicy2.prototype.sendRequest = function(request) {
    return __awaiter(this, void 0, void 0, function() {
      var xMsHeaderName, _i, _a, header;
      return __generator(this, function(_b) {
        for (xMsHeaderName = "", _i = 0, _a = request.headers.headersArray(); _i < _a.length; _i++)
          header = _a[_i], iEqual(header.name, HeaderConstants.X_MS_VERSION) && (xMsHeaderName = header.name);
        return xMsHeaderName !== "" && request.headers.remove(xMsHeaderName), [2, this._nextPolicy.sendRequest(request)];
      });
    });
  }, BatchHeaderFilterPolicy2;
}(BaseRequestPolicy), BatchHeaderFilterPolicyFactory = function() {
  function BatchHeaderFilterPolicyFactory2() {
  }
  return __name(BatchHeaderFilterPolicyFactory2, "BatchHeaderFilterPolicyFactory"), BatchHeaderFilterPolicyFactory2.prototype.create = function(nextPolicy, options) {
    return new BatchHeaderFilterPolicy(nextPolicy, options);
  }, BatchHeaderFilterPolicyFactory2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/BlobBatchClient.js
var import_api6 = __toModule(require_src2());
var BlobBatchClient = function() {
  function BlobBatchClient2(url2, credentialOrPipeline, options) {
    var pipeline;
    credentialOrPipeline instanceof Pipeline ? pipeline = credentialOrPipeline : credentialOrPipeline ? pipeline = newPipeline(credentialOrPipeline, options) : pipeline = newPipeline(new AnonymousCredential(), options);
    var storageClientContext = new StorageClientContext(url2, pipeline.toServiceClientOptions());
    this._serviceContext = new Service(storageClientContext);
  }
  return __name(BlobBatchClient2, "BlobBatchClient"), BlobBatchClient2.prototype.createBatch = function() {
    return new BlobBatch();
  }, BlobBatchClient2.prototype.deleteBlobs = function(urlsOrBlobClients, credentialOrOptions, options) {
    return __awaiter(this, void 0, void 0, function() {
      var batch, _i, urlsOrBlobClients_1, urlOrBlobClient;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            batch = new BlobBatch(), _i = 0, urlsOrBlobClients_1 = urlsOrBlobClients, _a.label = 1;
          case 1:
            return _i < urlsOrBlobClients_1.length ? (urlOrBlobClient = urlsOrBlobClients_1[_i], typeof urlOrBlobClient != "string" ? [3, 3] : [4, batch.deleteBlob(urlOrBlobClient, credentialOrOptions, options)]) : [3, 6];
          case 2:
            return _a.sent(), [3, 5];
          case 3:
            return [4, batch.deleteBlob(urlOrBlobClient, credentialOrOptions)];
          case 4:
            _a.sent(), _a.label = 5;
          case 5:
            return _i++, [3, 1];
          case 6:
            return [2, this.submitBatch(batch)];
        }
      });
    });
  }, BlobBatchClient2.prototype.setBlobsAccessTier = function(urlsOrBlobClients, credentialOrTier, tierOrOptions, options) {
    return __awaiter(this, void 0, void 0, function() {
      var batch, _i, urlsOrBlobClients_2, urlOrBlobClient;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            batch = new BlobBatch(), _i = 0, urlsOrBlobClients_2 = urlsOrBlobClients, _a.label = 1;
          case 1:
            return _i < urlsOrBlobClients_2.length ? (urlOrBlobClient = urlsOrBlobClients_2[_i], typeof urlOrBlobClient != "string" ? [3, 3] : [4, batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options)]) : [3, 6];
          case 2:
            return _a.sent(), [3, 5];
          case 3:
            return [4, batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions)];
          case 4:
            _a.sent(), _a.label = 5;
          case 5:
            return _i++, [3, 1];
          case 6:
            return [2, this.submitBatch(batch)];
        }
      });
    });
  }, BlobBatchClient2.prototype.submitBatch = function(batchRequest, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, batchRequestBody, rawBatchResponse, batchResponseParser, responseSummary, res, e_1;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            if (!batchRequest || batchRequest.getSubRequests().size == 0)
              throw new RangeError("Batch request should contain one or more sub requests.");
            _a = createSpan("BlobBatchClient-submitBatch", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 4, 5, 6]), batchRequestBody = batchRequest.getHttpRequestBody(), [4, this._serviceContext.submitBatch(batchRequestBody, utf8ByteLength(batchRequestBody), batchRequest.getMultiPartContentType(), __assign(__assign({}, options), {spanOptions}))];
          case 2:
            return rawBatchResponse = _b.sent(), batchResponseParser = new BatchResponseParser(rawBatchResponse, batchRequest.getSubRequests()), [4, batchResponseParser.parseBatchResponse()];
          case 3:
            return responseSummary = _b.sent(), res = {
              _response: rawBatchResponse._response,
              contentType: rawBatchResponse.contentType,
              errorCode: rawBatchResponse.errorCode,
              requestId: rawBatchResponse.requestId,
              clientRequestId: rawBatchResponse.clientRequestId,
              version: rawBatchResponse.version,
              subResponses: responseSummary.subResponses,
              subResponsesSucceededCount: responseSummary.subResponsesSucceededCount,
              subResponsesFailedCount: responseSummary.subResponsesFailedCount
            }, [2, res];
          case 4:
            throw e_1 = _b.sent(), span.setStatus({
              code: import_api6.CanonicalCode.UNKNOWN,
              message: e_1.message
            }), e_1;
          case 5:
            return span.end(), [7];
          case 6:
            return [2];
        }
      });
    });
  }, BlobBatchClient2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/sas/AccountSASPermissions.js
var AccountSASPermissions = function() {
  function AccountSASPermissions2() {
    this.read = !1, this.write = !1, this.delete = !1, this.deleteVersion = !1, this.list = !1, this.add = !1, this.create = !1, this.update = !1, this.process = !1, this.tag = !1, this.filter = !1;
  }
  return __name(AccountSASPermissions2, "AccountSASPermissions"), AccountSASPermissions2.parse = function(permissions) {
    for (var accountSASPermissions = new AccountSASPermissions2(), _i = 0, permissions_1 = permissions; _i < permissions_1.length; _i++) {
      var c = permissions_1[_i];
      switch (c) {
        case "r":
          accountSASPermissions.read = !0;
          break;
        case "w":
          accountSASPermissions.write = !0;
          break;
        case "d":
          accountSASPermissions.delete = !0;
          break;
        case "x":
          accountSASPermissions.deleteVersion = !0;
          break;
        case "l":
          accountSASPermissions.list = !0;
          break;
        case "a":
          accountSASPermissions.add = !0;
          break;
        case "c":
          accountSASPermissions.create = !0;
          break;
        case "u":
          accountSASPermissions.update = !0;
          break;
        case "p":
          accountSASPermissions.process = !0;
          break;
        case "t":
          accountSASPermissions.tag = !0;
          break;
        case "f":
          accountSASPermissions.filter = !0;
          break;
        default:
          throw new RangeError("Invalid permission character: " + c);
      }
    }
    return accountSASPermissions;
  }, AccountSASPermissions2.from = function(permissionLike) {
    var accountSASPermissions = new AccountSASPermissions2();
    return permissionLike.read && (accountSASPermissions.read = !0), permissionLike.write && (accountSASPermissions.write = !0), permissionLike.delete && (accountSASPermissions.delete = !0), permissionLike.deleteVersion && (accountSASPermissions.deleteVersion = !0), permissionLike.filter && (accountSASPermissions.filter = !0), permissionLike.tag && (accountSASPermissions.tag = !0), permissionLike.list && (accountSASPermissions.list = !0), permissionLike.add && (accountSASPermissions.add = !0), permissionLike.create && (accountSASPermissions.create = !0), permissionLike.update && (accountSASPermissions.update = !0), permissionLike.process && (accountSASPermissions.process = !0), accountSASPermissions;
  }, AccountSASPermissions2.prototype.toString = function() {
    var permissions = [];
    return this.read && permissions.push("r"), this.write && permissions.push("w"), this.delete && permissions.push("d"), this.deleteVersion && permissions.push("x"), this.filter && permissions.push("f"), this.tag && permissions.push("t"), this.list && permissions.push("l"), this.add && permissions.push("a"), this.create && permissions.push("c"), this.update && permissions.push("u"), this.process && permissions.push("p"), permissions.join("");
  }, AccountSASPermissions2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/sas/AccountSASResourceTypes.js
var AccountSASResourceTypes = function() {
  function AccountSASResourceTypes2() {
    this.service = !1, this.container = !1, this.object = !1;
  }
  return __name(AccountSASResourceTypes2, "AccountSASResourceTypes"), AccountSASResourceTypes2.parse = function(resourceTypes) {
    for (var accountSASResourceTypes = new AccountSASResourceTypes2(), _i = 0, resourceTypes_1 = resourceTypes; _i < resourceTypes_1.length; _i++) {
      var c = resourceTypes_1[_i];
      switch (c) {
        case "s":
          accountSASResourceTypes.service = !0;
          break;
        case "c":
          accountSASResourceTypes.container = !0;
          break;
        case "o":
          accountSASResourceTypes.object = !0;
          break;
        default:
          throw new RangeError("Invalid resource type: " + c);
      }
    }
    return accountSASResourceTypes;
  }, AccountSASResourceTypes2.prototype.toString = function() {
    var resourceTypes = [];
    return this.service && resourceTypes.push("s"), this.container && resourceTypes.push("c"), this.object && resourceTypes.push("o"), resourceTypes.join("");
  }, AccountSASResourceTypes2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/sas/AccountSASServices.js
var AccountSASServices = function() {
  function AccountSASServices2() {
    this.blob = !1, this.file = !1, this.queue = !1, this.table = !1;
  }
  return __name(AccountSASServices2, "AccountSASServices"), AccountSASServices2.parse = function(services) {
    for (var accountSASServices = new AccountSASServices2(), _i = 0, services_1 = services; _i < services_1.length; _i++) {
      var c = services_1[_i];
      switch (c) {
        case "b":
          accountSASServices.blob = !0;
          break;
        case "f":
          accountSASServices.file = !0;
          break;
        case "q":
          accountSASServices.queue = !0;
          break;
        case "t":
          accountSASServices.table = !0;
          break;
        default:
          throw new RangeError("Invalid service character: " + c);
      }
    }
    return accountSASServices;
  }, AccountSASServices2.prototype.toString = function() {
    var services = [];
    return this.blob && services.push("b"), this.table && services.push("t"), this.queue && services.push("q"), this.file && services.push("f"), services.join("");
  }, AccountSASServices2;
}();

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/sas/AccountSASSignatureValues.js
function generateAccountSASQueryParameters(accountSASSignatureValues, sharedKeyCredential) {
  var version2 = accountSASSignatureValues.version ? accountSASSignatureValues.version : SERVICE_VERSION;
  if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.deleteVersion && version2 < "2019-10-10")
    throw RangeError("'version' must be >= '2019-10-10' when provided 'x' permission.");
  if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.tag && version2 < "2019-12-12")
    throw RangeError("'version' must be >= '2019-12-12' when provided 't' permission.");
  if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.filter && version2 < "2019-12-12")
    throw RangeError("'version' must be >= '2019-12-12' when provided 'f' permission.");
  var parsedPermissions = AccountSASPermissions.parse(accountSASSignatureValues.permissions.toString()), parsedServices = AccountSASServices.parse(accountSASSignatureValues.services).toString(), parsedResourceTypes = AccountSASResourceTypes.parse(accountSASSignatureValues.resourceTypes).toString(), stringToSign = [
    sharedKeyCredential.accountName,
    parsedPermissions,
    parsedServices,
    parsedResourceTypes,
    accountSASSignatureValues.startsOn ? truncatedISO8061Date(accountSASSignatureValues.startsOn, !1) : "",
    truncatedISO8061Date(accountSASSignatureValues.expiresOn, !1),
    accountSASSignatureValues.ipRange ? ipRangeToString(accountSASSignatureValues.ipRange) : "",
    accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
    version2,
    ""
  ].join(`
`), signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
  return new SASQueryParameters(version2, signature, parsedPermissions.toString(), parsedServices, parsedResourceTypes, accountSASSignatureValues.protocol, accountSASSignatureValues.startsOn, accountSASSignatureValues.expiresOn, accountSASSignatureValues.ipRange);
}
__name(generateAccountSASQueryParameters, "generateAccountSASQueryParameters");

// ../node_modules/@azure/storage-blob/dist-esm/storage-blob/src/BlobServiceClient.js
var BlobServiceClient = function(_super) {
  __extends(BlobServiceClient2, _super);
  function BlobServiceClient2(url2, credentialOrPipeline, options) {
    var _this = this, pipeline;
    return credentialOrPipeline instanceof Pipeline ? pipeline = credentialOrPipeline : isNode && credentialOrPipeline instanceof StorageSharedKeyCredential || credentialOrPipeline instanceof AnonymousCredential || isTokenCredential(credentialOrPipeline) ? pipeline = newPipeline(credentialOrPipeline, options) : pipeline = newPipeline(new AnonymousCredential(), options), _this = _super.call(this, url2, pipeline) || this, _this.serviceContext = new Service(_this.storageClientContext), _this;
  }
  return __name(BlobServiceClient2, "BlobServiceClient"), BlobServiceClient2.fromConnectionString = function(connectionString, options) {
    options = options || {};
    var extractedCreds = extractConnectionStringParts(connectionString);
    if (extractedCreds.kind === "AccountConnString")
      if (isNode) {
        var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
        options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);
        var pipeline = newPipeline(sharedKeyCredential, options);
        return new BlobServiceClient2(extractedCreds.url, pipeline);
      } else
        throw new Error("Account connection string is only supported in Node.js environment");
    else if (extractedCreds.kind === "SASConnString") {
      var pipeline = newPipeline(new AnonymousCredential(), options);
      return new BlobServiceClient2(extractedCreds.url + "?" + extractedCreds.accountSas, pipeline);
    } else
      throw new Error("Connection string must be either an Account connection string or a SAS connection string");
  }, BlobServiceClient2.prototype.getContainerClient = function(containerName) {
    return new ContainerClient(appendToURLPath(this.url, encodeURIComponent(containerName)), this.pipeline);
  }, BlobServiceClient2.prototype.createContainer = function(containerName, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, containerClient, containerCreateResponse, e_1;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("BlobServiceClient-createContainer", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), containerClient = this.getContainerClient(containerName), [4, containerClient.create(__assign(__assign({}, options), {tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})}))];
          case 2:
            return containerCreateResponse = _b.sent(), [2, {
              containerClient,
              containerCreateResponse
            }];
          case 3:
            throw e_1 = _b.sent(), span.setStatus({
              code: import_api7.CanonicalCode.UNKNOWN,
              message: e_1.message
            }), e_1;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobServiceClient2.prototype.deleteContainer = function(containerName, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, containerClient, e_2;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("BlobServiceClient-deleteContainer", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), containerClient = this.getContainerClient(containerName), [4, containerClient.delete(__assign(__assign({}, options), {tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})}))];
          case 2:
            return [2, _b.sent()];
          case 3:
            throw e_2 = _b.sent(), span.setStatus({
              code: import_api7.CanonicalCode.UNKNOWN,
              message: e_2.message
            }), e_2;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobServiceClient2.prototype.undeleteContainer = function(deletedContainerName2, deletedContainerVersion2, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, containerClient, containerContext, containerUndeleteResponse, e_3;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("BlobServiceClient-undeleteContainer", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), containerClient = this.getContainerClient(options.destinationContainerName || deletedContainerName2), containerContext = new Container(containerClient.storageClientContext), [4, containerContext.restore(__assign(__assign({
              deletedContainerName: deletedContainerName2,
              deletedContainerVersion: deletedContainerVersion2
            }, options), {tracingOptions: __assign(__assign({}, options.tracingOptions), {spanOptions})}))];
          case 2:
            return containerUndeleteResponse = _b.sent(), [2, {containerClient, containerUndeleteResponse}];
          case 3:
            throw e_3 = _b.sent(), span.setStatus({
              code: import_api7.CanonicalCode.UNKNOWN,
              message: e_3.message
            }), e_3;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobServiceClient2.prototype.getProperties = function(options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, e_4;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("BlobServiceClient-getProperties", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), [4, this.serviceContext.getProperties({
              abortSignal: options.abortSignal,
              spanOptions
            })];
          case 2:
            return [2, _b.sent()];
          case 3:
            throw e_4 = _b.sent(), span.setStatus({
              code: import_api7.CanonicalCode.UNKNOWN,
              message: e_4.message
            }), e_4;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobServiceClient2.prototype.setProperties = function(properties, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, e_5;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("BlobServiceClient-setProperties", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), [4, this.serviceContext.setProperties(properties, {
              abortSignal: options.abortSignal,
              spanOptions
            })];
          case 2:
            return [2, _b.sent()];
          case 3:
            throw e_5 = _b.sent(), span.setStatus({
              code: import_api7.CanonicalCode.UNKNOWN,
              message: e_5.message
            }), e_5;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobServiceClient2.prototype.getStatistics = function(options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, e_6;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("BlobServiceClient-getStatistics", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), [4, this.serviceContext.getStatistics({
              abortSignal: options.abortSignal,
              spanOptions
            })];
          case 2:
            return [2, _b.sent()];
          case 3:
            throw e_6 = _b.sent(), span.setStatus({
              code: import_api7.CanonicalCode.UNKNOWN,
              message: e_6.message
            }), e_6;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobServiceClient2.prototype.getAccountInfo = function(options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, e_7;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("BlobServiceClient-getAccountInfo", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), [4, this.serviceContext.getAccountInfo({
              abortSignal: options.abortSignal,
              spanOptions
            })];
          case 2:
            return [2, _b.sent()];
          case 3:
            throw e_7 = _b.sent(), span.setStatus({
              code: import_api7.CanonicalCode.UNKNOWN,
              message: e_7.message
            }), e_7;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobServiceClient2.prototype.listContainersSegment = function(marker, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, e_8;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("BlobServiceClient-listContainersSegment", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), [4, this.serviceContext.listContainersSegment(__assign(__assign({abortSignal: options.abortSignal, marker}, options), {include: typeof options.include == "string" ? [options.include] : options.include, spanOptions}))];
          case 2:
            return [2, _b.sent()];
          case 3:
            throw e_8 = _b.sent(), span.setStatus({
              code: import_api7.CanonicalCode.UNKNOWN,
              message: e_8.message
            }), e_8;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobServiceClient2.prototype.findBlobsByTagsSegment = function(tagFilterSqlExpression, marker, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, response, wrappedResponse, e_9;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("BlobServiceClient-findBlobsByTagsSegment", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), [4, this.serviceContext.filterBlobs({
              abortSignal: options.abortSignal,
              where: tagFilterSqlExpression,
              marker,
              maxPageSize: options.maxPageSize,
              spanOptions
            })];
          case 2:
            return response = _b.sent(), wrappedResponse = __assign(__assign({}, response), {_response: response._response, blobs: response.blobs.map(function(blob) {
              var _a2, tagValue = "";
              return ((_a2 = blob.tags) === null || _a2 === void 0 ? void 0 : _a2.blobTagSet.length) === 1 && (tagValue = blob.tags.blobTagSet[0].value), __assign(__assign({}, blob), {tags: toTags(blob.tags), tagValue});
            })}), [2, wrappedResponse];
          case 3:
            throw e_9 = _b.sent(), span.setStatus({
              code: import_api7.CanonicalCode.UNKNOWN,
              message: e_9.message
            }), e_9;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobServiceClient2.prototype.findBlobsByTagsSegments = function(tagFilterSqlExpression, marker, options) {
    return options === void 0 && (options = {}), __asyncGenerator(this, arguments, /* @__PURE__ */ __name(function() {
      var response;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!(!!marker || marker === void 0))
              return [3, 6];
            _a.label = 1;
          case 1:
            return [4, __await(this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options))];
          case 2:
            return response = _a.sent(), response.blobs = response.blobs || [], marker = response.continuationToken, [4, __await(response)];
          case 3:
            return [4, _a.sent()];
          case 4:
            _a.sent(), _a.label = 5;
          case 5:
            if (marker)
              return [3, 1];
            _a.label = 6;
          case 6:
            return [2];
        }
      });
    }, "findBlobsByTagsSegments_1"));
  }, BlobServiceClient2.prototype.findBlobsByTagsItems = function(tagFilterSqlExpression, options) {
    return options === void 0 && (options = {}), __asyncGenerator(this, arguments, /* @__PURE__ */ __name(function() {
      var marker, _a, _b, segment, e_10_1, e_10, _c;
      return __generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            _d.trys.push([0, 7, 8, 13]), _a = __asyncValues(this.findBlobsByTagsSegments(tagFilterSqlExpression, marker, options)), _d.label = 1;
          case 1:
            return [4, __await(_a.next())];
          case 2:
            return _b = _d.sent(), !_b.done ? (segment = _b.value, [5, __values2(__asyncDelegator(__asyncValues(segment.blobs)))]) : [3, 6];
          case 3:
            return [4, __await.apply(void 0, [_d.sent()])];
          case 4:
            _d.sent(), _d.label = 5;
          case 5:
            return [3, 1];
          case 6:
            return [3, 13];
          case 7:
            return e_10_1 = _d.sent(), e_10 = {error: e_10_1}, [3, 13];
          case 8:
            return _d.trys.push([8, , 11, 12]), _b && !_b.done && (_c = _a.return) ? [4, __await(_c.call(_a))] : [3, 10];
          case 9:
            _d.sent(), _d.label = 10;
          case 10:
            return [3, 12];
          case 11:
            if (e_10)
              throw e_10.error;
            return [7];
          case 12:
            return [7];
          case 13:
            return [2];
        }
      });
    }, "findBlobsByTagsItems_1"));
  }, BlobServiceClient2.prototype.findBlobsByTags = function(tagFilterSqlExpression, options) {
    var _a, _this = this;
    options === void 0 && (options = {});
    var listSegmentOptions = __assign({}, options), iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);
    return _a = {
      next: function() {
        return iter.next();
      }
    }, _a[Symbol.asyncIterator] = function() {
      return this;
    }, _a.byPage = function(settings) {
      return settings === void 0 && (settings = {}), _this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, __assign({maxPageSize: settings.maxPageSize}, listSegmentOptions));
    }, _a;
  }, BlobServiceClient2.prototype.listSegments = function(marker, options) {
    return options === void 0 && (options = {}), __asyncGenerator(this, arguments, /* @__PURE__ */ __name(function() {
      var listContainersSegmentResponse;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!(!!marker || marker === void 0))
              return [3, 7];
            _a.label = 1;
          case 1:
            return [4, __await(this.listContainersSegment(marker, options))];
          case 2:
            return listContainersSegmentResponse = _a.sent(), listContainersSegmentResponse.containerItems = listContainersSegmentResponse.containerItems || [], marker = listContainersSegmentResponse.continuationToken, [4, __await(listContainersSegmentResponse)];
          case 3:
            return [4, __await.apply(void 0, [_a.sent()])];
          case 4:
            return [4, _a.sent()];
          case 5:
            _a.sent(), _a.label = 6;
          case 6:
            if (marker)
              return [3, 1];
            _a.label = 7;
          case 7:
            return [2];
        }
      });
    }, "listSegments_1"));
  }, BlobServiceClient2.prototype.listItems = function(options) {
    return options === void 0 && (options = {}), __asyncGenerator(this, arguments, /* @__PURE__ */ __name(function() {
      var marker, _a, _b, segment, e_11_1, e_11, _c;
      return __generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            _d.trys.push([0, 7, 8, 13]), _a = __asyncValues(this.listSegments(marker, options)), _d.label = 1;
          case 1:
            return [4, __await(_a.next())];
          case 2:
            return _b = _d.sent(), !_b.done ? (segment = _b.value, [5, __values2(__asyncDelegator(__asyncValues(segment.containerItems)))]) : [3, 6];
          case 3:
            return [4, __await.apply(void 0, [_d.sent()])];
          case 4:
            _d.sent(), _d.label = 5;
          case 5:
            return [3, 1];
          case 6:
            return [3, 13];
          case 7:
            return e_11_1 = _d.sent(), e_11 = {error: e_11_1}, [3, 13];
          case 8:
            return _d.trys.push([8, , 11, 12]), _b && !_b.done && (_c = _a.return) ? [4, __await(_c.call(_a))] : [3, 10];
          case 9:
            _d.sent(), _d.label = 10;
          case 10:
            return [3, 12];
          case 11:
            if (e_11)
              throw e_11.error;
            return [7];
          case 12:
            return [7];
          case 13:
            return [2];
        }
      });
    }, "listItems_1"));
  }, BlobServiceClient2.prototype.listContainers = function(options) {
    var _a, _this = this;
    options === void 0 && (options = {}), options.prefix === "" && (options.prefix = void 0);
    var include = [];
    options.includeDeleted && include.push("deleted"), options.includeMetadata && include.push("metadata");
    var listSegmentOptions = __assign(__assign({}, options), include.length > 0 ? {include} : {}), iter = this.listItems(listSegmentOptions);
    return _a = {
      next: function() {
        return iter.next();
      }
    }, _a[Symbol.asyncIterator] = function() {
      return this;
    }, _a.byPage = function(settings) {
      return settings === void 0 && (settings = {}), _this.listSegments(settings.continuationToken, __assign({maxPageSize: settings.maxPageSize}, listSegmentOptions));
    }, _a;
  }, BlobServiceClient2.prototype.getUserDelegationKey = function(startsOn, expiresOn2, options) {
    return options === void 0 && (options = {}), __awaiter(this, void 0, void 0, function() {
      var _a, span, spanOptions, response, userDelegationKey, res, e_12;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _a = createSpan("BlobServiceClient-getUserDelegationKey", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions, _b.label = 1;
          case 1:
            return _b.trys.push([1, 3, 4, 5]), [4, this.serviceContext.getUserDelegationKey({
              startsOn: truncatedISO8061Date(startsOn, !1),
              expiresOn: truncatedISO8061Date(expiresOn2, !1)
            }, {
              abortSignal: options.abortSignal,
              spanOptions
            })];
          case 2:
            return response = _b.sent(), userDelegationKey = {
              signedObjectId: response.signedObjectId,
              signedTenantId: response.signedTenantId,
              signedStartsOn: new Date(response.signedStartsOn),
              signedExpiresOn: new Date(response.signedExpiresOn),
              signedService: response.signedService,
              signedVersion: response.signedVersion,
              value: response.value
            }, res = __assign({_response: response._response, requestId: response.requestId, clientRequestId: response.clientRequestId, version: response.version, date: response.date, errorCode: response.errorCode}, userDelegationKey), [2, res];
          case 3:
            throw e_12 = _b.sent(), span.setStatus({
              code: import_api7.CanonicalCode.UNKNOWN,
              message: e_12.message
            }), e_12;
          case 4:
            return span.end(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, BlobServiceClient2.prototype.getBlobBatchClient = function() {
    return new BlobBatchClient(this.url, this.pipeline);
  }, BlobServiceClient2.prototype.generateAccountSasUrl = function(expiresOn2, permissions, resourceTypes, options) {
    if (permissions === void 0 && (permissions = AccountSASPermissions.parse("r")), resourceTypes === void 0 && (resourceTypes = "sco"), options === void 0 && (options = {}), !(this.credential instanceof StorageSharedKeyCredential))
      throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
    if (expiresOn2 === void 0) {
      var now = new Date();
      expiresOn2 = new Date(now.getTime() + 3600 * 1e3);
    }
    var sas = generateAccountSASQueryParameters(__assign({
      permissions,
      expiresOn: expiresOn2,
      resourceTypes,
      services: AccountSASServices.parse("b").toString()
    }, options), this.credential).toString();
    return appendToURLQuery(this.url, sas);
  }, BlobServiceClient2;
}(StorageClient);

// cache/index.ts
var import_cache3 = __toModule(require_cache()), import_core = __toModule(require_core()), import_fs2 = __toModule(require("fs")), import_util3 = __toModule(require("util"));

// utils/BuildSizes.ts
var import_glob = __toModule(require_glob()), import_fs = __toModule(require("fs")), import_path = __toModule(require("path")), import_zlib2 = __toModule(require("zlib"));
async function computeFileSize(filename) {
  let buffer = await import_fs.promises.readFile(filename);
  return new Promise((resolve, reject) => {
    import_zlib2.brotliCompress(buffer, (error, result) => {
      error ? reject(error) : resolve(result.byteLength);
    });
  });
}
__name(computeFileSize, "computeFileSize");
function isValidFile(filename) {
  return /\.(js|css)$/.test(filename) && !/service-worker\.js$/.test(filename) && !/precache-manifest\.[0-9a-f]+\.js$/.test(filename);
}
__name(isValidFile, "isValidFile");
function getFileNameKey(filename, buildPath) {
  return import_path.default.relative(buildPath, filename).replace(/\.([a-f0-9])+\./, ".[hash].");
}
__name(getFileNameKey, "getFileNameKey");
async function getBuildSizes(dir) {
  let globber = await import_glob.create(dir), [buildPath] = globber.getSearchPaths(), sizes = {};
  for await (let filename of globber.globGenerator()) {
    if (!isValidFile(filename))
      continue;
    let key = getFileNameKey(filename, buildPath);
    sizes[key] = await computeFileSize(filename);
  }
  return sizes;
}
__name(getBuildSizes, "getBuildSizes");

// utils/BuildSnapshotMeta.ts
var import_os2 = __toModule(require("os")), import_path2 = __toModule(require("path"));
function getBuildSnapshotMeta({
  sha,
  label
}) {
  let name = `build-size-v1-${label}`, restoreKey = `${name}-`;
  return {
    key: restoreKey + sha,
    restoreKey,
    filename: import_path2.default.join(import_os2.default.tmpdir(), `${name}.json`)
  };
}
__name(getBuildSnapshotMeta, "getBuildSnapshotMeta");

// cache/index.ts
main().catch(import_core.setFailed);
async function main() {
  let dir = import_core.getInput("dir", {required: !0}), sha = import_core.getInput("sha", {required: !0}), label = import_core.getInput("label", {required: !0}), meta = getBuildSnapshotMeta({sha, label});
  if (import_core.info(import_util3.format('Checking cache for the key "%s"\u2026', meta.key)), await import_cache3.restoreCache([meta.filename], meta.key)) {
    import_core.info("Cache hit, finishing the job\u2026");
    return;
  }
  import_core.info(import_util3.format('Computing build size of the "%s"\u2026', dir));
  let sizes = await getBuildSizes(dir);
  import_core.info(import_util3.format("Computed file sizes: %j", sizes)), await import_fs2.promises.writeFile(meta.filename, JSON.stringify(sizes), "utf-8"), import_core.info(import_util3.format('Writing "%s" to "%s" cache.', meta.filename, meta.key));
  try {
    await import_cache3.saveCache([meta.filename], meta.key);
  } catch (error) {
    if (error instanceof import_cache3.ReserveCacheError)
      import_core.warning(error);
    else
      throw error;
  }
}
__name(main, "main");
